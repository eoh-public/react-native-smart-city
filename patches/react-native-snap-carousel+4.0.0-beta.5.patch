diff --git a/node_modules/react-native-snap-carousel/.eslintrc b/node_modules/react-native-snap-carousel/.eslintrc
new file mode 100644
index 0000000..d4739ac
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/.eslintrc
@@ -0,0 +1,38 @@
+{
+    "parser"  : "babel-eslint",
+    "extends" : [
+        "standard",
+        "standard-react"
+     ],
+     "plugins": [
+         "react"
+     ],
+    "env" : {
+        "browser" : true,
+        "es6": true
+    },
+    "globals": {
+        "__DEV__": false
+    },
+    "parserOptions": {
+        "ecmaVersion": 6,
+        "ecmaFeatures": {
+            "jsx": true
+        }
+    },
+    "rules": {
+        "generator-star-spacing": 0,
+        "indent": [2, 4, { "ignoredNodes": ["JSXAttribute", "JSXSpreadAttribute"], "SwitchCase": 1 }],
+        "no-warning-comments": [1, {
+            "terms": ["todo", "fixme", "xxx"],
+            "location": "start"
+        }],
+        "operator-linebreak": [2, "after"],
+        "padded-blocks": 0,
+        "semi": [2, "always"],
+        "react/jsx-indent-props": [2, 2],
+        "react/jsx-boolean-value": [0, "never"],
+        "react/jsx-curly-spacing": [0, "never"],
+        "react/jsx-indent": [2, 4]
+    }
+}
diff --git a/node_modules/react-native-snap-carousel/.vscode/settings.json b/node_modules/react-native-snap-carousel/.vscode/settings.json
new file mode 100644
index 0000000..a6fb976
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/.vscode/settings.json
@@ -0,0 +1,3 @@
+{
+    "eslint.enable": true
+}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/ISSUE_TEMPLATE.md b/node_modules/react-native-snap-carousel/ISSUE_TEMPLATE.md
new file mode 100644
index 0000000..0629ddc
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/ISSUE_TEMPLATE.md
@@ -0,0 +1,129 @@
+<!--
+  MAKE SURE TO READ AND FOLLOW THIS TEMPLATE CLOSELY OR YOUR ISSUE WILL BE CLOSED WITHOUT NOTICE
+-->
+
+### Is this a bug report, a feature request, or a question?
+
+(Write your answer here.)
+
+<!--
+  If you answered "Bug report":
+
+    We expect you to produce a high-quality bug report since putting care into your report helps us fix the issue faster.
+    For bug reports, it is REQUIRED to fill the rest of this template, or the issue will be closed.
+
+  If you answered "Feature request" or "Question":
+
+    Make sure to describe as precisely as possible the feature you'd like to see implemented or the question you'd like to see answered.
+    When relevant, provide visual examples (screenshots, screencasts, diagrams...).
+    You can ignore the next steps as long as you've made sure that your description is as clear, thorough and illustrated as possible.
+-->
+
+### Have you followed the required steps before opening a bug report?
+
+(Check the step you've followed - put an `x` character between the square brackets (`[]`).)
+
+- [] I have read [the guidelines regarding bug report](https://github.com/archriss/react-native-snap-carousel/blob/master/CONTRIBUTING.md).
+- [] I have reviewed [the documentation](https://github.com/archriss/react-native-snap-carousel/blob/master/README.md) in its entirety, including the dedicated documentations :books:.
+- [] I have searched for [existing issues](https://github.com/archriss/react-native-snap-carousel/issues) and made sure that the problem hasn't already been reported.
+- [] I am using [the latest plugin version](https://github.com/archriss/react-native-snap-carousel/releases).
+- [] I am following [the issue template](https://raw.githubusercontent.com/archriss/react-native-snap-carousel/master/ISSUE_TEMPLATE.md) closely in order to produce a useful bug report.
+
+<!--
+  Please DO NOT go futher if you've not followed ALL of the above steps.
+  Failing to do so will result in your issue getting closed without warning.
+-->
+
+### Have you made sure that it wasn't a [React Native bug](https://github.com/archriss/react-native-snap-carousel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22react-native+bug%22+)?
+
+(Write your answer here.)
+
+<!--
+  Steps you should take:
+
+    1. Take a look at plugin's issues that are [labelled `react-native bug`](https://github.com/archriss/react-native-snap-carousel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22react-native+bug%22+)
+
+    2. Search [React Native issues](https://github.com/facebook/react-native/issues)
+
+    3. Read the following sections of the doc again: ["Known issues"](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/KNOWN_ISSUES.md), ["Important note regarding Android"](https://github.com/archriss/react-native-snap-carousel#important-note-regarding-android), and ["Custom interpolations caveats"](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md#caveats).
+ -->
+
+### Is the bug specific to iOS or Android? Or can it be reproduced on both platforms?
+
+(Write your answer here and specify the iOS/Android versions on which you've been able to reproduce the issue.)
+
+### Is the bug reproductible in a production environment (not a debug one)?
+
+(Write your answer here.)
+
+<!--
+  If you haven't been able to reproduce the bug in production mode, it probably has to do with React Native's limitations (see ["Known issues"](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/KNOWN_ISSUES.md)). Chances are we won't be able to do anything about it.
+-->
+
+### Environment
+
+<!--
+  Provide information about your current environment. At the very least, it should include the following:
+
+  Environment:
+    React: 16.0.0-beta.5
+    React native: 0.49.2
+    react-native-snap-carousel: 3.3.4
+
+  Target Platform:
+    Android (6.0)
+    iOS (10.3)
+-->
+
+(Write your answer here.)
+
+### Expected Behavior
+
+<!--
+  How did you expect your project to behave?
+  It’s fine if you’re not sure your understanding is correct.
+  Just write down what you thought would happen.
+-->
+
+(Write what you thought would happen.)
+
+### Actual Behavior
+
+<!--
+  Did something go wrong?
+  Is something broken, or not behaving as you expected?
+  Describe this section in detail, and attach screencasts (or screenshots) if possible.
+  Don't just say "it doesn't work"!
+-->
+
+(Write what happened. Add screencasts/screenshots!)
+
+### Reproducible Demo
+
+(Paste the link to a [Snack example](https://snack.expo.io/) in which the issue can be reproduced. Please follow [the guidelines](https://stackoverflow.com/help/mcve) for providing a Minimal, Complete, and Verifiable example.)
+
+<!--
+  This step is MANDATORY:
+
+    * It shows that you value and respect the time of the people that are willing to help you; no one wishes to waste his spare time trying to recreate someone else's problem.
+    * Issues without reproducible demos have an extremely low priority and will probably be closed without notice.
+    * You might figure out the issues yourself as you work on extracting it.
+-->
+
+### Steps to Reproduce
+
+<!--
+  How would you describe your issue to someone who doesn’t know you or your project?
+  Write a sequence of steps that anybody can repeat to see the issue.
+  Be specific! If the bug cannot be reproduced, your issue will be closed.
+-->
+
+(Write your steps so that anyone can reproduce the issue in the Snack demo you provided.)
+
+1.
+2.
+3.
+
+<!--
+  Thanks for helping us help you!
+-->
diff --git a/node_modules/react-native-snap-carousel/doc/CUSTOM_INTERPOLATIONS.md b/node_modules/react-native-snap-carousel/doc/CUSTOM_INTERPOLATIONS.md
new file mode 100644
index 0000000..687712b
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/CUSTOM_INTERPOLATIONS.md
@@ -0,0 +1,298 @@
+# Implementing custom interpolations
+
+> :warning: **This guide describes an advanced feature that is not intended for the faint-hearted**. Your sanity will be seriously challenged by the two most-feared enemies of this plugin: Android and React Native's `FlatList`. You **will** discover bugs that will drive you mad and, as a result, your aging process will accelerate drastically. Consider yourself warned and make sure to read [the caveats](#caveats) first and foremost!
+
+## Table of contents
+
+1. [Preview](#preview)
+1. [Usage](#usage)
+1. [Step-by-step example](#step-by-step-example)
+1. [Caveats](#caveats)
+
+## Preview
+
+Version `3.6.0` introduced a new cool feature: layouts. On top of the default one, we've implemented two other ways of stacking and animating items in the carousel. You can choose between these with [prop `layout`](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/PROPS_METHODS_AND_GETTERS.md#style-and-animation). Here how each one looks like (the reason why iOS and Android are differents [will be explained later](#caveats)):
+
+![react-native-snap-carousel default layout](https://i.imgur.com/e1WbZcu.gif)
+```javascript
+<Carousel layout={'default'} />
+```
+
+![react-native-snap-carousel stack layout ios](https://i.imgur.com/c7pU4rT.gif)
+![react-native-snap-carousel stack layout android](https://i.imgur.com/AnruacR.gif)
+```javascript
+<Carousel layout={'stack'} />
+```
+
+![react-native-snap-carousel tinder layout ios](https://i.imgur.com/D9QyTzb.gif)
+![react-native-snap-carousel tinder layout android](https://i.imgur.com/ab1TI4e.gif)
+```javascript
+<Carousel layout={'tinder'} />
+```
+
+We are able to do all this thanks to React Native's great [Animated API](https://facebook.github.io/react-native/docs/animations.html). Basically, we interpolate the current scroll position and provide to each item a set of animations based on this value. But those new layouts are just the tip of the iceberg. You can easily create others like these ones:
+
+![react-native-snap-carousel custom layout](https://i.imgur.com/slnTbyG.gif)
+![react-native-snap-carousel custom layout](https://i.imgur.com/OrdLsCM.gif)
+![react-native-snap-carousel custom layout](https://i.imgur.com/Nht4w9D.gif)
+![react-native-snap-carousel custom layout](https://i.imgur.com/kDx3xTc.gif)
+
+We've decided to expose a way for users to provide their own interpolators, customize their carousels and create awesome animations! Note that you can find the source code of the built-in layouts [here](https://github.com/archriss/react-native-snap-carousel/blob/master/src/utils/animations.js) and the source code of the custom examples [here](https://github.com/archriss/react-native-snap-carousel/blob/master/example/src/utils/animations.js). Taking a look at these is a very good way to understand how it works.
+
+## Usage
+
+### Prerequisites
+
+- You have some experience with React Native's [Animated API](https://facebook.github.io/react-native/docs/animations.html).
+- You have a good understanding of [Animated's interpolations](https://github.com/browniefed/react-native-animation-book/blob/master/INTERPOLATION.md).
+- You've read and understood [the caveats](#caveats).
+- You are known for both your mental toughness and the peace of your mind.
+
+### Summary
+
+Adding a custom interpolation is done by providing either one of these props (but most likely both): `scrollInterpolator` and `slideInterpolatedStyle`.
+
+:bulb: You cannot use prop `activeAnimationOptions` in conjunction with custom interpolations. Make sure it isn't set since the scroll position will simply not be interpolated otherwise.
+
+### Prop `scrollInterpolator`
+
+This prop will be used to interpolate the scroll position. Particularly, this means associating a specific scroll position to a specific value that is going to be used in `slideInterpolatedStyle` in order to animate styles.
+
+`scrollInterpolator` **has to be a function**. It will be called for every item in the data set on carousel's initialization and **it will receive two arguments: `index` and `carouselProps`**. The first one is the item index and the second one contains every carousel props since you might need them to define your interpolation. **The function must return an object of the following shape:**
+
+```javascript
+{
+    inputRange: [scroll value 1, scroll value 2, ...],
+    outputRange: [value associated with 1, value associated with 2, ...],
+}
+```
+
+> :warning: **Both arrays must have the same length**, otherwise you'll get an error.
+
+Since it can be pretty difficult to determine the adequate `inputRange` we've created a helper for you: [`getInputRangeFromIndexes(range, index, carouselProps)`](https://github.com/archriss/react-native-snap-carousel/blob/master/src/utils/animations.js#L5:L24). You only need to determine the range of items **relative to the active one** you'd like to animate at the same time. The current item will be zero-indexed in this function. For example, using a range of `[1, 0, -1]` means that you will be able to animate the current active item (`0`), the previous one (`-1)` and the next one (`1`).
+
+> :warning: As you might have noticed, **when using `getInputRangeFromIndexes()` you need to declare your range in a reverse order**. While this is pretty counter-intuitive, you'll otherwise get an error because `"inputRange must be monotonically increasing"`.
+
+### Prop `slideInterpolatedStyle`
+
+This prop is where the magic happens and where you're finally able to bend item's animation to your will. **`slideInterpolatedStyle` must be a function that returns a style object. It will receive three arguments: `index`, `animatedValue` and `carouselProps`.** The first and the last one are the same as the ones passed in `scrollInterpolator`, while `animatedValue` correspond with the animated value of carousel's scroll position.
+
+Based on the range you declared in `scrollInterpolator`, you can now interpolate values and do whatever you want.
+
+> :bulb: Unlike what you need to do in `scrollInterpolator`, the `inputRange` you declare in `slideInterpolatedStyle` has to be in a regular order.
+
+Consider the following:
+
+```javascript
+function animatedStyle = (index, animatedValue, carouselProps) => {
+    return {
+        opacity: animatedValue.interpolate({
+            inputRange: [-1, 0, 1],
+            outputRange: [0, 1, 0.5],
+            extrapolate: 'clamp'
+        })
+    }
+}
+```
+
+It will translate into:
+- item `-1` (the previous one) will have an opacity of `0`
+- item `0` (the active one) will have an opacity of `1`
+- item `1` (the next one) will have an opacity of `0.5`.
+
+When you scroll, items' opacity will progressively animate from one value to the next, following the scroll position.
+
+: bulb: Using `extrapolate: 'clamp'` will prevent your interpolation to exceed `outputRange`'s values, the "clamping" being desirable with most use cases. From [the RN doc](https://facebook.github.io/react-native/docs/animations.html#interpolation): *"By default, it will extrapolate the curve beyond the ranges given, but you can also have it clamp the output value."*
+
+## Step-by-step example
+
+It is recommended to take a look at [the source code of the built-in layouts](https://github.com/archriss/react-native-snap-carousel/blob/master/src/utils/animations.js) and at [the source code the custom examples](https://github.com/archriss/react-native-snap-carousel/blob/master/example/src/utils/animations.js); you'll learn a lot!
+
+For those who want to follow through a step-by-step tutorial, the following is for you.
+
+### Defining the scroll interpolator
+
+Let's say we want to create a photo album effect: when swiping, the active item will move away and the next ones will appear from underneath. Of course, these items are going to be slightly rotated.
+
+First things first: for which items do we need to create a custom animation?
+- Item `-1`: the item that has been moved away.
+- Item `0`: the active item.
+- Items `1` and `2`: underneath rotated items.
+- Item `3`: invisible item that will make item `2` appear with an opacity transition.
+
+With this clarified, declaring the scroll interpolator is as simple as :
+
+```javascript
+import { getInputRangeFromIndexes } from 'react-native-snap-carousel';
+
+function scrollInterpolator (index, carouselProps) {
+    const range = [3, 2, 1, 0, -1]; // <- Remember that this has to be declared in a reverse order
+    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
+    const outputRange = range;
+
+    return { inputRange, outputRange };
+}
+```
+
+### Creating the animations
+
+This is where the fun begins!
+
+The first trick is **to ensure that the active item will always sit on top of the next ones**. By default, an item with a higher index will also have a higher `zIndex`. To counteract this, you can use the following. :warning: **Currently, this can lead to swipe/click events being missed!** See [this issue](https://github.com/archriss/react-native-snap-carousel/issues/262) for more info.
+
+```javascript
+{
+    zIndex: carouselProps.data.length - index
+}
+```
+
+Then we can define the `opacity` animation. Since we only need a transition between the second and third items, declaring it is pretty straightforward:
+
+```javascript
+opacity: animatedValue.interpolate({
+    inputRange: [2, 3],
+    outputRange: [1, 0]
+})
+```
+
+Now for the `rotate` animation. The active item and the third one won't be rotated at all, while the previous one will be in order to add a nice visual effect when swiping. Read [this](https://facebook.github.io/react-native/docs/animations.html#interpolation) if you need an explanation of the `extrapolate` property.
+
+```javascript
+transform: [{
+    rotate: animatedValue.interpolate({
+        inputRange: [-1, 0, 1, 2, 3], // <- Unlike with `scrollInterpolator()`, this is declared in a regular order
+        outputRange: ['-25deg', '0deg', '-3deg', '1.8deg', '0deg'],
+        extrapolate: 'clamp'
+    })
+}]
+```
+
+The tricky part is the `transform` animation. First, we need to ensure that our animated items are all centered in the carousel. To do that, we need to apply a translation equals to: **`-itemWidth` (or `-itemHeight` for vertical sliders) * relative index**. Then, we want item `-1` to move a bit more quickly than the others, which means negatively translating it. Finally, it's a good idea to make our animations compatible with both horizontal and vertical carousels. Hence the following:
+
+```javascript
+const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
+const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
+
+return {
+    transform: [{
+        [translateProp]: animatedValue.interpolate({
+            inputRange: [-1, 0, 1, 2, 3],
+            outputRange: [
+                -sizeRef * 0.5,
+                0,
+                -sizeRef, // centered
+                -sizeRef * 2, // centered
+                -sizeRef * 3 // centered
+            ],
+            extrapolate: 'clamp'
+        })
+    }]
+};
+```
+
+Let's put it all together:
+
+```javascript
+import React, { PureComponent } from 'react';
+import Carousel, { getInputRangeFromIndexes } from 'react-native-snap-carousel';
+
+export default class MyCustomCarousel extends PureComponent {
+
+    _scrollInterpolator (index, carouselProps) {
+        const range = [3, 2, 1, 0, -1];
+        const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
+        const outputRange = range;
+
+        return { inputRange, outputRange };
+    }
+
+    _animatedStyles (index, animatedValue, carouselProps) {
+        const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
+        const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
+
+        return {
+            zIndex: carouselProps.data.length - index,
+            opacity: animatedValue.interpolate({
+                inputRange: [2, 3],
+                outputRange: [1, 0]
+            }),
+            transform: [{
+                rotate: animatedValue.interpolate({
+                    inputRange: [-1, 0, 1, 2, 3],
+                    outputRange: ['-25deg', '0deg', '-3deg', '1.8deg', '0deg'],
+                    extrapolate: 'clamp'
+                })
+            }, {
+                [translateProp]: animatedValue.interpolate({
+                    inputRange: [-1, 0, 1, 2, 3],
+                    outputRange: [
+                        -sizeRef * 0.5,
+                        0,
+                        -sizeRef, // centered
+                        -sizeRef * 2, // centered
+                        -sizeRef * 3 // centered
+                    ],
+                    extrapolate: 'clamp'
+                })
+            }]
+        };
+    }
+
+    render () {
+        return (
+            <Carousel
+              // other props
+              scrollInterpolator={this._scrollInterpolator}
+              slideInterpolatedStyle={this._animatedStyles}
+              useScrollView={true}
+            />
+        );
+    }
+}
+```
+
+Here is the result, which you can try live in [the provided example](https://github.com/archriss/react-native-snap-carousel/tree/master/example):
+
+![react-native-snap-carousel custom layout](https://i.imgur.com/slnTbyG.gif)
+
+:pill: Now for the bad news: **as is, this example won't be properly rendered on Android**. Continue reading to find out why and to discover ways to make it work.
+
+## Caveats
+
+### Android
+
+If you have any kind of experience with React Native, you already know that Android is always there to punch you in the face when you make the mistake of thinking that everything is fine.
+
+The issue here is pretty simple but very sad: [Android doesn't honor the `zIndex` property for `ScrollView`'s items](https://github.com/facebook/react-native/issues/16878). In concrete terms, this means that all items **after** the current active one will visually sit on top of it. Usually, you won't want that to happen.
+
+For most layouts, you will probably use the following trick to render the active item on top of the next ones (as seen in the 'stack' layout, the 'tinder' layout, the step-by-step example, and more):
+
+```javascript
+{ zIndex: carouselProps.data.length - index }
+```
+
+Well, do not bother doing so on Android since it just won't work... As far as we know, you have three ways of dealing with this matter:
+- **Use Android-specific prop `elevation`** -> `{ elevation: carouselProps.data.length - index }`. While this will work from a visual point of view, it has two major drawbacks: you will generate shadows (which you can "cut" with a container) and, more importantly, it has no effect over the rendering hierarchy. This means that **the item receving the tap event is not going to be the active one**. Pretty bothersome, right? Still, if you don't provide user interaction, this solution can be enough.
+- **Invert the effect**. This is what has been done for the built-in layouts. Since the active item will always sits on top of the previous one on Android, background cards are made of the previous items instead of the next ones.
+- **Use `FlatList`'s prop `inverted` with a reverse data set**. This provides the perfect transition to our second main problem...
+
+
+### The `FlatList` component
+
+`FlatList` is buggy as hell, period.
+
+With custom interpolations, what you're most likely to experience is... nothing! Your incredible animations are not going to be played because the next and previous items are going to show up too late to the party.
+
+Two solutions:
+- **Play with the following `FlatList` props** until you find something that suits your needs (or not): `initialNumToRender`, `maxToRenderPerBatch`, `windowSize` and `updateCellsBatchingPeriod`.
+- **Set `useScrollView` to `true` and/or `removeClippedSubviews` to `false`**. End of the bugs. :warning: This is a trade-off: you will have to forget about the performance optimizations that *are supposed* to come with `FlatList`, but your sanity will be preserved. We've chosen this solution for the 'stack' and 'tinder' layouts. **Bear in mind that this solution is not suited for large data sets.**
+
+### Others
+
+We use the native driver to ensure smooth animations and prevent performance issues. As stated [in RN doc](https://facebook.github.io/react-native/docs/animations.html#caveats): *"Not everything you can do with Animated is currently supported by the native driver. The main limitation is that **you can only animate non-layout properties: things like `transform` and `opacity` will work, but flexbox and position properties will not**."*.
+
+## What's next?
+
+We hope that you find this feature as awesome and useful as we are. Now go create awesome animations!
+
+We only ask for one thing in return: **please share with us your most interesting interpolations!**
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/doc/KNOWN_ISSUES.md b/node_modules/react-native-snap-carousel/doc/KNOWN_ISSUES.md
new file mode 100644
index 0000000..78f33fe
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/KNOWN_ISSUES.md
@@ -0,0 +1,75 @@
+# Known issues
+
+## Table of contents
+
+1. [`FlatList` and `ScrollView`'s limitations](#flatlist-and-scrollviews-limitations)
+1. [React Native version](#react-native-version)
+1. [Android performance](#android-performance)
+1. [Unreliable callbacks](#unreliable-callbacks)
+1. [Unreliable first item](#unreliable-first-item)
+1. [Error with Jest](#error-with-jest)
+1. [RTL support (experimental)](#rtl-support-experimental)
+
+## `FlatList` and `ScrollView`'s limitations
+
+Note that this plugin is built on top of React Native's `FlatList` which, in turn, is based on `VirtualizedList` and `ScrollView`. Unfortunately, their implementations have flaws that affect the plugin, the most problematic ones being the following:
+- there is no `scrollEnd` event
+- `scrollTo` method doesn't accept any callback
+- Android's `scrollTo` animation is quite brutal
+- it is not possible to specify a scroll duration
+- there are rendering and performance issues with the `FlatList` component.
+
+On top of that, `FlatList` has [its own set of bugs and buggy behaviors](https://github.com/facebook/react-native/issues?utf8=%E2%9C%93&q=flatlist).
+
+We're trying to work around these issues, but the result is not always as smooth as we'd want it to be. **You can help by letting the React Native team know how badly we need those features!** React Native has [a dedicated canny](https://react-native.canny.io/feature-requests) for feature requests; here are the ones that need your vote the most:
+- [[ScrollView] Add completion callback to scrollTo](https://react-native.canny.io/feature-requests/p/scrollview-add-completion-callback-to-scrollto)
+- [snapToInterval for Android](https://react-native.canny.io/feature-requests/p/snaptointerval-for-android)
+- [Add speed attribute to scrollTo](https://react-native.canny.io/feature-requests/p/add-speed-attribute-to-scrollto)
+- [Bring ios only methods to Android ScrollView](https://react-native.canny.io/feature-requests/p/bring-ios-only-methods-to-android-scrollview)
+- [ScrollView Animation Events (e.g. onScrollAnimationEnd)](https://react-native.canny.io/feature-requests/p/scrollview-animation-events-eg-onscrollanimationend)
+
+Remember that every vote counts and take a look at [#203](https://github.com/archriss/react-native-snap-carousel/issues/203) for more info!
+
+## React Native version
+
+:warning: **RN 0.43.x is the minimum recommended version for plugin releases `>= 3.0.0` since it was the first version to introduce the `FlatList` component.** Since version `3.5.0`, the component will fall back to rendering a `ScrollView` if you're using an older version of React Native (mirroring the effect of setting prop `useScrollView` to `true`). **But keep in mind that the `ScrollView` component is not suited to render a huge number of items.** If you experience performance issues, consider updating your React Native version and using the default `FlatList` version.
+
+Bear in mind that we follow RN evolutions closely, which means newer versions of the plugin might break when used in conjunction with a version of RN that is not the latest stable one.
+
+## Android performance
+
+:warning: **Make sure to test carousel's performance and behavior without JS Dev Mode enabled, ideally with a production build.**.
+
+It can take user experience from "crappy and sluggish" to "pretty good" - it's Android though, so nothing like "perfect" or "incredibly smooth"...
+
+Also, make sure to implement all the recommendations listed [here](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/TIPS_AND_TRICKS.md#optimizing-performance).
+
+## Unreliable callbacks
+
+When `enableMomentum` is disabled (default behavior), providing a reliable callback is really tricky since no `scrollEnd` event has been exposed yet for the `ScrollView` component. We can only rely on the `scrollEndDrag` event, which comes with a huge bunch of issues. See [#34](https://github.com/archriss/react-native-snap-carousel/issues/34) for more information.
+
+Version 2.3.0 tackled these issues with all sorts of flags and hacks. But you could still be facing the following one: **when you build a debug version of your app without enabling JS remote debugging, timers may desynchronize and cause a complete callback mess**. Try to either enable remote debugging or build a production version of your app, and everything should get back to normal.
+
+Callback handling has been completely revamped in version 3.2.0, in a less hacky and more reliable way. There is one issue though: callbacks now rely on scroll events. Usually, this is not a problem since the plugin features a native-powered scroll. **But there has been [a regression in React Native 0.46.x](https://github.com/facebook/react-native/issues/15769), that has been fixed in version 0.48.2.**
+
+If you're using an in-between version, you're in for some trouble since events won't be fired frequently enough (particularly on Android). **We've added a prop `callbackOffsetMargin` to help with this situation.**
+
+## Unreliable first item
+
+By design, **the `FlatList` component only renders a small chunk if items initially**.
+
+This means **you may need to rely on inherited props [`getItemLayout`](https://facebook.github.io/react-native/docs/flatlist#getitemlayout) & [`initialScrollIndex`](https://facebook.github.io/react-native/docs/flatlist#initialscrollindex) to get the `firstItem` prop to work properly** (usable from version `3.8.3` on).
+
+## Error with Jest
+
+You might encounter the following error when using the plugin in conjonction with Jest: `TypeError: Cannot read property 'style' of undefined at Object.<anonymous>`.
+
+As you can see [here](https://github.com/facebook/react-native/blob/master/jest/setup.js), this is because React Native mocks `ScrollView` for you when you write unit tests with Jest.
+
+The easiest workaround is to add `jest.unmock('ScrollView')` before importing the component in your test file (thanks [@hoangnm](https://github.com/hoangnm) for the tip!).
+
+## RTL support (experimental)
+
+Since version 2.1.0, the plugin is compatible with RTL layouts. Our implementation relies on miscellaneous hacks that work around a [React Native bug](https://github.com/facebook/react-native/issues/11960) with horizontal `ScrollView`. As such, this feature should be considered experimental since it might break with newer versions of React Native.
+
+Note that you may want to reverse the order of your data array for your items to be displayed in the proper RTL order. We've tried implementing it internally, but this led to numerous and unnecessary issues. You'll just have to do something as simple as `myCustomData.reverse()`.
diff --git a/node_modules/react-native-snap-carousel/doc/PAGINATION.md b/node_modules/react-native-snap-carousel/doc/PAGINATION.md
new file mode 100644
index 0000000..fdb44de
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/PAGINATION.md
@@ -0,0 +1,96 @@
+# `<Pagination />` component
+
+Starting with version `2.4.0`, a customizable `<Pagination />` component has been added. This is how it looks like with its default configuration:
+
+![react-native-snap-carousel pagination](https://i.imgur.com/FLQcGGL.gif)
+
+## Table of contents
+
+1. [Props](#props)
+1. [Note on dots' colors](#note-on-dots-colors)
+1. [Usage](#usage)
+
+## Props
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+**`activeDotIndex`** | Index of the currently active dot | Number | **Required**
+**`dotsLength`** | Number of dots to display | Number | **Required**
+`activeOpacity` | Opacity of the dot when tapped. The prop has no effect if `tappableDots` hasn't been set to `true`. | Number | 1
+`carouselRef` | Reference to the `Carousel` component to which pagination is linked. Needed only when setting `tappableDots` to `true`. | Object | `undefined`
+`containerStyle` | Style for dots' container that will be merged with the default one | View Style Object | `{}`
+`dotColor` | Background color of the active dot. **Use this if you want to animate the change between active and inactive colors**, and always in conjunction with `inactiveDotColor` (see [notes](#dots-colors)). | String | `undefined`
+`dotContainerStyle` | Style of each dot's container. Use this if you need to specify styles that wouldn't have any effect when defined with `dotStyle` (such as `flex`). | View Style Object | `{}`
+`dotElement` | Optional custom active dot element that will replace the default one. The element will receive a prop `active` set to `true` as well as a prop `index`. | React element | `undefined`
+`dotStyle` | Dots' style that will be merged with the default one | View Style Object | `{}`
+`inactiveDotColor` | Background color of the inactive dots. **Use this if you want to animate the change between active and inactive colors**, and always in conjunction with `dotColor` (see [notes](#dots-colors)). | String | `undefined`
+`inactiveDotElement` | Optional custom inactive dot element that will replace the default one. The element will receive a prop `active` set to `false` as well as a prop `index` | React element | `undefined`
+`inactiveDotOpacity` | Value of the opacity effect applied to inactive dots | Number | `0.5`
+`inactiveDotScale` | Value of the 'scale' transform applied to inactive dots | Number | `0.5`
+`inactiveDotStyle` | Dots' style that will be applied to inactive elements | View Style Object | `{}`
+`renderDots` | Function that gives you complete control over pagination's rendering. It will receive three parameters : `(activeIndex, total, context)`. This can be especially useful in order to replace dots with numbers. **:warning: You will need to provide your own logic to handle taps. See [this comment](https://github.com/archriss/react-native-snap-carousel/issues/273#issuecomment-368295203) for more info.** | Function | `undefined`
+`tappableDots` | Make default dots tappable, e.g. your carousel will slide to the corresponding item. Note that `carouselRef` must be specified for this to work. | Boolean | `false`
+`vertical` | Whether to layout dots vertically or horizontally | Boolean | `false`
+`animatedDuration` | Length of dot animation (milliseconds) | Number | `250`
+`animatedFriction` | Controls "bounciness"/overshoot on dot animation | Number | `4`
+`animatedTension` | Controls speed dot animation | Number | `50`
+`delayPressInDot` | Delay in ms, from the start of the touch, before onPressIn is called on dot | Number | `0`
+
+## Note on dots' colors
+If your active and inactive dots aren't of the same color, you have a choice to make:
+1. either animate the color transition by specifying both `dotColor` and `inactiveDotColor`
+1. or setting `{ backgroundColor }` in both `dotStyle` and `inactiveDotStyle`.
+
+**When animating the color transition, the dot component will no longer be able to use the native driver for scale and opacity transitions.** As stated in [React Native's doc](https://facebook.github.io/react-native/docs/animations.html#caveats), color animations aren't supported by the native driver. And, unfortunately, it doesn't seem currently possible to run native-powered and js-powered animations at the same time on the same element.
+
+Basically, this is a tradeoff between color transition and optimal smoothness. We recommended you to try the first version and, if you experiment performance drops, to settle for the second one.
+
+## Usage
+
+Since `<Pagination />` is, purposely, a separated component, you need to connect it to your `<Carousel />` component manually. This is pretty straightforward, but here is an example to get you started.
+
+```javascript
+import Carousel, { Pagination } from 'react-native-snap-carousel';
+
+export default class MyCarousel extends Component {
+
+    _renderItem ({item, index}) {
+        return <MySlideComponent data={item} />
+    }
+
+    get pagination () {
+        const { entries, activeSlide } = this.state;
+        return (
+            <Pagination
+              dotsLength={entries.length}
+              activeDotIndex={activeSlide}
+              containerStyle={{ backgroundColor: 'rgba(0, 0, 0, 0.75)' }}
+              dotStyle={{
+                  width: 10,
+                  height: 10,
+                  borderRadius: 5,
+                  marginHorizontal: 8,
+                  backgroundColor: 'rgba(255, 255, 255, 0.92)'
+              }}
+              inactiveDotStyle={{
+                  // Define styles for inactive dots here
+              }}
+              inactiveDotOpacity={0.4}
+              inactiveDotScale={0.6}
+            />
+        );
+    }
+
+    render () {
+        return (
+            <View>
+                <Carousel
+                  data={this.state.entries}
+                  renderItem={this._renderItem}
+                  onSnapToItem={(index) => this.setState({ activeSlide: index }) }
+                />
+                { this.pagination }
+            </View>
+        );
+    }
+```
diff --git a/node_modules/react-native-snap-carousel/doc/PARALLAX_IMAGE.md b/node_modules/react-native-snap-carousel/doc/PARALLAX_IMAGE.md
new file mode 100644
index 0000000..3527310
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/PARALLAX_IMAGE.md
@@ -0,0 +1,196 @@
+# `<ParallaxImage />` component
+
+Version `3.0.0` introduced a `<ParallaxImage />` component, an image component aware of carousel's current scroll position and therefore able to display a nice parallax effect (powered by the native driver to ensure top-notch performance).
+
+![react-native-snap-carousel parallax image](https://i.imgur.com/6iIb4SR.gif)
+
+## Props
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`containerStyle` | Optional style for image's container | View Style Object | `{}`
+`dimensions` | Optional on-screen dimensions of the image, as measured with [native methods](https://facebook.github.io/react-native/docs/direct-manipulation.html#other-native-methods). This allows for a bit of optimization, but it's sometimes tricky to get these in responsive layouts. | `{ width: number, height: number }` | `undefined`
+`fadeDuration` | Duration of the fade-in effect when image is loaded | Number | `500`
+`parallaxFactor` | Speed of the parallax effect. Be aware that the bigger the value, the more image will appear "zoomed in". | Number | `0.3`
+`showSpinner` | Whether to display a spinner while image is loading or not | Boolean | `true`
+`spinnerColor` | Color of the spinner | String | 'rgba(0, 0, 0, 0.4)'
+`AnimatedImageComponent` | Custom animated image component | Function Object | `Animated.Image`
+
+All [`<Image />` props](https://facebook.github.io/react-native/docs/image.html#props) are also inherited, **particularly `source` which is required**.
+
+## Usage
+
+The first thing you need to do is to **set `hasParallaxImages` to `true` for your `<Carousel />`**. This will make a new argument available in your `renderItem()` function, which must then be passed to the `<ParallaxImage />`.
+
+Here is an example that shows how to connect images to your carousel (note the `parallaxProps` argument).
+
+```javascript
+import Carousel, { ParallaxImage } from 'react-native-snap-carousel';
+import { Dimensions, StyleSheet } from 'react-native';
+
+const { width: screenWidth } = Dimensions.get('window')
+
+export default class MyCarousel extends Component {
+
+    _renderItem ({item, index}, parallaxProps) {
+        return (
+            <View style={styles.item}>
+                <ParallaxImage
+                    source={{ uri: item.thumbnail }}
+                    containerStyle={styles.imageContainer}
+                    style={styles.image}
+                    parallaxFactor={0.4}
+                    {...parallaxProps}
+                />
+                <Text style={styles.title} numberOfLines={2}>
+                    { item.title }
+                </Text>
+            </View>
+        );
+    }
+
+    render () {
+        return (
+            <Carousel
+                sliderWidth={screenWidth}
+                sliderHeight={screenWidth}
+                itemWidth={screenWidth - 60}
+                data={this.state.entries}
+                renderItem={this._renderItem}
+                hasParallaxImages={true}
+            />
+        );
+    }
+}
+
+const styles = StyleSheet.create({
+  item: {
+    width: screenWidth - 60,
+    height: screenWidth - 60,
+  },
+  imageContainer: {
+    flex: 1,
+    marginBottom: Platform.select({ ios: 0, android: 1 }), // Prevent a random Android rendering issue
+    backgroundColor: 'white',
+    borderRadius: 8,
+  },
+  image: {
+    ...StyleSheet.absoluteFillObject,
+    resizeMode: 'cover',
+  },
+})
+```
+
+## Example to use with React Hooks
+
+```javascript
+import React, {useRef, useState, useEffect} from 'react';
+import Carousel, {ParallaxImage} from 'react-native-snap-carousel';
+import {
+  View,
+  Text,
+  Dimensions,
+  StyleSheet,
+  TouchableOpacity,
+  Platform,
+} from 'react-native';
+
+const ENTRIES1 = [
+  {
+    title: 'Beautiful and dramatic Antelope Canyon',
+    subtitle: 'Lorem ipsum dolor sit amet et nuncat mergitur',
+    illustration: 'https://i.imgur.com/UYiroysl.jpg',
+  },
+  {
+    title: 'Earlier this morning, NYC',
+    subtitle: 'Lorem ipsum dolor sit amet',
+    illustration: 'https://i.imgur.com/UPrs1EWl.jpg',
+  },
+  {
+    title: 'White Pocket Sunset',
+    subtitle: 'Lorem ipsum dolor sit amet et nuncat ',
+    illustration: 'https://i.imgur.com/MABUbpDl.jpg',
+  },
+  {
+    title: 'Acrocorinth, Greece',
+    subtitle: 'Lorem ipsum dolor sit amet et nuncat mergitur',
+    illustration: 'https://i.imgur.com/KZsmUi2l.jpg',
+  },
+  {
+    title: 'The lone tree, majestic landscape of New Zealand',
+    subtitle: 'Lorem ipsum dolor sit amet',
+    illustration: 'https://i.imgur.com/2nCt3Sbl.jpg',
+  },
+];
+const {width: screenWidth} = Dimensions.get('window');
+
+const MyCarousel = props => {
+  const [entries, setEntries] = useState([]);
+  const carouselRef = useRef(null);
+
+  const goForward = () => {
+    carouselRef.current.snapToNext();
+  };
+
+  useEffect(() => {
+    setEntries(ENTRIES1);
+  }, []);
+
+  const renderItem = ({item, index}, parallaxProps) => {
+    return (
+      <View style={styles.item}>
+        <ParallaxImage
+          source={{uri: item.illustration}}
+          containerStyle={styles.imageContainer}
+          style={styles.image}
+          parallaxFactor={0.4}
+          {...parallaxProps}
+        />
+        <Text style={styles.title} numberOfLines={2}>
+          {item.title}
+        </Text>
+      </View>
+    );
+  };
+
+  return (
+    <View style={styles.container}>
+      <TouchableOpacity onPress={goForward}>
+        <Text>go to next slide</Text>
+      </TouchableOpacity>
+      <Carousel
+        ref={carouselRef}
+        sliderWidth={screenWidth}
+        sliderHeight={screenWidth}
+        itemWidth={screenWidth - 60}
+        data={entries}
+        renderItem={renderItem}
+        hasParallaxImages={true}
+      />
+    </View>
+  );
+};
+
+export default MyCarousel;
+
+const styles = StyleSheet.create({
+  container: {
+    flex: 1,
+  },
+  item: {
+    width: screenWidth - 60,
+    height: screenWidth - 60,
+  },
+  imageContainer: {
+    flex: 1,
+    marginBottom: Platform.select({ios: 0, android: 1}), // Prevent a random Android rendering issue
+    backgroundColor: 'white',
+    borderRadius: 8,
+  },
+  image: {
+    ...StyleSheet.absoluteFillObject,
+    resizeMode: 'cover',
+  },
+});
+
+```
diff --git a/node_modules/react-native-snap-carousel/doc/PROPS_METHODS_AND_GETTERS.md b/node_modules/react-native-snap-carousel/doc/PROPS_METHODS_AND_GETTERS.md
new file mode 100644
index 0000000..5167d60
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/PROPS_METHODS_AND_GETTERS.md
@@ -0,0 +1,146 @@
+# Props, methods and getters
+
+## Table of contents
+
+1. [Props](#props)
+    * [Required](#required)
+    * [Behavior](#behavior)
+    * [Loop](#loop)
+    * [Autoplay](#autoplay)
+    * [Style and animation](#style-and-animation)
+    * [Callbacks](#callbacks)
+    * [Inherited props](#inherited-props)
+1. [Methods](#methods)
+1. [Getters](#getters)
+
+## Props
+
+### Required
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+**`data`** | Array of items to loop on | Array | **Required**
+**`renderItem`** | Takes an item from data and renders it into the list. The function receives one argument `{item, index}` (see [Usage](https://github.com/archriss/react-native-snap-carousel#usage)) and must return a React element. | Function | **Required**
+**`itemWidth`** | Width in pixels of carousel's items, **must be the same for all of them** | Number | **Required for __horizontal__ carousel**
+**`sliderWidth`** | Width in pixels of the carousel itself | Number | **Required for __horizontal__ carousel**
+**`itemHeight`** | Height in pixels of carousel's items, **must be the same for all of them** | Number | **Required for __vertical__ carousel**
+**`sliderHeight`** | Height in pixels of the carousel itself | Number | **Required for __vertical__ carousel**
+
+### Behavior
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`activeSlideOffset` | From slider's center, minimum slide distance to be scrolled before being set to active. | Number | `20`
+`apparitionDelay` | `FlatList`'s init is a real mess, with lots of unneeded flickers and slides movement. This prop controls the delay during which the carousel will be hidden when mounted. **WARNING: on Android, using it may lead to [rendering issues](https://github.com/archriss/react-native-snap-carousel/issues/236) (i.e. images not showing up)**. Make sure to test thoroughly if you decide on using it. | Number | `0`
+`callbackOffsetMargin` | Scroll events might not be triggered often enough to get a precise measure and, therefore, to provide a reliable callback. This usually is an Android issue, which might be linked to the version of React Native you're using (see ["Unreliable callbacks"](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/KNOWN_ISSUES.md#unreliable-callbacks)). To work around this, you can define a small margin that will increase the "sweet spot"'s width. The default value should cover most cases, but **you will want to increase it if you experience missed callbacks**. | Number | `5`
+`enableMomentum` | See [momentum](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/TIPS_AND_TRICKS.md#momentum) | Boolean | `false`
+`enableSnap` | If enabled, releasing the touch will scroll to the center of the nearest/active item | Boolean | `true`
+`firstItem` | Index of the first item to display. :warning: **Make sure to use inherited props [`getItemLayout`](https://facebook.github.io/react-native/docs/flatlist#getitemlayout) & [`initialScrollIndex`](https://facebook.github.io/react-native/docs/flatlist#initialscrollindex) if the prop doesn't seem to work**. | Number | `0`
+`hasParallaxImages` | Whether the carousel contains `<ParallaxImage />` components or not. Required for specific data to be passed to children. | Boolean | `false`
+`lockScrollTimeoutDuration` | This prop works in conjunction with `lockScrollWhileSnapping`. When scroll is locked, a timer is created in order to release the scroll if something goes wrong with the regular callback handling. **Normally, you shouldn't have to use this prop.** | Number | `1000`
+`lockScrollWhileSnapping` | Prevent the user from swiping again while the carousel is snapping to a position. This prevents miscellaneous minor issues (inadvertently tapping an item while scrolling, stopping the scrolling animation if the carousel is tapped in the middle of a snap, clunky behavior on Android when short snapping quickly in opposite directions). The only drawback is that enabling the prop hinders the ability to swipe quickly between items as a little pause between swipes is needed. **Note that the prop won't have any effect if `enableMomentum` is set to `true`, since it would otherwise impede the natural and expected behavior.** | Boolean | `false`
+`scrollEnabled` | When `false`, the view cannot be scrolled via touch interaction ([inherited prop](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/PROPS_METHODS_AND_GETTERS.md#inherited-props)) | Boolean | `true`
+`shouldOptimizeUpdates` | Whether to implement a `shouldComponentUpdate` strategy to minimize updates | Boolean | `true`
+`swipeThreshold` | Delta x when swiping to trigger the snap | Number | `20`
+`useScrollView` | Whether to use a `ScrollView` component instead of the default `FlatList` one. The advantages are to avoid rendering issues that can arise with `FlatList` and to provide compatibility with React Native pre- `0.43`. The major drawbacks are that you won't benefit from any of `FlatList`'s advanced optimizations and that you won't be able to use either `VirtualizedList` or `FlatList`'s specific props. **We recommend activating it only with a small set of slides and to test performance thoroughly in production mode.** Since version `3.7.6`, this prop also accepts a custom scroll component (see #498 for more info). | Boolean | `false` for `default` layout, `true` for `stack` and `tinder` layouts
+`vertical` | Layout slides vertically instead of horizontally | Boolean | `false`
+
+### Loop
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`loop` | Enable infinite loop mode. **:warning: It won't work if `enableSnap` has been set to `false`.** | Boolean | `false`
+`loopClonesPerSide` | Number of clones to append to each side of the original items. **When swiping very quickly**, the user will eventually need to pause for a quick second before the scroll is repositioned (this occurs when the end of the set is reached). By increasing this number, the user will be able to scroll more slides before having to stop; but you'll also load more items in memory. This is a trade-off between optimal user experience and performance. | Number | `3`
+
+### Autoplay
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`autoplay` | Trigger autoplay on mount. If you enable autoplay, we recommend you to set `enableMomentum` to `false` (default) and `lockScrollWhileSnapping` to `true`; this will enhance user experience a bit. | Boolean | `false`
+`autoplayDelay` | Delay before enabling autoplay on startup & after releasing the touch | Number | `1000`
+`autoplayInterval` | Delay in ms until navigating to the next item | Number |  `3000`
+
+### Style and animation
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`activeAnimationOptions` | Custom animation options. Note that `useNativeDriver` will be enabled by default and that opacity's easing will always be kept linear. **Setting this prop to something other than `null` will trigger custom animations and will completely change the way items are animated**: rather than having their opacity and scale interpolated based the scroll value (default behavior), they will now play the custom animation you provide as soon as they become active. **This means you cannot use props `layout`, `scrollInterpolator` or `slideInterpolatedStyle` in conjunction with `activeAnimationOptions`.** | Object | `null`
+`activeAnimationType` | Custom [animation type](https://facebook.github.io/react-native/docs/animated.html#configuring-animations): either `'decay`, `'spring'` or `'timing'`. Note that it will only be applied to the scale animation since opacity's animation type will always be set to `timing` (no one wants the opacity to 'bounce' around). | String | `'timing'`
+`activeSlideAlignment` | Determine active slide's alignment relative to the carousel. Possible values are: `'start'`, `'center'` and `'end'`. **It is not recommended to use this prop in conjunction with the `layout` one.** | String | `'center'`
+`containerCustomStyle` | Optional styles for Scrollview's global wrapper | View Style Object | `{}`
+`contentContainerCustomStyle` | Optional styles for Scrollview's items container. **:warning: Tread softly as this can mess with the carousel's inner logic!** | View Style Object | `{}`
+`inactiveSlideOpacity` | Value of the opacity effect applied to inactive slides | Number | `0.7`
+`inactiveSlideScale` | Value of the 'scale' transform applied to inactive slides | Number | `0.9`
+`inactiveSlideShift` | Value of the 'translate' transform applied to inactive slides (see [#204](https://github.com/archriss/react-native-snap-carousel/issues/204) or [the "custom interpolations" doc](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md) for an example usage). This prop will have no effect with layouts others than the default one. | Number | `0`
+`layout` | Define the way items are rendered and animated. Possible values are `'default'`, `'stack'` and `'tinder'`. See [this](https://github.com/archriss/react-native-snap-carousel#layouts-and-custom-interpolations) for more info and visual examples. :warning: **Setting this prop to either `'stack'` or `'tinder'` will activate `useScrollView` [to prevent rendering bugs with `FlatList`](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md#caveats). Therefore, those layouts won't be suited if you have a large data set since all items are going to be rendered upfront.** | String | `'default'`
+`layoutCardOffset` | Use to increase or decrease the default card offset in both 'stack' and 'tinder' layouts. | Number | `18` for the 'stack' layout, `9` for the 'tinder' one
+`scrollInterpolator` | Used to define custom interpolations. See [the dedicated doc](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md#summary). | Function | `undefined`
+`slideInterpolatedStyle` | Used to define custom interpolations. See [the dedicated doc](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/CUSTOM_INTERPOLATIONS.md#summary). | Function | `undefined`
+`slideStyle` | Optional style for each item's container (the one whose scale and opacity are animated) | Animated View Style Object | `{}`
+
+### Callbacks
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+`onLayout(event)` | Exposed `View` callback; invoked on mount and layout changes | Function | `undefined`
+`onScroll(event)` | Exposed `ScrollView` callback; fired while scrolling | Function | `undefined`
+`onBeforeSnapToItem(slideIndex)` | Callback fired when the new active item has been determined, before snapping to it | Function | `undefined`
+`onSnapToItem(slideIndex)` | Callback fired after snapping to an item | Function | `undefined`
+
+### Inherited props
+
+The component is built on top of the `FlatList` component, meaning it inherits from [`FlatList`](https://facebook.github.io/react-native/docs/flatlist.html), [`VirtualizedList`](https://facebook.github.io/react-native/docs/virtualizedlist.html), and [`ScrollView`](https://facebook.github.io/react-native/docs/scrollview.html).
+
+You can use almost all props from this three components, but some of them can't be overriden because it would mess with our implementation's logic.
+
+Here are a few useful props regarding carousel's **style and "feeling"**: `scrollEnabled` (if you want to disable user scrolling while still being able to use `Carousel`'s methods), `showsHorizontalScrollIndicator`, `overScrollMode` (android), `bounces` (ios), `decelerationRate` (ios), `scrollEventThrottle` (ios).
+
+And here are some useful ones for **performance optimizations and rendering**: `initialNumToRender`, `maxToRenderPerBatch`, `windowSize`, `updateCellsBatchingPeriod`, `extraData`, `removeClippedSubviews` (the latter may have bugs, as stated in [RN's doc](https://facebook.github.io/react-native/docs/flatlist.html#removeclippedsubviews)). The first three are already implemented with default parameters, but you can override them if they don't suit your needs.
+
+## Methods
+
+### Reference to the component
+
+In order to use the following methods, you need to create a reference to the carousel's instance. There are two ways of doing it.
+
+#### ref as a callback attribute (**recommended**)
+```javascript
+<Carousel
+  // other props
+  ref={(c) => { this._carousel = c; }}
+/>
+
+// methods can then be called this way
+onPress={() => { this._carousel.snapToNext(); }}
+```
+
+#### ref as a string attribute ([legacy](http://stackoverflow.com/questions/37468913/why-ref-string-is-legacy))
+```javascript
+<Carousel
+  // other props
+  ref={'carousel'}
+/>
+
+// methods can then be called this way
+onPress={() => { this.refs.carousel.snapToNext(); }}
+```
+
+### Available methods
+
+Method | Description
+------ | ------
+`startAutoplay (instantly = false)` | Start the autoplay programmatically
+`stopAutoplay ()` | Stop the autoplay programmatically
+`snapToItem (index, animated = true, fireCallback = true)` | Snap to an item programmatically
+`snapToNext (animated = true, fireCallback = true)` | Snap to next item programmatically
+`snapToPrev (animated = true, fireCallback = true)` | Snap to previous item programmatically
+`triggerRenderingHack (offset)` | Call this when needed to work around [a random `FlatList` bug](https://github.com/facebook/react-native/issues/1831) that keeps content hidden until the carousel is scrolled (see [#238](https://github.com/archriss/react-native-snap-carousel/issues/238)). Note that the `offset` parameter is not required and will default to either `1` or `-1` depending on the current scroll position.
+
+## Getters
+
+> You need a reference to the carousel's instance (see [above](#reference-to-the-component) if needed).
+
+Property | Description
+------ | ------
+`currentIndex` | Current active item (`int`, starts at 0)
+`currentScrollPosition` | Underlying `ScrollView`'s current content offset (`int`, starts at `0` if `activeSlideAlignment` is set to `start`, negative value otherwise)
diff --git a/node_modules/react-native-snap-carousel/doc/TIPS_AND_TRICKS.md b/node_modules/react-native-snap-carousel/doc/TIPS_AND_TRICKS.md
new file mode 100644
index 0000000..aa6ac3a
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/TIPS_AND_TRICKS.md
@@ -0,0 +1,358 @@
+# Tips and tricks
+
+## Table of contents
+
+1. [Optimizing performance](#optimizing-performance)
+1. [Momentum](#momentum)
+1. [Margin between slides](#margin-between-slides)
+1. [Carousel's stretched height](#carousels-stretched-height)
+1. [Items' dynamic height](#items-dynamic-height)
+1. [Fullscreen slides](#fullscreen-slides)
+1. [Viewport wide slides / no preview effect](#viewport-wide-slides--no-preview-effect)
+1. [Handling device rotation](#handling-device-rotation)
+1. [Native-powered animations](#native-powered-animations)
+1. [Implementing navigation](#implementing-navigation)
+1. [Implementing zooming feature](#implementing-zooming-feature)
+1. [Using a specific commit](#using-a-specific-commit)
+1. [Useful threads](#useful-threads)
+1. [Understanding styles](#understanding-styles)
+1. [Migration from version 2.x](#migration-from-version-2x)
+
+## Optimizing performance
+
+Here are a few good practices to keep in mind when dealing with the component (or any React Native list for that matter):
+
+* **Implement `shouldComponentUpdate`** (see [the `shallowCompare` addon](https://www.npmjs.com/package/react-addons-shallow-compare`)) for every carousel children (in `renderItem()`) or **make it a `PureComponent`** (some users report that `shouldComponentUpdate` is faster, but you should try both and decide for yourself).
+* Make sure the carousel **isn't a child of a `ScrollView`** (this includes `FlatList`, `VirtualizedList` and many plugins). Apparently, it would render all child components, even those currently off-screen.
+* If your data set is huge, **consider loading additional chunks of data only when the user has reached the end of the current set**. In order to do this, you'll have to play with `VirtualizedList`'s props `onEndReached` and `onEndReachedThreshold`
+* **Add [prop `removeClippedSubviews`](https://facebook.github.io/react-native/docs/scrollview.html#removeclippedsubviews)** and set it to `true` so that out-of-view items are removed from memory.
+
+Here are a few other tips given by [@pcooney10](https://github.com/pcooney10) in [this thread](https://github.com/archriss/react-native-snap-carousel/issues/247#issuecomment-360276562):
+
+- Make sure there aren't any excessive calls to `this.setState` in the component that renders the carousels and their parents.
+- Properly leverage the `initialNumToRender` and `maxToRenderPerBatch` props inherited from `FlatList`, and `windowSize` inherited from `VirtualizedList`.
+- Utilize [`InteractionManager`](https://facebook.github.io/react-native/docs/interactionmanager.html) to render the Carousels that are "below the fold".
+- Avoid using functions and object literals for props declared on components - this apparently results in "new props" during a re-render.
+
+Lastly, make sure to read [this note](https://github.com/archriss/react-native-snap-carousel#important-note-regarding-android) regarding Android and [this one](https://github.com/archriss/react-native-snap-carousel#important-note-regarding-ios) regarding iOS.
+
+## Momentum
+
+Since version `1.5.0`, the snapping effect can be based on momentum (by setting `enableMomentum` to `true`) instead of when you're releasing your finger. It means that the component will wait until the `ScrollView` isn't moving anymore to snap.
+
+By default, the inertia isn't too high on Android. However, we had to tweak the default iOS value a bit to make sure the snapping isn't delayed for too long. You can adjust this value to your needs thanks to [this prop](https://facebook.github.io/react-native/docs/scrollview.html#decelerationrate).
+
+If momentum is disabled (default behavior), make sure to play with prop `scrollEndDragDebounceValue` since it can help achieving a better snap feeling.
+
+> **We recommend setting `enableMomentum` to `false` (default) and `decelerationRate` to `'fast'` when you are displaying only one main slide** (as in the showcase above), and to use `true` and `0.9` otherwise.
+
+## Margin between slides
+If you need some **extra horizontal margin** between slides (besides the one resulting from the scale effect), you should add it as `paddingHorizontal` on slide's container.
+
+:warning: **The value of `itemWidth` must include this extra margin.**
+
+```javascript
+const horizontalMargin = 20;
+const slideWidth = 280;
+
+const sliderWidth = Dimensions.get('window').width;
+const itemWidth = slideWidth + horizontalMargin * 2;
+const itemHeight = 200;
+
+const styles = StyleSheet.create({
+    slide: {
+        width: itemWidth,
+        height: itemHeight,
+        paddingHorizontal: horizontalMargin
+        // other styles for the item container
+    },
+    slideInnerContainer: {
+        width: slideWidth,
+        flex: 1
+        // other styles for the inner container
+    }
+};
+```
+```javascript
+    _renderItem ({item, index}) {
+        return (
+            <View style={styles.slide}>
+                <View style={styles.slideInnerContainer} />
+            </View>
+        );
+    }
+
+    render () {
+        return (
+            <Carousel
+              renderItem={this._renderItem}
+              sliderWidth={sliderWidth}
+              itemWidth={itemWidth}
+            />
+        );
+    }
+```
+
+## Carousel's stretched height
+
+Since `<Carousel />` is, ultimately, based on `<ScrollView />`, it inherits [its default styles](https://github.com/facebook/react-native/blob/c38f167019a3c481847d4abc80a458f7784f1336/Libraries/Components/ScrollView/ScrollView.js#L1153-L1169) and particularly `{ flexGrow: 1 }`. This means that, by default, **the carousel container will stretch to fill up all available space**.
+
+If this is not what you're after, you can prevent this behavior by passing `{ flexGrow: 0 }` to prop `containerCustomStyle`.
+
+Alternatively, you can either use this prop to pass a custom height to the container, or wrap the carousel in a `<View />` with a fixed height.
+
+## Items' dynamic height
+
+If you want your slides to have dynamic height (e.g. to fill up the entirety of the available space), you need to transfer `{ flex: 1 }` to all the relevant wrappers. Here is a minimal example:
+
+```javascript
+_renderItem ({item, index}) {
+    return (
+        <View style={{ flex: 1 }} />
+    );
+}
+
+render () {
+    return (
+        <Carousel
+          data={this.state.data}
+          renderItem={this._renderItem}
+          containerCustomStyle={{ flex: 1 }}
+          slideStyle={{ flex: 1 }}
+        />
+    );
+}
+```
+
+## Fullscreen slides
+
+While the plugin hasn't been designed with this use case in mind, you can easily implement fullscreen slides. The following code can serve as a good starting point.
+
+```javascript
+const { width: viewportWidth, height: viewportHeight } = Dimensions.get('window');
+
+export class MyCarousel extends Component {
+
+    _renderItem ({item, index}) {
+        return (
+            <View style={{ height: viewportHeight }} /> // or { flex: 1 } for responsive height
+        );
+    }
+
+    render () {
+        return (
+            <Carousel
+              data={this.state.entries}
+              renderItem={this._renderItem}
+              sliderWidth={viewportWidth}
+              itemWidth={viewportWidth}
+              slideStyle={{ width: viewportWidth }}
+              inactiveSlideOpacity={1}
+              inactiveSlideScale={1}
+            />
+        );
+    }
+}
+```
+
+[This plugin](https://github.com/shichongrui/react-native-on-layout) can also prove useful.
+
+## Viewport wide slides / no preview effect
+
+**If you are using the plugin without the preview effect (meaning that your slides, as well as your slider, are viewport wide), we do not recommend using this plugin.**
+
+You'll be better off with [`react-native-swiper`](https://github.com/leecade/react-native-swiper) for the simple reason that it implements the `ViewPagerAndroid` component, which provides a way better overall feeling on Android, whereas we must hack our way around [the frustrating limitations of the `ScrollView` component](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/KNOWN_ISSUES.md#flatlist-and-scrollviews-limitations).
+
+## Handling device rotation
+
+Since version 2.2.0, slides will re-center properly if you update slider and/or items' dimensions when `onLayout` is fired.
+
+Here is an example of a working implementation (thanks [@andrewpope](https://github.com/archriss/react-native-snap-carousel/pull/76#issuecomment-306187425)):
+
+```
+constructor(props) {
+    super(props);
+    this.state = {
+        viewport: {
+            width: Dimensions.get('window').width,
+            height: Dimensions.get('window').height
+        }
+    };
+}
+
+render() {
+    return (
+        <View
+            onLayout={() => {
+                this.setState({
+                    viewport: {
+                        width: Dimensions.get('window').width,
+                        height: Dimensions.get('window').height
+                    }
+                });
+            }}
+        >
+            <Carousel
+                ref={c => { this.carousel = c; } }
+                sliderWidth={this.state.viewport.width}
+                itemWidth={this.state.viewport.width}
+                ...
+            />
+        </View>
+    );
+}
+```
+
+## Native-powered animations
+
+Slides' animations are based on scroll events and have been moved to the native thread in order to prevent the tiny lag associated with React Native's JavaScript bridge. This is really useful when displaying a `transform` and/or `opacity` animation that needs to follow carousel's scroll position closely. You can find more info in [this post from Facebook](https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html) or in [this one on Medium](https://medium.com/xebia/linking-animations-to-scroll-position-in-react-native-5c55995f5a6e).
+
+## Implementing navigation
+
+Some users had trouble implementing navigation with the carousel (see [#83](https://github.com/archriss/react-native-snap-carousel/issues/83), [#146](https://github.com/archriss/react-native-snap-carousel/issues/146) and [#212](https://github.com/archriss/react-native-snap-carousel/issues/212)) because they weren't aware of methods' context.
+
+[jordangrant](https://github.com/jordangrant) was kind enough to share [a comprehensive walkthrough](https://github.com/archriss/react-native-snap-carousel/issues/146#issuecomment-343933652) which is reproduced below. Kuddos to him!
+
+In your Carousel:
+
+```
+<Carousel
+    data={image1}
+    renderItem={this._renderItem.bind(this)}   //<------
+    sliderWidth={equalWidth2}
+    itemWidth={equalWidth5}
+  />
+```
+
+Adding the bind allows the `_renderItem` function to understand what `this` is (in `this.props.navigation`).
+
+In `_renderItem()`:
+
+```
+_renderItem ({item, index}) {
+        return (
+            <SliderEntry
+              data={item}
+              navigation={this.props.navigation}   //<-------
+            />
+        );
+    }
+```
+
+And inside `SliderEntry.js`:
+
+```
+export default class SliderEntry extends Component {
+
+    static propTypes = {
+        data: PropTypes.object.isRequired,
+    };
+
+    render () {
+        const { data: { title, subtitle, illustration}, navigation } = this.props;    //<------
+
+        return (
+          <TouchableOpacity
+            activeOpacity={1}
+            style={styles.slideInnerContainer}
+            onPress={() => navigation.navigate('Feed')}  //<------- now you can use navigation
+          >
+    }
+}
+```
+
+## Implementing zooming feature
+
+See https://github.com/archriss/react-native-snap-carousel/issues/264#issuecomment-366473756
+
+## Using a specific commit
+
+This plugin is regularly updated, and new versions are frequently pushed to `npm`. But you may want to use a specific commit, not yet merged or published.
+
+This is pretty easy: in your `package.json` file, use the GitHub link instead of a version number, and point to the specific commit using `#`. For example, if the commit reference is `fbdb671`, you would write:
+```javascript
+"react-native-snap-carousel": "https://github.com/archriss/react-native-snap-carousel#fbdb671"
+```
+
+## Useful threads
+
+Some issues stand above the others because a lot of useful information has been shared.
+
+In order to make it easier for everyone to find them, they are [tagged with an asterisk](https://github.com/archriss/react-native-snap-carousel/issues?q=is%3Aissue+label%3A%2A).
+
+## Understanding styles
+
+Here is a screenshot that should help you understand how each of the required variables is used.
+
+![react-native-snap-carousel info](https://i.imgur.com/PMi6aBd.jpg)
+
+## Migration from version 2.x
+
+Slides are no longer appended as direct children of the component since the plugin is now based on `FlatList` instead of `ScrollView`. There are two new props that takes care of their rendering: `data` and `renderItem` (both are inherited from `FlatList`).
+
+> :warning: **Make sure to read about [the recommended React Native version](https://github.com/archriss/react-native-snap-carousel/blob/master/doc/KNOWN_ISSUES.md#react-native-version) before migrating.**
+
+If you were already looping throught an array of data to populate the carousel, the migration is pretty straightforward. Just pass your slides' data to the `data` prop, convert your slides' getter to a function and pass it to the `renderItem` prop: you're good to go!
+
+**From**
+```javascript
+    get slides () {
+        return this.state.entries.map((entry, index) => {
+            return (
+                <View key={`entry-${index}`} style={styles.slide}>
+                    <Text style={styles.title}>{ entry.title }</Text>
+                </View>
+            );
+        });
+    }
+
+    render () {
+        return (
+            <Carousel
+              sliderWidth={sliderWidth}
+              itemWidth={itemWidth}
+            >
+                { this.slides }
+            </Carousel>
+        );
+    }
+```
+
+**To**
+```javascript
+    _renderItem ({item, index}) {
+        return (
+            <View style={styles.slide}>
+                <Text style={styles.title}>{ item.title }</Text>
+            </View>
+        );
+    }
+
+    render () {
+        return (
+            <Carousel
+              data={this.state.entries}
+              renderItem={this._renderItem}
+              sliderWidth={sliderWidth}
+              itemWidth={itemWidth}
+            />
+        );
+    }
+```
+
+> Note that the `key` prop is no longer needed for carousel's items. If you want to provide a custom key, you should pass your own [`keyExtractor`](https://facebook.github.io/react-native/docs/flatlist.html#keyextractor) to the `<Carousel />`.
+
+If you were previously appending random types of children, you will need to rely on a specific bit of data to return the proper element from your `renderItem` function.
+
+**Example**
+```javascript
+    _renderItem ({item, index}) {
+        if (item.type === 'text') {
+            return <Text style={styles.textSlide} />;
+        } else if (item.type === 'image') {
+            return <Image style={styles.imageSlide} />;
+        } else {
+            return <View style={styles.viewSlide} />;
+        }
+    }
+```
diff --git a/node_modules/react-native-snap-carousel/doc/VERSION_4.md b/node_modules/react-native-snap-carousel/doc/VERSION_4.md
new file mode 100644
index 0000000..eac8ec5
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/doc/VERSION_4.md
@@ -0,0 +1,71 @@
+# A shiny new version is on its way!
+
+![react-native-snap-carousel mind blown](https://i.imgur.com/gdaKtSm.gif)
+
+## 💡 Why?
+
+So far, and because of [numerous React Native limitations](https://github.com/archriss/react-native-snap-carousel/issues/203), the entire plugin has basically been based on a pile of hacks and workarounds...
+
+With the most recent versions of React Native, a few interesting props have appeared and made me consider the possibility of finally rewriting the inner logic of the carousel.
+
+Don't get me wrong: we'll still have to rely on a few hacks to account for, well, Android particularly. But it was possible to get rid of most of them, and that is for the best!
+
+## ✨ Wonderful benefits
+
+Most of the heavy work is done, and here's what you can enjoy out-of-the-box:
+
+- **(Very) Smooth scrolling.** Put simply, this is night and day. Just try it for yourself and you'll see that there's just no going back!
+- **Reliable callback logic.**
+- **Optimized custom interpolations ('stack' and 'tinder' layouts for example) that can be used with a huge number of items.** Previously, you couldn't use those with a big data set as this would create performance issues. :warning: **This one is iOS-only for now** (but, given a few recent tests, we might find a way to make it work on Android).
+- **An experimental snap feature** that is promising but not yet complete (see below).
+
+## 📍 Next steps
+
+Before making it widely available, **I now need your help** 🙌
+
+The first thing you can do is test this new version and let me know how it works for you and you particular setup. For example, vertical carousels, pagination and parallax images haven't been tested yet — they are expected to work properly though.
+
+### How to test?
+
+- You can find the already published beta versions by running: `npm view react-native-snap-carousel versions --json`
+- [Follow this PR closely](https://github.com/archriss/react-native-snap-carousel/pull/678). **This is where the discussion will take place.**
+- And if you like to live on the edge, [try the latest commits](https://stackoverflow.com/a/27630247/) of that same PR ;-)
+
+### 🦸‍♀️🦸‍♂️ Get your hands dirty!
+
+Then, **if you want to jump in**, I'd be glad if you could help me with the following:
+
+1. **Reducing the number of rerenders** (see [#478](https://github.com/archriss/react-native-snap-carousel/issues/478)). [`why-did-you-render`](https://github.com/welldone-software/why-did-you-render) is going to prove really helpful for that.
+2. **Finding a way to make the experimental snap feature work even with the last items** (see "New props" below for more details on this feature).
+
+Let's finish that together and make sure this plugin remains absolutely awesome!
+
+Cheers,
+[bd-arc](https://github.com/bd-arc)
+
+---
+
+## 📚 New, updated and removed props
+
+### New props
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+✅ **`useExperimentalSnap`** | By default, items will always be centered according to the `activeSlideAlignment` prop. A sometimes unwanted result of this is the addition of empty spaces at the end/beginning of the carousel. Since version 4, it is possible to use another centering option that will avoid white spaces. :warning: **If you set it to `true`, some items might not be "reachable" — i.e. for the last item(s), the snap callbacks won't be triggered and the animations won't be complete.** We recommend activate it only if you don't rely on `onSnapToItem` and if both `inactiveSlideScale` and `inactiveSlideOpacity` are set to `1`. A side benefit of activating it is **the ability to slide only one item at a time** when setting the inherited prop `disableIntervalMomentum` to `true`. | Boolean | `false`
+✅ **`onScrollIndexChanged(slideIndex)`** | Executed as soon as the active index changes during scroll (whereas `onSnapToItem` is executed only for the last active item). :warning: **Avoid doing heavy calculations or rendering here!** | Function | `undefined`
+
+### Updated props
+
+Prop | Description | Type | Default
+------ | ------ | ------ | ------
+✅ **`renderItem({ item, index, dataIndex })`** | `renderItem()` now receives a **`dataIndex` param** that will represent the index based on your data set and not on the actual number of items — the two numbers won't match for looped carousels. This is useful if you need to pass to the item something based on your data rather than on the inner index. | Function | **Required**
+
+### Removed props
+
+- ❌ `activeAnimationOptions`
+- ❌ `activeAnimationType`
+- ❌ `enableMomentum`
+- ❌ `lockScrollTimeoutDuration`
+- ❌ `lockScrollWhileSnapping`
+- ❌ `onBeforeSnapToItem`
+- ❌ `swipeThreshold`
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js b/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js
deleted file mode 100644
index 48b5c11..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js
+++ /dev/null
@@ -1,1315 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = exports.Carousel = void 0;
-
-var _react = _interopRequireDefault(require("react"));
-
-var _reactNative = require("react-native");
-
-var _reactAddonsShallowCompare = _interopRequireDefault(require("react-addons-shallow-compare"));
-
-var _animations = require("../utils/animations");
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
-
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-// Metro doesn't support dynamic imports - i.e. require() done in the component itself
-// But at the same time the following import will fail on Snack...
-// TODO: find a way to get React Native's version without having to assume the file path
-// import RN_PACKAGE from '../../../react-native/package.json';
-const IS_ANDROID = _reactNative.Platform.OS === 'android'; // React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView
-// See https://github.com/facebook/react-native/issues/11960
-// NOTE: the following variable is not declared in the constructor
-// otherwise it is undefined at init, which messes with custom indexes
-
-const IS_RTL = _reactNative.I18nManager.isRTL;
-
-class Carousel extends _react.default.Component {
-  constructor(props) {
-    super(props);
-
-    _defineProperty(this, "_activeItem", void 0);
-
-    _defineProperty(this, "_onScrollActiveItem", void 0);
-
-    _defineProperty(this, "_previousFirstItem", void 0);
-
-    _defineProperty(this, "_previousItemsLength", void 0);
-
-    _defineProperty(this, "_mounted", void 0);
-
-    _defineProperty(this, "_positions", void 0);
-
-    _defineProperty(this, "_currentScrollOffset", void 0);
-
-    _defineProperty(this, "_scrollEnabled", void 0);
-
-    _defineProperty(this, "_initTimeout", void 0);
-
-    _defineProperty(this, "_apparitionTimeout", void 0);
-
-    _defineProperty(this, "_hackSlideAnimationTimeout", void 0);
-
-    _defineProperty(this, "_enableAutoplayTimeout", void 0);
-
-    _defineProperty(this, "_autoplayTimeout", void 0);
-
-    _defineProperty(this, "_snapNoMomentumTimeout", void 0);
-
-    _defineProperty(this, "_androidRepositioningTimeout", void 0);
-
-    _defineProperty(this, "_autoplayInterval", void 0);
-
-    _defineProperty(this, "_scrollPos", void 0);
-
-    _defineProperty(this, "_onScrollHandler", void 0);
-
-    _defineProperty(this, "_carouselRef", null);
-
-    _defineProperty(this, "_autoplaying", void 0);
-
-    _defineProperty(this, "_autoplay", void 0);
-
-    _defineProperty(this, "_onLayoutInitDone", void 0);
-
-    this.state = {
-      hideCarousel: !!props.apparitionDelay,
-      interpolators: []
-    }; // this._RNVersionCode = this._getRNVersionCode();
-    // The following values are not stored in the state because 'setState()' is asynchronous
-    // and this results in an absolutely crappy behavior on Android while swiping (see #156)
-
-    const initialActiveItem = this._getFirstItem(props.firstItem);
-
-    this._activeItem = initialActiveItem;
-    this._onScrollActiveItem = initialActiveItem;
-    this._previousFirstItem = initialActiveItem;
-    this._previousItemsLength = initialActiveItem;
-    this._mounted = false;
-    this._positions = [];
-    this._currentScrollOffset = 0; // Store ScrollView's scroll position
-
-    this._scrollEnabled = props.scrollEnabled !== false;
-    this._getCellRendererComponent = this._getCellRendererComponent.bind(this);
-    this._getItemLayout = this._getItemLayout.bind(this);
-    this._getKeyExtractor = this._getKeyExtractor.bind(this);
-    this._onLayout = this._onLayout.bind(this);
-    this._onScroll = this._onScroll.bind(this);
-    this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);
-    this._onTouchStart = this._onTouchStart.bind(this);
-    this._onTouchEnd = this._onTouchEnd.bind(this);
-    this._renderItem = this._renderItem.bind(this); // WARNING: call this AFTER binding _onScroll
-
-    this._setScrollHandler(props); // Display warnings
-
-
-    this._displayWarnings(props);
-  }
-
-  componentDidMount() {
-    const {
-      apparitionDelay,
-      autoplay,
-      firstItem
-    } = this.props;
-    this._mounted = true;
-
-    this._initPositionsAndInterpolators(); // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...
-
-
-    this._initTimeout = setTimeout(() => {
-      if (!this._mounted) {
-        return;
-      }
-
-      const apparitionCallback = () => {
-        if (apparitionDelay) {
-          this.setState({
-            hideCarousel: false
-          });
-        }
-
-        if (autoplay) {
-          this.startAutoplay();
-        }
-      }; // FlatList will use its own built-in prop `initialScrollIndex`
-
-
-      if (this._needsScrollView()) {
-        const _firstItem = this._getFirstItem(firstItem);
-
-        this._snapToItem(_firstItem, false, false, true); // this._hackActiveSlideAnimation(_firstItem);
-
-      }
-
-      if (apparitionDelay) {
-        this._apparitionTimeout = setTimeout(() => {
-          apparitionCallback();
-        }, apparitionDelay);
-      } else {
-        apparitionCallback();
-      }
-    }, 1);
-  }
-
-  shouldComponentUpdate(nextProps, nextState) {
-    if (this.props.shouldOptimizeUpdates === false) {
-      return true;
-    } else {
-      return (0, _reactAddonsShallowCompare.default)(this, nextProps, nextState);
-    }
-  }
-
-  componentDidUpdate(prevProps) {
-    const {
-      interpolators
-    } = this.state;
-    const {
-      firstItem,
-      scrollEnabled
-    } = this.props;
-
-    const itemsLength = this._getCustomDataLength(this.props);
-
-    if (!itemsLength) {
-      return;
-    }
-
-    const nextFirstItem = this._getFirstItem(firstItem, this.props);
-
-    let nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;
-    const hasNewSize = this.props.vertical !== prevProps.vertical || this.props.vertical && prevProps.vertical && (prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight) || !this.props.vertical && !prevProps.vertical && (prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth); // Prevent issues with dynamically removed items
-
-    if (nextActiveItem > itemsLength - 1) {
-      nextActiveItem = itemsLength - 1;
-    } // Handle changing scrollEnabled independent of user -> carousel interaction
-
-
-    if (scrollEnabled !== prevProps.scrollEnabled) {
-      this._setScrollEnabled(scrollEnabled);
-    }
-
-    if (interpolators.length !== itemsLength || hasNewSize) {
-      this._activeItem = nextActiveItem;
-      this._previousItemsLength = itemsLength;
-
-      this._initPositionsAndInterpolators(this.props); // Handle scroll issue when dynamically removing items (see #133)
-      // This also fixes first item's active state on Android
-      // Because 'initialScrollIndex' apparently doesn't trigger scroll
-
-
-      if (this._previousItemsLength > itemsLength) {
-        this._hackActiveSlideAnimation(nextActiveItem);
-      }
-
-      if (hasNewSize) {
-        this._snapToItem(nextActiveItem, false, false, true);
-      }
-    } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {
-      this._activeItem = nextFirstItem;
-      this._previousFirstItem = nextFirstItem;
-
-      this._snapToItem(nextFirstItem, false, true, true);
-    }
-
-    if (this.props.onScroll !== prevProps.onScroll) {
-      this._setScrollHandler(this.props);
-    }
-  }
-
-  componentWillUnmount() {
-    this._mounted = false;
-    this.stopAutoplay(); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._initTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._apparitionTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._hackSlideAnimationTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._enableAutoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._autoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._snapNoMomentumTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._androidRepositioningTimeout);
-  }
-
-  get realIndex() {
-    return this._activeItem;
-  }
-
-  get currentIndex() {
-    return this._getDataIndex(this._activeItem);
-  }
-
-  get currentScrollPosition() {
-    return this._currentScrollOffset;
-  }
-
-  _setScrollHandler(props) {
-    // Native driver for scroll events
-    const scrollEventConfig = {
-      listener: this._onScroll,
-      useNativeDriver: true
-    };
-    this._scrollPos = new _reactNative.Animated.Value(0);
-    const argMapping = props.vertical ? [{
-      nativeEvent: {
-        contentOffset: {
-          y: this._scrollPos
-        }
-      }
-    }] : [{
-      nativeEvent: {
-        contentOffset: {
-          x: this._scrollPos
-        }
-      }
-    }]; // @ts-expect-error Let's ignore for now that trick
-
-    if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {
-      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294
-      argMapping.pop(); // @ts-expect-error Let's ignore for now that trick
-
-      const [argMap] = props.onScroll._argMapping;
-
-      if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {
-        // Shares the same animated value passed in props
-        this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;
-      } // @ts-expect-error Let's ignore for now that trick
-
-
-      argMapping.push(...props.onScroll._argMapping);
-    }
-
-    this._onScrollHandler = _reactNative.Animated.event(argMapping, scrollEventConfig);
-  } // This will return a future-proof version code number compatible with semantic versioning
-  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002
-  // _getRNVersionCode () {
-  //     const version = RN_PACKAGE && RN_PACKAGE.version;
-  //     if (!version) {
-  //         return null;
-  //     }
-  //     const versionSplit = version.split('.');
-  //     if (!versionSplit || !versionSplit.length) {
-  //         return null;
-  //     }
-  //     return versionSplit[0] * 10000 +
-  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +
-  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);
-  // }
-
-
-  _displayWarnings(props = this.props) {
-    const pluginName = 'react-native-snap-carousel';
-    const removedProps = ['activeAnimationType', 'activeAnimationOptions', 'enableMomentum', 'lockScrollTimeoutDuration', 'lockScrollWhileSnapping', 'onBeforeSnapToItem', 'swipeThreshold']; // if (this._RNVersionCode && this._RNVersionCode < 5800) {
-    //     console.error(
-    //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +
-    //         'Please downgrade to version 3.x or update your version of React Native.'
-    //     );
-    // }
-
-    if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {
-      console.error("".concat(pluginName, ": You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels"));
-    }
-
-    if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {
-      console.error("".concat(pluginName, ": You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels"));
-    }
-
-    removedProps.forEach(removedProp => {
-      if (removedProp in props) {
-        console.warn("".concat(pluginName, ": Prop ").concat(removedProp, " has been removed in version 4 of the plugin"));
-      }
-    });
-  }
-
-  _needsScrollView() {
-    const {
-      useScrollView
-    } = this.props; // Android's cell renderer is buggy and has a stange overflow
-    // TODO: a workaround might be to pass the custom animated styles directly to it
-
-    return IS_ANDROID ? useScrollView || !_reactNative.Animated.FlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() : useScrollView || !_reactNative.Animated.FlatList;
-  }
-
-  _needsRTLAdaptations() {
-    const {
-      vertical
-    } = this.props;
-    return IS_RTL && IS_ANDROID && !vertical;
-  }
-
-  _enableLoop() {
-    const {
-      data,
-      enableSnap,
-      loop
-    } = this.props;
-    return enableSnap && loop && data && data.length && data.length > 1;
-  }
-
-  _shouldAnimateSlides(props = this.props) {
-    const {
-      inactiveSlideOpacity,
-      inactiveSlideScale,
-      scrollInterpolator,
-      slideInterpolatedStyle
-    } = props;
-    return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();
-  }
-
-  _shouldUseShiftLayout() {
-    const {
-      inactiveSlideShift,
-      layout
-    } = this.props;
-    return layout === 'default' && inactiveSlideShift !== 0;
-  }
-
-  _shouldUseStackLayout() {
-    return this.props.layout === 'stack';
-  }
-
-  _shouldUseTinderLayout() {
-    return this.props.layout === 'tinder';
-  }
-
-  _shouldRepositionScroll(index) {
-    const {
-      data,
-      enableSnap,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (!enableSnap || !dataLength || !this._enableLoop() || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {
-      return false;
-    }
-
-    return true;
-  }
-
-  _roundNumber(num, decimals = 1) {
-    // https://stackoverflow.com/a/41716722/
-    const rounder = Math.pow(10, decimals);
-    return Math.round((num + Number.EPSILON) * rounder) / rounder;
-  }
-
-  _isMultiple(x, y) {
-    // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/
-    // Required because Android viewport size can return pretty complicated decimals numbers
-    return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);
-  }
-
-  _getCustomData(props = this.props) {
-    const {
-      data,
-      loopClonesPerSide
-    } = props;
-    const dataLength = data && data.length;
-
-    if (!dataLength) {
-      return [];
-    }
-
-    if (!this._enableLoop()) {
-      return data;
-    }
-
-    let previousItems = [];
-    let nextItems = [];
-
-    if (loopClonesPerSide > dataLength) {
-      const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-      const remainder = loopClonesPerSide % dataLength;
-
-      for (let i = 0; i < dataMultiplier; i++) {
-        previousItems.push(...data);
-        nextItems.push(...data);
-      }
-
-      previousItems.unshift(...data.slice(-remainder));
-      nextItems.push(...data.slice(0, remainder));
-    } else {
-      previousItems = data.slice(-loopClonesPerSide);
-      nextItems = data.slice(0, loopClonesPerSide);
-    }
-
-    return previousItems.concat(data, nextItems);
-  }
-
-  _getCustomDataLength(props = this.props) {
-    const {
-      data,
-      loopClonesPerSide
-    } = props;
-    const dataLength = data && data.length;
-
-    if (!dataLength) {
-      return 0;
-    }
-
-    return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;
-  }
-
-  _getCustomIndex(index, props = this.props) {
-    const itemsLength = this._getCustomDataLength(props);
-
-    if (!itemsLength || typeof index === 'undefined') {
-      return 0;
-    }
-
-    return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;
-  }
-
-  _getDataIndex(index) {
-    const {
-      data,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (!this._enableLoop() || !dataLength) {
-      return index;
-    }
-
-    if (index >= dataLength + loopClonesPerSide) {
-      return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;
-    } else if (index < loopClonesPerSide) {
-      // TODO: is there a simpler way of determining the interpolated index?
-      if (loopClonesPerSide > dataLength) {
-        const baseDataIndexes = [];
-        const dataIndexes = [];
-        const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-        const remainder = loopClonesPerSide % dataLength;
-
-        for (let i = 0; i < dataLength; i++) {
-          baseDataIndexes.push(i);
-        }
-
-        for (let j = 0; j < dataMultiplier; j++) {
-          dataIndexes.push(...baseDataIndexes);
-        }
-
-        dataIndexes.unshift(...baseDataIndexes.slice(-remainder));
-        return dataIndexes[index];
-      } else {
-        return index + dataLength - loopClonesPerSide;
-      }
-    } else {
-      return index - loopClonesPerSide;
-    }
-  } // Used with `snapToItem()` and 'PaginationDot'
-
-
-  _getPositionIndex(index) {
-    const {
-      loop,
-      loopClonesPerSide
-    } = this.props;
-    return loop ? index + loopClonesPerSide : index;
-  }
-
-  _getSnapOffsets(props = this.props) {
-    const offset = this._getItemMainDimension();
-
-    return [...Array(this._getCustomDataLength(props))].map((_, i) => {
-      return i * offset;
-    });
-  }
-
-  _getFirstItem(index, props = this.props) {
-    const {
-      loopClonesPerSide
-    } = props;
-
-    const itemsLength = this._getCustomDataLength(props);
-
-    if (!itemsLength || index > itemsLength - 1 || index < 0) {
-      return 0;
-    }
-
-    return this._enableLoop() ? index + loopClonesPerSide : index;
-  }
-
-  _getWrappedRef() {
-    // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component
-    if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {
-      return this._carouselRef;
-    } // https://github.com/facebook/react-native/issues/10635
-    // https://stackoverflow.com/a/48786374/8412141
-
-
-    return this._carouselRef && // @ts-expect-error This is for before 0.62
-    this._carouselRef.getNode && // @ts-expect-error This is for before 0.62
-    this._carouselRef.getNode();
-  }
-
-  _getScrollEnabled() {
-    return this._scrollEnabled;
-  }
-
-  _setScrollEnabled(scrollEnabled = true) {
-    const wrappedRef = this._getWrappedRef();
-
-    if (!wrappedRef || !wrappedRef.setNativeProps) {
-      return;
-    } // 'setNativeProps()' is used instead of 'setState()' because the latter
-    // really takes a toll on Android behavior when momentum is disabled
-
-
-    wrappedRef.setNativeProps({
-      scrollEnabled
-    });
-    this._scrollEnabled = scrollEnabled;
-  }
-
-  _getItemMainDimension() {
-    return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;
-  }
-
-  _getItemScrollOffset(index) {
-    return this._positions && this._positions[index] && this._positions[index].start;
-  }
-
-  _getItemLayout(_, index) {
-    const itemMainDimension = this._getItemMainDimension();
-
-    return {
-      index,
-      length: itemMainDimension,
-      offset: itemMainDimension * index // + this._getContainerInnerMargin()
-
-    };
-  } // This will allow us to have a proper zIndex even with a FlatList
-  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165
-
-
-  _getCellRendererComponent({
-    children,
-    index,
-    style,
-    ...props
-  }) {
-    const cellStyle = [style, !IS_ANDROID ? {
-      zIndex: this._getCustomDataLength() - index
-    } : {}];
-    return /*#__PURE__*/_react.default.createElement(_reactNative.View, _extends({
-      style: cellStyle,
-      key: index
-    }, props), children);
-  }
-
-  _getKeyExtractor(_, index) {
-    return this._needsScrollView() ? "scrollview-item-".concat(index) : "flatlist-item-".concat(index);
-  }
-
-  _getScrollOffset(event) {
-    const {
-      vertical
-    } = this.props;
-    return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;
-  }
-
-  _getContainerInnerMargin(opposite = false) {
-    const {
-      activeSlideAlignment
-    } = this.props;
-
-    if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {
-      return 0;
-    } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {
-      return this.props.vertical ? this.props.sliderHeight - this.props.itemHeight : this.props.sliderWidth - this.props.itemWidth;
-    } else {
-      return this.props.vertical ? (this.props.sliderHeight - this.props.itemHeight) / 2 : (this.props.sliderWidth - this.props.itemWidth) / 2;
-    }
-  }
-
-  _getActiveSlideOffset() {
-    const {
-      activeSlideOffset
-    } = this.props;
-
-    const itemMainDimension = this._getItemMainDimension();
-
-    const minOffset = 10; // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide
-
-    return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;
-  }
-
-  _getActiveItem(offset) {
-    const itemMainDimension = this._getItemMainDimension();
-
-    const center = offset + itemMainDimension / 2;
-
-    const activeSlideOffset = this._getActiveSlideOffset();
-
-    const lastIndex = this._positions.length - 1;
-    let itemIndex;
-
-    if (offset <= 0) {
-      return 0;
-    }
-
-    if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {
-      return lastIndex;
-    }
-
-    for (let i = 0; i < this._positions.length; i++) {
-      const {
-        start,
-        end
-      } = this._positions[i];
-
-      if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {
-        itemIndex = i;
-        break;
-      }
-    }
-
-    return itemIndex || 0;
-  }
-
-  _getSlideInterpolatedStyle(index, animatedValue) {
-    const {
-      layoutCardOffset,
-      slideInterpolatedStyle
-    } = this.props;
-
-    if (slideInterpolatedStyle) {
-      return slideInterpolatedStyle(index, animatedValue, this.props);
-    } else if (this._shouldUseTinderLayout()) {
-      return (0, _animations.tinderAnimatedStyles)(index, animatedValue, this.props, layoutCardOffset);
-    } else if (this._shouldUseStackLayout()) {
-      return (0, _animations.stackAnimatedStyles)(index, animatedValue, this.props, layoutCardOffset);
-    } else if (this._shouldUseShiftLayout()) {
-      return (0, _animations.shiftAnimatedStyles)(index, animatedValue, this.props);
-    } else {
-      return (0, _animations.defaultAnimatedStyles)(index, animatedValue, this.props);
-    }
-  }
-
-  _initPositionsAndInterpolators(props = this.props) {
-    const {
-      data,
-      scrollInterpolator
-    } = props;
-
-    const itemMainDimension = this._getItemMainDimension();
-
-    if (!data || !data.length) {
-      return;
-    }
-
-    const interpolators = [];
-    this._positions = [];
-
-    this._getCustomData(props).forEach((_itemData, index) => {
-      const _index = this._getCustomIndex(index, props);
-
-      let animatedValue;
-      this._positions[index] = {
-        start: index * itemMainDimension,
-        end: index * itemMainDimension + itemMainDimension
-      };
-
-      if (!this._shouldAnimateSlides(props) || !this._scrollPos) {
-        animatedValue = new _reactNative.Animated.Value(1);
-      } else {
-        let interpolator;
-
-        if (scrollInterpolator) {
-          interpolator = scrollInterpolator(_index, props);
-        } else if (this._shouldUseStackLayout()) {
-          interpolator = (0, _animations.stackScrollInterpolator)(_index, props);
-        } else if (this._shouldUseTinderLayout()) {
-          interpolator = (0, _animations.tinderScrollInterpolator)(_index, props);
-        }
-
-        if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {
-          interpolator = (0, _animations.defaultScrollInterpolator)(_index, props);
-        }
-
-        animatedValue = this._scrollPos.interpolate({ ...interpolator,
-          extrapolate: 'clamp'
-        });
-      }
-
-      interpolators.push(animatedValue);
-    });
-
-    this.setState({
-      interpolators
-    });
-  }
-
-  _hackActiveSlideAnimation(index, scrollValue = 1) {
-    const offset = this._getItemScrollOffset(index);
-
-    if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {
-      return;
-    }
-
-    const multiplier = this._currentScrollOffset === 0 ? 1 : -1;
-    const scrollDelta = scrollValue * multiplier;
-
-    this._scrollTo({
-      offset: offset + scrollDelta,
-      animated: false
-    }); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-
-    clearTimeout(this._hackSlideAnimationTimeout);
-    this._hackSlideAnimationTimeout = setTimeout(() => {
-      this._scrollTo({
-        offset,
-        animated: false
-      });
-    }, 1); // works randomly when set to '0'
-  }
-
-  _repositionScroll(index, animated = false) {
-    const {
-      data,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {
-      return;
-    }
-
-    let repositionTo = index;
-
-    if (index >= dataLength + loopClonesPerSide) {
-      repositionTo = index - dataLength;
-    } else if (index < loopClonesPerSide) {
-      repositionTo = index + dataLength;
-    }
-
-    this._snapToItem(repositionTo, animated, false);
-  }
-
-  _scrollTo({
-    offset,
-    index,
-    animated = true
-  }) {
-    const {
-      vertical
-    } = this.props;
-
-    const wrappedRef = this._getWrappedRef();
-
-    if (!this._mounted || !wrappedRef || typeof offset === 'undefined' && typeof index === 'undefined') {
-      return;
-    }
-
-    let scrollToOffset;
-
-    if (typeof index !== 'undefined') {
-      scrollToOffset = this._getItemScrollOffset(index);
-    } else {
-      scrollToOffset = offset;
-    }
-
-    if (typeof scrollToOffset === 'undefined') {
-      return;
-    }
-
-    const options = this._needsScrollView() ? {
-      x: vertical ? 0 : offset,
-      y: vertical ? offset : 0,
-      animated
-    } : {
-      offset,
-      animated
-    };
-
-    if (this._needsScrollView()) {
-      wrappedRef.scrollTo(options);
-    } else {
-      wrappedRef.scrollToOffset(options);
-    }
-  }
-
-  _onTouchStart(event) {
-    const {
-      onTouchStart
-    } = this.props; // `onTouchStart` is fired even when `scrollEnabled` is set to `false`
-
-    if (this._getScrollEnabled() !== false && this._autoplaying) {
-      this.pauseAutoPlay();
-    }
-
-    onTouchStart && onTouchStart(event);
-  }
-
-  _onTouchEnd(event) {
-    const {
-      onTouchEnd
-    } = this.props;
-
-    if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {
-      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()
-      this.startAutoplay();
-    }
-
-    onTouchEnd && onTouchEnd(event);
-  }
-
-  _onScroll(event) {
-    const {
-      onScroll,
-      onScrollIndexChanged
-    } = this.props;
-    const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
-
-    const nextActiveItem = this._getActiveItem(scrollOffset);
-
-    this._currentScrollOffset = scrollOffset;
-
-    if (nextActiveItem !== this._onScrollActiveItem) {
-      this._onScrollActiveItem = nextActiveItem;
-      onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));
-    }
-
-    if (typeof onScroll === 'function' && event) {
-      onScroll(event);
-    }
-  }
-
-  _onMomentumScrollEnd(event) {
-    const {
-      autoplayDelay,
-      onMomentumScrollEnd,
-      onSnapToItem
-    } = this.props;
-    const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
-
-    const nextActiveItem = this._getActiveItem(scrollOffset);
-
-    const hasSnapped = this._isMultiple(scrollOffset, this.props.vertical ? this.props.itemHeight : this.props.itemWidth); // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:
-    // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated
-    // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically
-
-
-    if (nextActiveItem !== this._activeItem) {
-      this._activeItem = nextActiveItem;
-      onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));
-
-      if (hasSnapped) {
-        this._repositionScroll(nextActiveItem);
-      }
-    }
-
-    onMomentumScrollEnd && onMomentumScrollEnd(event); // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed
-    // https://github.com/facebook/react-native/issues/9439
-
-    if (IS_ANDROID && this._autoplay && !this._autoplaying) {
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._enableAutoplayTimeout);
-      this._enableAutoplayTimeout = setTimeout(() => {
-        this.startAutoplay();
-      }, autoplayDelay);
-    }
-  }
-
-  _onLayout(event) {
-    const {
-      onLayout
-    } = this.props; // Prevent unneeded actions during the first 'onLayout' (triggered on init)
-
-    if (this._onLayoutInitDone) {
-      this._initPositionsAndInterpolators();
-
-      this._snapToItem(this._activeItem, false, false, true);
-    } else {
-      this._onLayoutInitDone = true;
-    }
-
-    onLayout && onLayout(event);
-  }
-
-  _snapToItem(index, animated = true, fireCallback = true, forceScrollTo = false) {
-    const {
-      onSnapToItem
-    } = this.props;
-
-    const itemsLength = this._getCustomDataLength();
-
-    const wrappedRef = this._getWrappedRef();
-
-    if (!itemsLength || !wrappedRef) {
-      return;
-    }
-
-    if (!index || index < 0) {
-      index = 0;
-    } else if (itemsLength > 0 && index >= itemsLength) {
-      index = itemsLength - 1;
-    }
-
-    if (index === this._activeItem && !forceScrollTo) {
-      return;
-    }
-
-    const offset = this._getItemScrollOffset(index);
-
-    if (offset === undefined) {
-      return;
-    }
-
-    this._scrollTo({
-      offset,
-      animated
-    }); // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated
-    // so we need to trigger the callback manually
-    // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically
-    // Therefore everything critical needs to be manually called here as well, even though the timing might be off
-
-
-    const requiresManualTrigger = !animated || IS_ANDROID;
-
-    if (requiresManualTrigger) {
-      this._activeItem = index;
-
-      if (fireCallback) {
-        onSnapToItem && onSnapToItem(this._getDataIndex(index));
-      } // Repositioning on Android
-
-
-      if (IS_ANDROID && this._shouldRepositionScroll(index)) {
-        if (animated) {
-          this._androidRepositioningTimeout = setTimeout(() => {
-            // Without scroll animation, the behavior is completely buggy...
-            this._repositionScroll(index, true);
-          }, 400); // Approximate scroll duration on Android
-        } else {
-          this._repositionScroll(index);
-        }
-      }
-    }
-  }
-
-  startAutoplay() {
-    const {
-      autoplayInterval,
-      autoplayDelay
-    } = this.props;
-    this._autoplay = true;
-
-    if (this._autoplaying) {
-      return;
-    } // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-
-    clearTimeout(this._autoplayTimeout);
-    this._autoplayTimeout = setTimeout(() => {
-      this._autoplaying = true;
-      this._autoplayInterval = setInterval(() => {
-        if (this._autoplaying) {
-          this.snapToNext();
-        }
-      }, autoplayInterval);
-    }, autoplayDelay);
-  }
-
-  pauseAutoPlay() {
-    this._autoplaying = false; // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._autoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._enableAutoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearInterval(this._autoplayInterval);
-  }
-
-  stopAutoplay() {
-    this._autoplay = false;
-    this.pauseAutoPlay();
-  }
-
-  snapToItem(index, animated = true, fireCallback = true) {
-    if (!index || index < 0) {
-      index = 0;
-    }
-
-    const positionIndex = this._getPositionIndex(index);
-
-    if (positionIndex === this._activeItem) {
-      return;
-    }
-
-    this._snapToItem(positionIndex, animated, fireCallback);
-  }
-
-  snapToNext(animated = true, fireCallback = true) {
-    const itemsLength = this._getCustomDataLength();
-
-    let newIndex = this._activeItem + 1;
-
-    if (newIndex > itemsLength - 1) {
-      newIndex = 0;
-    }
-
-    this._snapToItem(newIndex, animated, fireCallback);
-  }
-
-  snapToPrev(animated = true, fireCallback = true) {
-    const itemsLength = this._getCustomDataLength();
-
-    let newIndex = this._activeItem - 1;
-
-    if (newIndex < 0) {
-      newIndex = itemsLength - 1;
-    }
-
-    this._snapToItem(newIndex, animated, fireCallback);
-  } // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668
-
-
-  triggerRenderingHack(offset = 1) {
-    this._hackActiveSlideAnimation(this._activeItem, offset);
-  }
-
-  _renderItem({
-    item,
-    index
-  }) {
-    const {
-      interpolators
-    } = this.state;
-    const {
-      keyExtractor,
-      slideStyle
-    } = this.props;
-    const animatedValue = interpolators && interpolators[index];
-
-    if (typeof animatedValue === 'undefined') {
-      return null;
-    }
-
-    const animate = this._shouldAnimateSlides();
-
-    const Component = animate ? _reactNative.Animated.View : _reactNative.View;
-    const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};
-
-    const dataIndex = this._getDataIndex(index);
-
-    const mainDimension = this.props.vertical ? {
-      height: this.props.itemHeight
-    } : {
-      width: this.props.itemWidth
-    };
-    const specificProps = this._needsScrollView() ? {
-      key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)
-    } : {};
-    return /*#__PURE__*/_react.default.createElement(Component, _extends({
-      style: [mainDimension, slideStyle, animatedStyle],
-      pointerEvents: "box-none"
-    }, specificProps), this.props.vertical ? this.props.renderItem({
-      item,
-      index,
-      dataIndex
-    }, {
-      scrollPosition: this._scrollPos,
-      carouselRef: this._carouselRef,
-      vertical: this.props.vertical,
-      sliderHeight: this.props.sliderHeight,
-      itemHeight: this.props.itemHeight
-    }) : this.props.renderItem({
-      item,
-      index,
-      dataIndex
-    }, {
-      scrollPosition: this._scrollPos,
-      carouselRef: this._carouselRef,
-      vertical: !!this.props.vertical,
-      sliderWidth: this.props.sliderWidth,
-      itemWidth: this.props.itemWidth
-    }));
-  }
-
-  _getComponentOverridableProps() {
-    const {
-      hideCarousel
-    } = this.state;
-    const {
-      loopClonesPerSide
-    } = this.props;
-    const visibleItems = Math.ceil(this.props.vertical ? this.props.sliderHeight / this.props.itemHeight : this.props.sliderWidth / this.props.itemWidth) + 1;
-    const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;
-    const initialNumToRender = visibleItems + initialNumPerSide * 2;
-    const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;
-    const windowSize = maxToRenderPerBatch;
-    const specificProps = !this._needsScrollView() ? {
-      initialNumToRender,
-      maxToRenderPerBatch,
-      windowSize // updateCellsBatchingPeriod
-
-    } : {};
-    return { ...specificProps,
-      automaticallyAdjustContentInsets: false,
-      decelerationRate: 'fast',
-      directionalLockEnabled: true,
-      disableScrollViewPanResponder: false,
-      // If set to `true`, touch events will be triggered too easily
-      inverted: this._needsRTLAdaptations(),
-      overScrollMode: 'never',
-      pinchGestureEnabled: false,
-      pointerEvents: hideCarousel ? 'none' : 'auto',
-      // removeClippedSubviews: !this._needsScrollView(),
-      // renderToHardwareTextureAndroid: true,
-      scrollsToTop: false,
-      showsHorizontalScrollIndicator: false,
-      showsVerticalScrollIndicator: false
-    };
-  }
-
-  _getComponentStaticProps() {
-    const {
-      hideCarousel
-    } = this.state;
-    const {
-      activeSlideAlignment,
-      CellRendererComponent,
-      containerCustomStyle,
-      contentContainerCustomStyle,
-      firstItem,
-      getItemLayout,
-      keyExtractor,
-      style,
-      useExperimentalSnap
-    } = this.props;
-    const containerStyle = [// { overflow: 'hidden' },
-    containerCustomStyle || style || {}, hideCarousel ? {
-      opacity: 0
-    } : {}, this.props.vertical ? {
-      height: this.props.sliderHeight,
-      flexDirection: 'column'
-    } : // LTR hack; see https://github.com/facebook/react-native/issues/11960
-    // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423
-    {
-      width: this.props.sliderWidth,
-      flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'
-    }];
-    const innerMarginStyle = this.props.vertical ? {
-      paddingTop: this._getContainerInnerMargin(),
-      paddingBottom: this._getContainerInnerMargin(true)
-    } : {
-      paddingLeft: this._getContainerInnerMargin(),
-      paddingRight: this._getContainerInnerMargin(true)
-    };
-    const contentContainerStyle = [!useExperimentalSnap ? innerMarginStyle : {}, contentContainerCustomStyle || {}]; // WARNING: `snapToAlignment` won't work as intended because of the following:
-    // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755
-    // - Snap points will be off
-    // - Slide animations will be off
-    // - Last items won't be set as active (no `onSnapToItem` callback)
-    // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being
-
-    const snapProps = useExperimentalSnap ? {
-      // disableIntervalMomentum: true, // Slide ± one item at a time
-      snapToAlignment: activeSlideAlignment,
-      snapToInterval: this._getItemMainDimension()
-    } : {
-      snapToOffsets: this._getSnapOffsets()
-    }; // Flatlist specifics
-
-    const specificProps = !this._needsScrollView() ? {
-      CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,
-      getItemLayout: getItemLayout || this._getItemLayout,
-      initialScrollIndex: this._getFirstItem(firstItem),
-      keyExtractor: keyExtractor || this._getKeyExtractor,
-      numColumns: 1,
-      renderItem: this._renderItem
-    } : {};
-    return { ...specificProps,
-      ...snapProps,
-      // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      ref: c => {
-        this._carouselRef = c;
-      },
-      contentContainerStyle: contentContainerStyle,
-      data: this._getCustomData(),
-      horizontal: !this.props.vertical,
-      scrollEventThrottle: 1,
-      style: containerStyle,
-      onLayout: this._onLayout,
-      onMomentumScrollEnd: this._onMomentumScrollEnd,
-      onScroll: this._onScrollHandler,
-      onTouchStart: this._onTouchStart,
-      onTouchEnd: this._onTouchEnd
-    };
-  }
-
-  render() {
-    const {
-      data,
-      renderItem,
-      useScrollView
-    } = this.props;
-
-    if (!data || !renderItem) {
-      return null;
-    }
-
-    const props = { ...this._getComponentOverridableProps(),
-      ...this.props,
-      ...this._getComponentStaticProps()
-    };
-    const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : _reactNative.Animated.ScrollView;
-    return this._needsScrollView() || !_reactNative.Animated.FlatList ? /*#__PURE__*/_react.default.createElement(ScrollViewComponent, props, this._getCustomData().map((item, index) => {
-      return this._renderItem({
-        item,
-        index
-      });
-    })) :
-    /*#__PURE__*/
-    // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between
-    // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.
-    _react.default.createElement(_reactNative.Animated.FlatList, props);
-  }
-
-}
-
-exports.Carousel = Carousel;
-
-_defineProperty(Carousel, "defaultProps", {
-  activeSlideAlignment: 'center',
-  activeSlideOffset: 20,
-  apparitionDelay: 0,
-  autoplay: false,
-  autoplayDelay: 1000,
-  autoplayInterval: 3000,
-  callbackOffsetMargin: 5,
-  containerCustomStyle: {},
-  contentContainerCustomStyle: {},
-  enableSnap: true,
-  firstItem: 0,
-  hasParallaxImages: false,
-  inactiveSlideOpacity: 0.7,
-  inactiveSlideScale: 0.9,
-  inactiveSlideShift: 0,
-  layout: 'default',
-  loop: false,
-  loopClonesPerSide: 3,
-  scrollEnabled: true,
-  slideStyle: {},
-  shouldOptimizeUpdates: true,
-  useExperimentalSnap: false,
-  useScrollView: !_reactNative.Animated.FlatList
-});
-
-var _default = Carousel;
-exports.default = _default;
-//# sourceMappingURL=Carousel.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js.map
deleted file mode 100644
index b3f21d1..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/Carousel.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Carousel.tsx"],"names":["IS_ANDROID","Platform","OS","IS_RTL","I18nManager","isRTL","Carousel","React","Component","constructor","props","state","hideCarousel","apparitionDelay","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_onScrollActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentScrollOffset","_scrollEnabled","scrollEnabled","_getCellRendererComponent","bind","_getItemLayout","_getKeyExtractor","_onLayout","_onScroll","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_renderItem","_setScrollHandler","_displayWarnings","componentDidMount","autoplay","_initPositionsAndInterpolators","_initTimeout","setTimeout","apparitionCallback","setState","startAutoplay","_needsScrollView","_firstItem","_snapToItem","_apparitionTimeout","shouldComponentUpdate","nextProps","nextState","shouldOptimizeUpdates","componentDidUpdate","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSize","vertical","itemHeight","sliderHeight","itemWidth","sliderWidth","_setScrollEnabled","length","_hackActiveSlideAnimation","onScroll","componentWillUnmount","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_androidRepositioningTimeout","realIndex","currentIndex","_getDataIndex","currentScrollPosition","scrollEventConfig","listener","useNativeDriver","_scrollPos","Animated","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","pluginName","removedProps","console","error","forEach","removedProp","warn","useScrollView","FlatList","_shouldUseStackLayout","_shouldUseTinderLayout","_needsRTLAdaptations","_enableLoop","data","enableSnap","loop","_shouldAnimateSlides","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","inactiveSlideShift","layout","_shouldRepositionScroll","index","loopClonesPerSide","dataLength","_roundNumber","num","decimals","rounder","Math","pow","round","Number","EPSILON","_isMultiple","_getCustomData","previousItems","nextItems","dataMultiplier","floor","remainder","i","unshift","slice","concat","_getCustomIndex","baseDataIndexes","dataIndexes","j","_getPositionIndex","_getSnapOffsets","offset","_getItemMainDimension","map","_","_getWrappedRef","_carouselRef","scrollTo","scrollToOffset","getNode","_getScrollEnabled","wrappedRef","setNativeProps","_getItemScrollOffset","start","itemMainDimension","children","style","cellStyle","zIndex","_getScrollOffset","_getContainerInnerMargin","opposite","activeSlideAlignment","_getActiveSlideOffset","activeSlideOffset","minOffset","_getActiveItem","center","lastIndex","itemIndex","end","_getSlideInterpolatedStyle","animatedValue","layoutCardOffset","_itemData","_index","interpolator","inputRange","outputRange","interpolate","extrapolate","scrollValue","multiplier","scrollDelta","_scrollTo","animated","_repositionScroll","repositionTo","options","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollIndexChanged","scrollOffset","autoplayDelay","onMomentumScrollEnd","onSnapToItem","hasSnapped","onLayout","_onLayoutInitDone","fireCallback","forceScrollTo","undefined","requiresManualTrigger","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","snapToItem","positionIndex","newIndex","snapToPrev","triggerRenderingHack","item","keyExtractor","slideStyle","animate","View","animatedStyle","dataIndex","mainDimension","height","width","specificProps","key","renderItem","scrollPosition","carouselRef","_getComponentOverridableProps","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","automaticallyAdjustContentInsets","decelerationRate","directionalLockEnabled","disableScrollViewPanResponder","inverted","overScrollMode","pinchGestureEnabled","pointerEvents","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","_getComponentStaticProps","CellRendererComponent","containerCustomStyle","contentContainerCustomStyle","getItemLayout","useExperimentalSnap","containerStyle","opacity","flexDirection","innerMarginStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","contentContainerStyle","snapProps","snapToAlignment","snapToInterval","snapToOffsets","initialScrollIndex","numColumns","ref","c","horizontal","scrollEventThrottle","render","ScrollViewComponent","ScrollView","callbackOffsetMargin","hasParallaxImages"],"mappings":"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","sourcesContent":["import React, { PropsWithChildren } from 'react';\nimport {\n    Animated,\n    FlatList,\n    I18nManager,\n    Platform,\n    ScrollView,\n    View,\n    StyleProp,\n    NativeSyntheticEvent,\n    NativeScrollEvent,\n    LayoutChangeEvent,\n    GestureResponderEvent,\n    ViewStyle\n} from 'react-native';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\nimport type { CarouselProps, CarouselState } from './types';\n\n// Metro doesn't support dynamic imports - i.e. require() done in the component itself\n// But at the same time the following import will fail on Snack...\n// TODO: find a way to get React Native's version without having to assume the file path\n// import RN_PACKAGE from '../../../react-native/package.json';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport class Carousel<TData> extends React.Component<\n  CarouselProps<TData>,\n  CarouselState\n> {\n  static defaultProps = {\n      activeSlideAlignment: 'center',\n      activeSlideOffset: 20,\n      apparitionDelay: 0,\n      autoplay: false,\n      autoplayDelay: 1000,\n      autoplayInterval: 3000,\n      callbackOffsetMargin: 5,\n      containerCustomStyle: {},\n      contentContainerCustomStyle: {},\n      enableSnap: true,\n      firstItem: 0,\n      hasParallaxImages: false,\n      inactiveSlideOpacity: 0.7,\n      inactiveSlideScale: 0.9,\n      inactiveSlideShift: 0,\n      layout: 'default',\n      loop: false,\n      loopClonesPerSide: 3,\n      scrollEnabled: true,\n      slideStyle: {},\n      shouldOptimizeUpdates: true,\n      useExperimentalSnap: false,\n      useScrollView: !Animated.FlatList\n  };\n\n  _activeItem: number;\n  _onScrollActiveItem: number;\n  _previousFirstItem: number;\n  _previousItemsLength: number;\n  _mounted: boolean;\n  _positions: { start: number; end: number }[];\n  _currentScrollOffset: number;\n  _scrollEnabled: boolean;\n\n  _initTimeout?: ReturnType<typeof setTimeout>;\n  _apparitionTimeout?: ReturnType<typeof setTimeout>;\n  _hackSlideAnimationTimeout?: ReturnType<typeof setTimeout>;\n  _enableAutoplayTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayTimeout?: ReturnType<typeof setTimeout>;\n  _snapNoMomentumTimeout?: ReturnType<typeof setTimeout>;\n  _androidRepositioningTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayInterval?: ReturnType<typeof setInterval>;\n\n  _scrollPos?: Animated.Value;\n\n  _onScrollHandler?: ReturnType<typeof Animated.event>;\n\n  _carouselRef: ScrollView | FlatList<TData> | null = null;\n\n  _autoplaying?: boolean;\n  _autoplay?: boolean;\n\n  _onLayoutInitDone?: boolean;\n\n  constructor (props: CarouselProps<TData>) {\n      super(props);\n\n      this.state = {\n          hideCarousel: !!props.apparitionDelay,\n          interpolators: []\n      };\n\n      // this._RNVersionCode = this._getRNVersionCode();\n\n      // The following values are not stored in the state because 'setState()' is asynchronous\n      // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n      const initialActiveItem = this._getFirstItem(props.firstItem);\n      this._activeItem = initialActiveItem;\n      this._onScrollActiveItem = initialActiveItem;\n      this._previousFirstItem = initialActiveItem;\n      this._previousItemsLength = initialActiveItem;\n\n      this._mounted = false;\n      this._positions = [];\n      this._currentScrollOffset = 0; // Store ScrollView's scroll position\n      this._scrollEnabled = props.scrollEnabled !== false;\n\n      this._getCellRendererComponent = this._getCellRendererComponent.bind(this);\n      this._getItemLayout = this._getItemLayout.bind(this);\n      this._getKeyExtractor = this._getKeyExtractor.bind(this);\n      this._onLayout = this._onLayout.bind(this);\n      this._onScroll = this._onScroll.bind(this);\n      this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);\n      this._onTouchStart = this._onTouchStart.bind(this);\n      this._onTouchEnd = this._onTouchEnd.bind(this);\n      this._renderItem = this._renderItem.bind(this);\n\n      // WARNING: call this AFTER binding _onScroll\n      this._setScrollHandler(props);\n\n      // Display warnings\n      this._displayWarnings(props);\n  }\n\n  componentDidMount () {\n      const { apparitionDelay, autoplay, firstItem } = this.props;\n\n      this._mounted = true;\n      this._initPositionsAndInterpolators();\n\n      // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n      this._initTimeout = setTimeout(() => {\n          if (!this._mounted) {\n              return;\n          }\n\n          const apparitionCallback = () => {\n              if (apparitionDelay) {\n                  this.setState({ hideCarousel: false });\n              }\n              if (autoplay) {\n                  this.startAutoplay();\n              }\n          };\n\n          // FlatList will use its own built-in prop `initialScrollIndex`\n          if (this._needsScrollView()) {\n              const _firstItem = this._getFirstItem(firstItem);\n              this._snapToItem(_firstItem, false, false, true);\n              // this._hackActiveSlideAnimation(_firstItem);\n          }\n\n          if (apparitionDelay) {\n              this._apparitionTimeout = setTimeout(() => {\n                  apparitionCallback();\n              }, apparitionDelay);\n          } else {\n              apparitionCallback();\n          }\n      }, 1);\n  }\n\n  shouldComponentUpdate (\n      nextProps: CarouselProps<TData>,\n      nextState: CarouselState\n  ): boolean {\n      if (this.props.shouldOptimizeUpdates === false) {\n          return true;\n      } else {\n          return shallowCompare(this, nextProps, nextState);\n      }\n  }\n\n  componentDidUpdate (prevProps: CarouselProps<TData>) {\n      const { interpolators } = this.state;\n      const {\n          firstItem,\n          scrollEnabled\n      } = this.props;\n      const itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n          return;\n      }\n\n      const nextFirstItem = this._getFirstItem(firstItem, this.props);\n      let nextActiveItem =\n      typeof this._activeItem !== 'undefined' ?\n          this._activeItem :\n          nextFirstItem;\n\n      const hasNewSize = this.props.vertical !== prevProps.vertical ||\n       (\n           this.props.vertical && prevProps.vertical && (\n               prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight\n           )\n       ) || (\n          !this.props.vertical && !prevProps.vertical && (\n              prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth\n          )\n      );\n\n      // Prevent issues with dynamically removed items\n      if (nextActiveItem > itemsLength - 1) {\n          nextActiveItem = itemsLength - 1;\n      }\n\n      // Handle changing scrollEnabled independent of user -> carousel interaction\n      if (scrollEnabled !== prevProps.scrollEnabled) {\n          this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (\n          interpolators.length !== itemsLength ||\n          hasNewSize\n      ) {\n          this._activeItem = nextActiveItem;\n          this._previousItemsLength = itemsLength;\n\n          this._initPositionsAndInterpolators(this.props);\n\n          // Handle scroll issue when dynamically removing items (see #133)\n          // This also fixes first item's active state on Android\n          // Because 'initialScrollIndex' apparently doesn't trigger scroll\n          if (this._previousItemsLength > itemsLength) {\n              this._hackActiveSlideAnimation(nextActiveItem);\n          }\n\n          if (hasNewSize) {\n              this._snapToItem(nextActiveItem, false, false, true);\n          }\n      } else if (\n          nextFirstItem !== this._previousFirstItem &&\n      nextFirstItem !== this._activeItem\n      ) {\n          this._activeItem = nextFirstItem;\n          this._previousFirstItem = nextFirstItem;\n          this._snapToItem(nextFirstItem, false, true, true);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n      }\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n      this.stopAutoplay();\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._initTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._apparitionTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._snapNoMomentumTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._androidRepositioningTimeout);\n  }\n\n  get realIndex () {\n      return this._activeItem;\n  }\n\n  get currentIndex () {\n      return this._getDataIndex(this._activeItem);\n  }\n\n  get currentScrollPosition () {\n      return this._currentScrollOffset;\n  }\n\n  _setScrollHandler (props: CarouselProps<TData>) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n          listener: this._onScroll,\n          useNativeDriver: true\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical ?\n          [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :\n          [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      // @ts-expect-error Let's ignore for now that trick\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n          argMapping.pop();\n          // @ts-expect-error Let's ignore for now that trick\n          const [argMap] = props.onScroll._argMapping;\n          if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n              // Shares the same animated value passed in props\n              this._scrollPos =\n          argMap.nativeEvent.contentOffset.x ||\n          argMap.nativeEvent.contentOffset.y ||\n          this._scrollPos;\n          }\n          // @ts-expect-error Let's ignore for now that trick\n          argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event<NativeScrollEvent>(\n          argMapping,\n          scrollEventConfig\n      );\n  }\n\n  // This will return a future-proof version code number compatible with semantic versioning\n  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002\n  // _getRNVersionCode () {\n  //     const version = RN_PACKAGE && RN_PACKAGE.version;\n  //     if (!version) {\n  //         return null;\n  //     }\n  //     const versionSplit = version.split('.');\n  //     if (!versionSplit || !versionSplit.length) {\n  //         return null;\n  //     }\n  //     return versionSplit[0] * 10000 +\n  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +\n  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);\n  // }\n\n  _displayWarnings (props: CarouselProps<TData> = this.props) {\n      const pluginName = 'react-native-snap-carousel';\n      const removedProps = [\n          'activeAnimationType',\n          'activeAnimationOptions',\n          'enableMomentum',\n          'lockScrollTimeoutDuration',\n          'lockScrollWhileSnapping',\n          'onBeforeSnapToItem',\n          'swipeThreshold'\n      ] as const;\n\n      // if (this._RNVersionCode && this._RNVersionCode < 5800) {\n      //     console.error(\n      //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +\n      //         'Please downgrade to version 3.x or update your version of React Native.'\n      //     );\n      // }\n      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`\n          );\n      }\n      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`\n          );\n      }\n\n      removedProps.forEach((removedProp) => {\n          if (removedProp in props) {\n              console.warn(\n                  `${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`\n              );\n          }\n      });\n  }\n\n  _needsScrollView () {\n      const { useScrollView } = this.props;\n      // Android's cell renderer is buggy and has a stange overflow\n      // TODO: a workaround might be to pass the custom animated styles directly to it\n      return IS_ANDROID ?\n          useScrollView ||\n          !Animated.FlatList ||\n          this._shouldUseStackLayout() ||\n          this._shouldUseTinderLayout() :\n          useScrollView || !Animated.FlatList;\n  }\n\n  _needsRTLAdaptations () {\n      const { vertical } = this.props;\n      return IS_RTL && IS_ANDROID && !vertical;\n  }\n\n  _enableLoop () {\n      const { data, enableSnap, loop } = this.props;\n      return enableSnap && loop && data && data.length && data.length > 1;\n  }\n\n  _shouldAnimateSlides (props: CarouselProps<TData> = this.props) {\n      const {\n          inactiveSlideOpacity,\n          inactiveSlideScale,\n          scrollInterpolator,\n          slideInterpolatedStyle\n      } = props;\n      return (\n          inactiveSlideOpacity < 1 ||\n      inactiveSlideScale < 1 ||\n      !!scrollInterpolator ||\n      !!slideInterpolatedStyle ||\n      this._shouldUseShiftLayout() ||\n      this._shouldUseStackLayout() ||\n      this._shouldUseTinderLayout()\n      );\n  }\n\n  _shouldUseShiftLayout () {\n      const { inactiveSlideShift, layout } = this.props;\n      return layout === 'default' && inactiveSlideShift !== 0;\n  }\n\n  _shouldUseStackLayout () {\n      return this.props.layout === 'stack';\n  }\n\n  _shouldUseTinderLayout () {\n      return this.props.layout === 'tinder';\n  }\n\n  _shouldRepositionScroll (index: number) {\n      const { data, enableSnap, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n      if (\n          !enableSnap ||\n      !dataLength ||\n      !this._enableLoop() ||\n      (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)\n      ) {\n          return false;\n      }\n      return true;\n  }\n\n  _roundNumber (num: number, decimals = 1) {\n      // https://stackoverflow.com/a/41716722/\n      const rounder = Math.pow(10, decimals);\n      return Math.round((num + Number.EPSILON) * rounder) / rounder;\n  }\n\n  _isMultiple (x: number, y: number) {\n      // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/\n      // Required because Android viewport size can return pretty complicated decimals numbers\n      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n  }\n\n  _getCustomData (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return [];\n      }\n\n      if (!this._enableLoop()) {\n          return data;\n      }\n\n      let previousItems = [];\n      let nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n          const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          const remainder = loopClonesPerSide % dataLength;\n\n          for (let i = 0; i < dataMultiplier; i++) {\n              previousItems.push(...data);\n              nextItems.push(...data);\n          }\n\n          previousItems.unshift(...data.slice(-remainder));\n          nextItems.push(...data.slice(0, remainder));\n      } else {\n          previousItems = data.slice(-loopClonesPerSide);\n          nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n  }\n\n  _getCustomDataLength (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n  }\n\n  _getCustomIndex (index: number, props: CarouselProps<TData> = this.props) {\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || typeof index === 'undefined') {\n          return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n  }\n\n  _getDataIndex (index: number) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n          return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n          return loopClonesPerSide > dataLength ?\n              (index - loopClonesPerSide) % dataLength :\n              index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n      // TODO: is there a simpler way of determining the interpolated index?\n          if (loopClonesPerSide > dataLength) {\n              const baseDataIndexes = [];\n              const dataIndexes = [];\n              const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n              const remainder = loopClonesPerSide % dataLength;\n\n              for (let i = 0; i < dataLength; i++) {\n                  baseDataIndexes.push(i);\n              }\n\n              for (let j = 0; j < dataMultiplier; j++) {\n                  dataIndexes.push(...baseDataIndexes);\n              }\n\n              dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n              return dataIndexes[index];\n          } else {\n              return index + dataLength - loopClonesPerSide;\n          }\n      } else {\n          return index - loopClonesPerSide;\n      }\n  }\n\n  // Used with `snapToItem()` and 'PaginationDot'\n  _getPositionIndex (index: number) {\n      const { loop, loopClonesPerSide } = this.props;\n      return loop ? index + loopClonesPerSide : index;\n  }\n\n  _getSnapOffsets (props: CarouselProps<TData> = this.props) {\n      const offset = this._getItemMainDimension();\n      return [...Array(this._getCustomDataLength(props))].map((_, i) => {\n          return i * offset;\n      });\n  }\n\n  _getFirstItem (index: number, props: CarouselProps<TData> = this.props) {\n      const { loopClonesPerSide } = props;\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n          return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n  }\n\n  _getWrappedRef () {\n      // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component\n      if (\n          this._carouselRef &&\n      ((this._needsScrollView() &&\n        (this._carouselRef as ScrollView).scrollTo) ||\n        (!this._needsScrollView() &&\n          (this._carouselRef as FlatList).scrollToOffset))\n      ) {\n          return this._carouselRef;\n      }\n      // https://github.com/facebook/react-native/issues/10635\n      // https://stackoverflow.com/a/48786374/8412141\n      return (\n          this._carouselRef &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode()\n      );\n  }\n\n  _getScrollEnabled () {\n      return this._scrollEnabled;\n  }\n\n  _setScrollEnabled (scrollEnabled = true) {\n      const wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n          return;\n      }\n\n      // 'setNativeProps()' is used instead of 'setState()' because the latter\n      // really takes a toll on Android behavior when momentum is disabled\n      wrappedRef.setNativeProps({ scrollEnabled });\n      this._scrollEnabled = scrollEnabled;\n  }\n\n  _getItemMainDimension () {\n      return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;\n  }\n\n  _getItemScrollOffset (index: number) {\n      return (\n          this._positions && this._positions[index] && this._positions[index].start\n      );\n  }\n\n  _getItemLayout (_: TData[], index: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      return {\n          index,\n          length: itemMainDimension,\n          offset: itemMainDimension * index // + this._getContainerInnerMargin()\n      };\n  }\n\n  // This will allow us to have a proper zIndex even with a FlatList\n  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165\n  _getCellRendererComponent ({\n      children,\n      index,\n      style,\n      ...props\n  }: PropsWithChildren<{ index: number; style: StyleProp<ViewStyle> }>) {\n      const cellStyle = [\n          style,\n          !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}\n      ];\n\n      return (\n          <View style={cellStyle} key={index} {...props}>\n              {children}\n          </View>\n      );\n  }\n\n  _getKeyExtractor (_: TData, index: number) {\n      return this._needsScrollView() ?\n          `scrollview-item-${index}` :\n          `flatlist-item-${index}`;\n  }\n\n  _getScrollOffset (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { vertical } = this.props;\n      return (\n          (event &&\n        event.nativeEvent &&\n        event.nativeEvent.contentOffset &&\n        event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) ||\n      0\n      );\n  }\n\n  _getContainerInnerMargin (opposite = false) {\n      const { activeSlideAlignment } = this.props;\n\n      if (\n          (activeSlideAlignment === 'start' && !opposite) ||\n      (activeSlideAlignment === 'end' && opposite)\n      ) {\n          return 0;\n      } else if (\n          (activeSlideAlignment === 'end' && !opposite) ||\n      (activeSlideAlignment === 'start' && opposite)\n      ) {\n          return this.props.vertical ?\n              this.props.sliderHeight - this.props.itemHeight :\n              this.props.sliderWidth - this.props.itemWidth;\n      } else {\n          return this.props.vertical ?\n              (this.props.sliderHeight - this.props.itemHeight) / 2 :\n              (this.props.sliderWidth - this.props.itemWidth) / 2;\n      }\n  }\n\n  _getActiveSlideOffset () {\n      const { activeSlideOffset } = this.props;\n      const itemMainDimension = this._getItemMainDimension();\n      const minOffset = 10;\n      // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide\n      return itemMainDimension / 2 - activeSlideOffset >= minOffset ?\n          activeSlideOffset :\n          minOffset;\n  }\n\n  _getActiveItem (offset: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      const center = offset + itemMainDimension / 2;\n      const activeSlideOffset = this._getActiveSlideOffset();\n      const lastIndex = this._positions.length - 1;\n      let itemIndex;\n\n      if (offset <= 0) {\n          return 0;\n      }\n\n      if (\n          this._positions[lastIndex] &&\n      offset >= this._positions[lastIndex].start\n      ) {\n          return lastIndex;\n      }\n\n      for (let i = 0; i < this._positions.length; i++) {\n          const { start, end } = this._positions[i];\n          if (\n              center + activeSlideOffset >= start &&\n        center - activeSlideOffset <= end\n          ) {\n              itemIndex = i;\n              break;\n          }\n      }\n\n      return itemIndex || 0;\n  }\n\n  _getSlideInterpolatedStyle (index: number, animatedValue: Animated.AnimatedInterpolation) {\n      const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n      if (slideInterpolatedStyle) {\n          return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n          return tinderAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseStackLayout()) {\n          return stackAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseShiftLayout()) {\n          return shiftAnimatedStyles(index, animatedValue, this.props);\n      } else {\n          return defaultAnimatedStyles(index, animatedValue, this.props);\n      }\n  }\n\n  _initPositionsAndInterpolators (props: CarouselProps<TData> = this.props) {\n      const { data, scrollInterpolator } = props;\n      const itemMainDimension = this._getItemMainDimension();\n\n      if (!data || !data.length) {\n          return;\n      }\n\n      const interpolators: Animated.AnimatedInterpolation[] = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach((_itemData, index) => {\n          const _index = this._getCustomIndex(index, props);\n          let animatedValue: Animated.AnimatedInterpolation;\n\n          this._positions[index] = {\n              start: index * itemMainDimension,\n              end: index * itemMainDimension + itemMainDimension\n          };\n\n          if (!this._shouldAnimateSlides(props) || !this._scrollPos) {\n              animatedValue = new Animated.Value(1);\n          } else {\n              let interpolator;\n\n              if (scrollInterpolator) {\n                  interpolator = scrollInterpolator(_index, props);\n              } else if (this._shouldUseStackLayout()) {\n                  interpolator = stackScrollInterpolator(_index, props);\n              } else if (this._shouldUseTinderLayout()) {\n                  interpolator = tinderScrollInterpolator(_index, props);\n              }\n\n              if (\n                  !interpolator ||\n          !interpolator.inputRange ||\n          !interpolator.outputRange\n              ) {\n                  interpolator = defaultScrollInterpolator(_index, props);\n              }\n\n              animatedValue = this._scrollPos.interpolate({\n                  ...interpolator,\n                  extrapolate: 'clamp'\n              });\n          }\n\n          interpolators.push(animatedValue);\n      });\n\n      this.setState({ interpolators });\n  }\n\n  _hackActiveSlideAnimation (index: number, scrollValue = 1) {\n      const offset = this._getItemScrollOffset(index);\n\n      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n          return;\n      }\n\n      const multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n      const scrollDelta = scrollValue * multiplier;\n\n      this._scrollTo({ offset: offset + scrollDelta, animated: false });\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(() => {\n          this._scrollTo({ offset, animated: false });\n      }, 1); // works randomly when set to '0'\n  }\n\n  _repositionScroll (index: number, animated = false) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n          return;\n      }\n\n      let repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n          repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n          repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, animated, false);\n  }\n\n  _scrollTo ({\n      offset,\n      index,\n      animated = true\n  }: {\n    offset: number;\n    index?: number;\n    animated: boolean;\n  }) {\n      const { vertical } = this.props;\n      const wrappedRef = this._getWrappedRef();\n      if (\n          !this._mounted ||\n      !wrappedRef ||\n      (typeof offset === 'undefined' && typeof index === 'undefined')\n      ) {\n          return;\n      }\n\n      let scrollToOffset;\n      if (typeof index !== 'undefined') {\n          scrollToOffset = this._getItemScrollOffset(index);\n      } else {\n          scrollToOffset = offset;\n      }\n\n      if (typeof scrollToOffset === 'undefined') {\n          return;\n      }\n\n      const options = this._needsScrollView() ?\n          {\n              x: vertical ? 0 : offset,\n              y: vertical ? offset : 0,\n              animated\n          } :\n          {\n              offset,\n              animated\n          };\n\n      if (this._needsScrollView()) {\n          wrappedRef.scrollTo(options);\n      } else {\n          wrappedRef.scrollToOffset(options);\n      }\n  }\n\n  _onTouchStart (event: GestureResponderEvent) {\n      const { onTouchStart } = this.props;\n\n      // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n          this.pauseAutoPlay();\n      }\n\n      onTouchStart && onTouchStart(event);\n  }\n\n  _onTouchEnd (event: GestureResponderEvent) {\n      const { onTouchEnd } = this.props;\n\n      if (\n          this._getScrollEnabled() !== false &&\n      this._autoplay &&\n      !this._autoplaying\n      ) {\n      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()\n          this.startAutoplay();\n      }\n\n      onTouchEnd && onTouchEnd(event);\n  }\n\n  _onScroll (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { onScroll, onScrollIndexChanged } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n\n      this._currentScrollOffset = scrollOffset;\n\n      if (nextActiveItem !== this._onScrollActiveItem) {\n          this._onScrollActiveItem = nextActiveItem;\n          onScrollIndexChanged &&\n        onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n      }\n\n      if (typeof onScroll === 'function' && event) {\n          onScroll(event);\n      }\n  }\n\n  _onMomentumScrollEnd (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { autoplayDelay, onMomentumScrollEnd, onSnapToItem } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n      const hasSnapped = this._isMultiple(\n          scrollOffset,\n          this.props.vertical ? this.props.itemHeight : this.props.itemWidth\n      );\n\n      // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:\n      // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated\n      // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically\n      if (nextActiveItem !== this._activeItem) {\n          this._activeItem = nextActiveItem;\n          onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n          if (hasSnapped) {\n              this._repositionScroll(nextActiveItem);\n          }\n      }\n\n      onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n      // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n      // https://github.com/facebook/react-native/issues/9439\n      if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n          clearTimeout(this._enableAutoplayTimeout);\n          this._enableAutoplayTimeout = setTimeout(() => {\n              this.startAutoplay();\n          }, autoplayDelay);\n      }\n  }\n\n  _onLayout (event: LayoutChangeEvent) {\n      const { onLayout } = this.props;\n\n      // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n      if (this._onLayoutInitDone) {\n          this._initPositionsAndInterpolators();\n          this._snapToItem(this._activeItem, false, false, true);\n      } else {\n          this._onLayoutInitDone = true;\n      }\n\n      onLayout && onLayout(event);\n  }\n\n  _snapToItem (\n      index: number,\n      animated = true,\n      fireCallback = true,\n      forceScrollTo = false\n  ) {\n      const { onSnapToItem } = this.props;\n      const itemsLength = this._getCustomDataLength();\n      const wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n          return;\n      }\n\n      if (!index || index < 0) {\n          index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n          index = itemsLength - 1;\n      }\n\n      if (index === this._activeItem && !forceScrollTo) {\n          return;\n      }\n\n      const offset = this._getItemScrollOffset(index);\n\n      if (offset === undefined) {\n          return;\n      }\n\n      this._scrollTo({ offset, animated });\n\n      // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated\n      // so we need to trigger the callback manually\n      // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically\n      // Therefore everything critical needs to be manually called here as well, even though the timing might be off\n      const requiresManualTrigger = !animated || IS_ANDROID;\n      if (requiresManualTrigger) {\n          this._activeItem = index;\n\n          if (fireCallback) {\n              onSnapToItem && onSnapToItem(this._getDataIndex(index));\n          }\n\n          // Repositioning on Android\n          if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n              if (animated) {\n                  this._androidRepositioningTimeout = setTimeout(() => {\n                      // Without scroll animation, the behavior is completely buggy...\n                      this._repositionScroll(index, true);\n                  }, 400); // Approximate scroll duration on Android\n              } else {\n                  this._repositionScroll(index);\n              }\n          }\n      }\n  }\n\n  startAutoplay () {\n      const { autoplayInterval, autoplayDelay } = this.props;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n          return;\n      }\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(() => {\n          this._autoplaying = true;\n          this._autoplayInterval = setInterval(() => {\n              if (this._autoplaying) {\n                  this.snapToNext();\n              }\n          }, autoplayInterval);\n      }, autoplayDelay);\n  }\n\n  pauseAutoPlay () {\n      this._autoplaying = false;\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearInterval(this._autoplayInterval);\n  }\n\n  stopAutoplay () {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n  }\n\n  snapToItem (index: number, animated = true, fireCallback = true) {\n      if (!index || index < 0) {\n          index = 0;\n      }\n\n      const positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n          return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n  }\n\n  snapToNext (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem + 1;\n      if (newIndex > itemsLength - 1) {\n          newIndex = 0;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  snapToPrev (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem - 1;\n      if (newIndex < 0) {\n          newIndex = itemsLength - 1;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n  triggerRenderingHack (offset = 1) {\n      this._hackActiveSlideAnimation(this._activeItem, offset);\n  }\n\n  _renderItem ({ item, index }: { item: TData; index: number }) {\n      const { interpolators } = this.state;\n      const {\n          keyExtractor,\n          slideStyle\n      } = this.props;\n      const animatedValue = interpolators && interpolators[index];\n\n      if (typeof animatedValue === 'undefined') {\n          return null;\n      }\n\n      const animate = this._shouldAnimateSlides();\n      const Component = animate ? Animated.View : View;\n      const animatedStyle = animate ?\n          this._getSlideInterpolatedStyle(index, animatedValue) :\n          {};\n      const dataIndex = this._getDataIndex(index);\n\n      const mainDimension = this.props.vertical ?\n          { height: this.props.itemHeight } :\n          { width: this.props.itemWidth };\n      const specificProps = this._needsScrollView() ?\n          {\n              key: keyExtractor ?\n                  keyExtractor(item, index) :\n                  this._getKeyExtractor(item, index)\n          } :\n          {};\n\n      return (\n          <Component\n            style={[mainDimension, slideStyle, animatedStyle]}\n            pointerEvents='box-none'\n            {...specificProps}\n          >\n              {this.props.vertical ? this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: this.props.vertical,\n                  sliderHeight: this.props.sliderHeight,\n                  itemHeight: this.props.itemHeight\n              }) : this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: !!this.props.vertical,\n                  sliderWidth: this.props.sliderWidth,\n                  itemWidth: this.props.itemWidth\n              })}\n          </Component>\n      );\n  }\n\n  _getComponentOverridableProps () {\n      const { hideCarousel } = this.state;\n      const { loopClonesPerSide } = this.props;\n      const visibleItems =\n      Math.ceil(\n          this.props.vertical ?\n              this.props.sliderHeight / this.props.itemHeight :\n              this.props.sliderWidth / this.props.itemWidth\n      ) + 1;\n      const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      const initialNumToRender = visibleItems + initialNumPerSide * 2;\n      const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;\n      const windowSize = maxToRenderPerBatch;\n\n      const specificProps = !this._needsScrollView() ?\n          {\n              initialNumToRender,\n              maxToRenderPerBatch,\n              windowSize\n          // updateCellsBatchingPeriod\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          automaticallyAdjustContentInsets: false,\n          decelerationRate: 'fast' as const,\n          directionalLockEnabled: true,\n          disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily\n          inverted: this._needsRTLAdaptations(),\n          overScrollMode: 'never' as const,\n          pinchGestureEnabled: false,\n          pointerEvents: hideCarousel ? 'none' as const : 'auto' as const,\n          // removeClippedSubviews: !this._needsScrollView(),\n          // renderToHardwareTextureAndroid: true,\n          scrollsToTop: false,\n          showsHorizontalScrollIndicator: false,\n          showsVerticalScrollIndicator: false\n      };\n  }\n\n  _getComponentStaticProps () {\n      const { hideCarousel } = this.state;\n      const {\n          activeSlideAlignment,\n          CellRendererComponent,\n          containerCustomStyle,\n          contentContainerCustomStyle,\n          firstItem,\n          getItemLayout,\n          keyExtractor,\n          style,\n          useExperimentalSnap\n      } = this.props;\n\n      const containerStyle = [\n      // { overflow: 'hidden' },\n          containerCustomStyle || style || {},\n          hideCarousel ? { opacity: 0 } : {},\n          this.props.vertical ?\n              { height: this.props.sliderHeight, flexDirection: 'column' as const } : // LTR hack; see https://github.com/facebook/react-native/issues/11960\n          // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n              {\n                  width: this.props.sliderWidth,\n                  flexDirection: this._needsRTLAdaptations() ? 'row-reverse' as const : 'row' as const\n              }\n      ];\n\n      const innerMarginStyle = this.props.vertical ?\n          {\n              paddingTop: this._getContainerInnerMargin(),\n              paddingBottom: this._getContainerInnerMargin(true)\n          } :\n          {\n              paddingLeft: this._getContainerInnerMargin(),\n              paddingRight: this._getContainerInnerMargin(true)\n          };\n\n      const contentContainerStyle = [\n          !useExperimentalSnap ? innerMarginStyle : {},\n          contentContainerCustomStyle || {}\n      ];\n\n      // WARNING: `snapToAlignment` won't work as intended because of the following:\n      // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755\n      // - Snap points will be off\n      // - Slide animations will be off\n      // - Last items won't be set as active (no `onSnapToItem` callback)\n      // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being\n      const snapProps = useExperimentalSnap ?\n          {\n          // disableIntervalMomentum: true, // Slide ± one item at a time\n              snapToAlignment: activeSlideAlignment,\n              snapToInterval: this._getItemMainDimension()\n          } :\n          {\n              snapToOffsets: this._getSnapOffsets()\n          };\n\n      // Flatlist specifics\n      const specificProps = !this._needsScrollView() ?\n          {\n              CellRendererComponent:\n            CellRendererComponent || this._getCellRendererComponent,\n              getItemLayout: getItemLayout || this._getItemLayout,\n              initialScrollIndex: this._getFirstItem(firstItem),\n              keyExtractor: keyExtractor || this._getKeyExtractor,\n              numColumns: 1,\n              renderItem: this._renderItem\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          ...snapProps,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ref: (c: any) => {\n              this._carouselRef = c as FlatList<TData> | ScrollView;\n          },\n          contentContainerStyle: contentContainerStyle,\n          data: this._getCustomData(),\n          horizontal: !this.props.vertical,\n          scrollEventThrottle: 1,\n          style: containerStyle,\n          onLayout: this._onLayout,\n          onMomentumScrollEnd: this._onMomentumScrollEnd,\n          onScroll: this._onScrollHandler,\n          onTouchStart: this._onTouchStart,\n          onTouchEnd: this._onTouchEnd\n      };\n  }\n\n  render () {\n      const { data, renderItem, useScrollView } = this.props;\n\n      if (!data || !renderItem) {\n          return null;\n      }\n\n      const props = {\n          ...this._getComponentOverridableProps(),\n          ...this.props,\n          ...this._getComponentStaticProps()\n      };\n\n      const ScrollViewComponent =\n      typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;\n\n      return this._needsScrollView() || !Animated.FlatList ? (\n          <ScrollViewComponent {...props}>\n              {this._getCustomData().map((item, index) => {\n                  return this._renderItem({ item, index });\n              })}\n          </ScrollViewComponent>\n      ) : (\n          // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between\n          // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.\n          <Animated.FlatList {...props} />\n      );\n  }\n}\n\nexport default Carousel;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js b/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js
deleted file mode 100644
index 2f0e414..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js
+++ /dev/null
@@ -1,2 +0,0 @@
-"use strict";
-//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js.map
deleted file mode 100644
index 9ffd4b2..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/carousel/types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/index.js b/node_modules/react-native-snap-carousel/lib/commonjs/index.js
deleted file mode 100644
index 080a403..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/index.js
+++ /dev/null
@@ -1,56 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-Object.defineProperty(exports, "default", {
-  enumerable: true,
-  get: function () {
-    return _Carousel.default;
-  }
-});
-Object.defineProperty(exports, "Carousel", {
-  enumerable: true,
-  get: function () {
-    return _Carousel.default;
-  }
-});
-Object.defineProperty(exports, "Pagination", {
-  enumerable: true,
-  get: function () {
-    return _Pagination.default;
-  }
-});
-Object.defineProperty(exports, "ParallaxImage", {
-  enumerable: true,
-  get: function () {
-    return _ParallaxImage.default;
-  }
-});
-Object.defineProperty(exports, "ParallaxImageStatus", {
-  enumerable: true,
-  get: function () {
-    return _ParallaxImage.ParallaxImageStatus;
-  }
-});
-Object.defineProperty(exports, "getInputRangeFromIndexes", {
-  enumerable: true,
-  get: function () {
-    return _animations.getInputRangeFromIndexes;
-  }
-});
-
-var _Carousel = _interopRequireDefault(require("./carousel/Carousel"));
-
-var _Pagination = _interopRequireDefault(require("./pagination/Pagination"));
-
-var _ParallaxImage = _interopRequireWildcard(require("./parallaximage/ParallaxImage"));
-
-var _animations = require("./utils/animations");
-
-function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/index.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/index.js.map
deleted file mode 100644
index 1b1368b..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA","sourcesContent":["import Carousel from './carousel/Carousel';\nimport Pagination from './pagination/Pagination';\nimport ParallaxImage, { ParallaxImageStatus } from './parallaximage/ParallaxImage';\nimport { getInputRangeFromIndexes } from './utils/animations';\n\nexport {\n    Carousel as default,\n    Carousel,\n    Pagination,\n    ParallaxImage,\n    ParallaxImageStatus,\n    getInputRangeFromIndexes\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js
deleted file mode 100644
index 3816b6a..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js
+++ /dev/null
@@ -1,150 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = void 0;
-
-var _react = _interopRequireWildcard(require("react"));
-
-var _reactNative = require("react-native");
-
-var _PaginationDot = _interopRequireDefault(require("./PaginationDot"));
-
-var _Pagination = _interopRequireDefault(require("./Pagination.style"));
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
-
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-const IS_IOS = _reactNative.Platform.OS === 'ios';
-const IS_RTL = _reactNative.I18nManager.isRTL;
-
-class Pagination extends _react.PureComponent {
-  constructor(props) {
-    super(props); // Warnings
-
-    if (props.dotColor && !props.inactiveDotColor || !props.dotColor && props.inactiveDotColor) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You need to specify both `dotColor` and `inactiveDotColor`');
-    }
-
-    if (props.dotElement && !props.inactiveDotElement || !props.dotElement && props.inactiveDotElement) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You need to specify both `dotElement` and `inactiveDotElement`');
-    }
-
-    if (props.tappableDots && props.carouselRef === undefined) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You must specify prop `carouselRef` when setting `tappableDots` to `true`');
-    }
-  }
-
-  _needsRTLAdaptations() {
-    const {
-      vertical
-    } = this.props;
-    return IS_RTL && !IS_IOS && !vertical;
-  }
-
-  get _activeDotIndex() {
-    const {
-      activeDotIndex,
-      dotsLength
-    } = this.props;
-    return this._needsRTLAdaptations() ? dotsLength - activeDotIndex - 1 : activeDotIndex;
-  }
-
-  get dots() {
-    const {
-      activeOpacity,
-      carouselRef,
-      dotsLength,
-      dotColor,
-      dotContainerStyle,
-      dotElement,
-      dotStyle,
-      inactiveDotColor,
-      inactiveDotElement,
-      inactiveDotOpacity,
-      inactiveDotScale,
-      inactiveDotStyle,
-      renderDots,
-      tappableDots,
-      animatedDuration,
-      animatedFriction,
-      animatedTension,
-      delayPressInDot
-    } = this.props;
-
-    if (renderDots) {
-      return renderDots(this._activeDotIndex, dotsLength, this);
-    }
-
-    const DefaultDot = /*#__PURE__*/_react.default.createElement(_PaginationDot.default, {
-      carouselRef: carouselRef,
-      tappable: tappableDots && typeof carouselRef !== 'undefined',
-      activeOpacity: activeOpacity,
-      color: dotColor,
-      containerStyle: dotContainerStyle,
-      style: dotStyle,
-      inactiveColor: inactiveDotColor,
-      inactiveOpacity: inactiveDotOpacity,
-      inactiveScale: inactiveDotScale,
-      inactiveStyle: inactiveDotStyle,
-      animatedDuration: animatedDuration,
-      animatedFriction: animatedFriction,
-      animatedTension: animatedTension,
-      delayPressInDot: delayPressInDot
-    });
-
-    const dots = [...Array(dotsLength).keys()].map(i => {
-      const isActive = i === this._activeDotIndex;
-      return /*#__PURE__*/_react.default.cloneElement((isActive ? dotElement : inactiveDotElement) || DefaultDot, {
-        key: "pagination-dot-".concat(i),
-        active: isActive,
-        index: i
-      });
-    });
-    return dots;
-  }
-
-  render() {
-    const {
-      dotsLength,
-      containerStyle,
-      vertical,
-      accessibilityLabel
-    } = this.props;
-
-    if (!dotsLength || dotsLength < 2) {
-      return false;
-    }
-
-    const style = [_Pagination.default.sliderPagination, {
-      flexDirection: vertical ? 'column' : this._needsRTLAdaptations() ? 'row-reverse' : 'row'
-    }, containerStyle || {}];
-    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
-      pointerEvents: "box-none",
-      style: style,
-      accessible: !!accessibilityLabel,
-      accessibilityLabel: accessibilityLabel
-    }, this.dots);
-  }
-
-}
-
-exports.default = Pagination;
-
-_defineProperty(Pagination, "defaultProps", {
-  inactiveDotOpacity: 0.5,
-  inactiveDotScale: 0.5,
-  tappableDots: false,
-  vertical: false,
-  animatedDuration: 250,
-  animatedFriction: 4,
-  animatedTension: 50,
-  delayPressInDot: 0
-});
-//# sourceMappingURL=Pagination.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js.map
deleted file mode 100644
index 70cfe0e..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Pagination.tsx"],"names":["IS_IOS","Platform","OS","IS_RTL","I18nManager","isRTL","Pagination","PureComponent","constructor","props","dotColor","inactiveDotColor","console","warn","dotElement","inactiveDotElement","tappableDots","carouselRef","undefined","_needsRTLAdaptations","vertical","_activeDotIndex","activeDotIndex","dotsLength","dots","activeOpacity","dotContainerStyle","dotStyle","inactiveDotOpacity","inactiveDotScale","inactiveDotStyle","renderDots","animatedDuration","animatedFriction","animatedTension","delayPressInDot","DefaultDot","Array","keys","map","i","isActive","React","cloneElement","key","active","index","render","containerStyle","accessibilityLabel","style","styles","sliderPagination","flexDirection"],"mappings":"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","sourcesContent":["import React, { PureComponent, ReactElement } from 'react';\nimport {\n    I18nManager,\n    Platform,\n    View,\n    StyleProp,\n    ViewStyle\n} from 'react-native';\nimport PaginationDot from './PaginationDot';\nimport styles from './Pagination.style';\nimport type Carousel from 'src/carousel/Carousel';\n\nconst IS_IOS = Platform.OS === 'ios';\nconst IS_RTL = I18nManager.isRTL;\n\ntype PaginationProps<TData> = {\n  activeDotIndex: number;\n  dotsLength: number;\n  activeOpacity?: number;\n  carouselRef?: Carousel<TData> | null;\n  containerStyle?: StyleProp<ViewStyle>;\n  dotColor?: string;\n  dotContainerStyle?: StyleProp<ViewStyle>;\n  dotElement?: ReactElement;\n  dotStyle?: StyleProp<ViewStyle>;\n  inactiveDotColor?: string;\n  inactiveDotElement?: ReactElement;\n  inactiveDotOpacity: number;\n  inactiveDotScale: number;\n  inactiveDotStyle?: StyleProp<ViewStyle>;\n  renderDots?: (\n    activeIndex: number,\n    length: number,\n    context: Pagination<TData>\n  ) => ReactElement;\n  tappableDots: boolean;\n  vertical: boolean;\n  accessibilityLabel?: string;\n  animatedDuration: number;\n  animatedFriction: number;\n  animatedTension: number;\n  delayPressInDot: number;\n};\n\nexport default class Pagination<TData> extends PureComponent<PaginationProps<TData>> {\n  static defaultProps = {\n      inactiveDotOpacity: 0.5,\n      inactiveDotScale: 0.5,\n      tappableDots: false,\n      vertical: false,\n      animatedDuration: 250,\n      animatedFriction: 4,\n      animatedTension: 50,\n      delayPressInDot: 0\n  };\n\n  constructor (props: PaginationProps<TData>) {\n      super(props);\n\n      // Warnings\n      if (\n          (props.dotColor && !props.inactiveDotColor) ||\n      (!props.dotColor && props.inactiveDotColor)\n      ) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You need to specify both `dotColor` and `inactiveDotColor`'\n          );\n      }\n      if (\n          (props.dotElement && !props.inactiveDotElement) ||\n      (!props.dotElement && props.inactiveDotElement)\n      ) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You need to specify both `dotElement` and `inactiveDotElement`'\n          );\n      }\n      if (props.tappableDots && props.carouselRef === undefined) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You must specify prop `carouselRef` when setting `tappableDots` to `true`'\n          );\n      }\n  }\n\n  _needsRTLAdaptations () {\n      const { vertical } = this.props;\n      return IS_RTL && !IS_IOS && !vertical;\n  }\n\n  get _activeDotIndex () {\n      const { activeDotIndex, dotsLength } = this.props;\n      return this._needsRTLAdaptations() ?\n          dotsLength - activeDotIndex - 1 :\n          activeDotIndex;\n  }\n\n  get dots () {\n      const {\n          activeOpacity,\n          carouselRef,\n          dotsLength,\n          dotColor,\n          dotContainerStyle,\n          dotElement,\n          dotStyle,\n          inactiveDotColor,\n          inactiveDotElement,\n          inactiveDotOpacity,\n          inactiveDotScale,\n          inactiveDotStyle,\n          renderDots,\n          tappableDots,\n          animatedDuration,\n          animatedFriction,\n          animatedTension,\n          delayPressInDot\n      } = this.props;\n\n      if (renderDots) {\n          return renderDots(this._activeDotIndex, dotsLength, this);\n      }\n\n      const DefaultDot = (\n          <PaginationDot\n            carouselRef={carouselRef}\n            tappable={tappableDots && typeof carouselRef !== 'undefined'}\n            activeOpacity={activeOpacity}\n            color={dotColor}\n            containerStyle={dotContainerStyle}\n            style={dotStyle}\n            inactiveColor={inactiveDotColor}\n            inactiveOpacity={inactiveDotOpacity}\n            inactiveScale={inactiveDotScale}\n            inactiveStyle={inactiveDotStyle}\n            animatedDuration={animatedDuration}\n            animatedFriction={animatedFriction}\n            animatedTension={animatedTension}\n            delayPressInDot={delayPressInDot}\n          />\n      );\n\n      const dots = [...Array(dotsLength).keys()].map((i) => {\n          const isActive = i === this._activeDotIndex;\n          return React.cloneElement(\n              (isActive ? dotElement : inactiveDotElement) || DefaultDot,\n              {\n                  key: `pagination-dot-${i}`,\n                  active: isActive,\n                  index: i\n              }\n          );\n      });\n\n      return dots;\n  }\n\n  render () {\n      const {\n          dotsLength,\n          containerStyle,\n          vertical,\n          accessibilityLabel\n      } = this.props;\n\n      if (!dotsLength || dotsLength < 2) {\n          return false;\n      }\n\n      const style = [\n          styles.sliderPagination,\n          {\n              flexDirection: vertical ?\n                  ('column' as const) :\n                  this._needsRTLAdaptations() ?\n                      ('row-reverse' as const) :\n                      ('row' as const)\n          },\n          containerStyle || {}\n      ];\n\n      return (\n          <View\n            pointerEvents='box-none'\n            style={style}\n            accessible={!!accessibilityLabel}\n            accessibilityLabel={accessibilityLabel}\n          >\n              {this.dots}\n          </View>\n      );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js
deleted file mode 100644
index 8d3ac9c..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js
+++ /dev/null
@@ -1,34 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = void 0;
-
-var _reactNative = require("react-native");
-
-const DEFAULT_DOT_SIZE = 7;
-const DEFAULT_DOT_COLOR = 'rgba(0, 0, 0, 0.75)';
-
-var _default = _reactNative.StyleSheet.create({
-  sliderPagination: {
-    alignItems: 'center',
-    justifyContent: 'center',
-    paddingHorizontal: 20,
-    paddingVertical: 30
-  },
-  sliderPaginationDotContainer: {
-    alignItems: 'center',
-    justifyContent: 'center',
-    marginHorizontal: 8
-  },
-  sliderPaginationDot: {
-    width: DEFAULT_DOT_SIZE,
-    height: DEFAULT_DOT_SIZE,
-    borderRadius: DEFAULT_DOT_SIZE / 2,
-    backgroundColor: DEFAULT_DOT_COLOR
-  }
-});
-
-exports.default = _default;
-//# sourceMappingURL=Pagination.style.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js.map
deleted file mode 100644
index d7473db..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/Pagination.style.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Pagination.style.ts"],"names":["DEFAULT_DOT_SIZE","DEFAULT_DOT_COLOR","StyleSheet","create","sliderPagination","alignItems","justifyContent","paddingHorizontal","paddingVertical","sliderPaginationDotContainer","marginHorizontal","sliderPaginationDot","width","height","borderRadius","backgroundColor"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,gBAAgB,GAAG,CAAzB;AACA,MAAMC,iBAAiB,GAAG,qBAA1B;;eAEeC,wBAAWC,MAAX,CAAkB;AAC7BC,EAAAA,gBAAgB,EAAE;AACdC,IAAAA,UAAU,EAAE,QADE;AAEdC,IAAAA,cAAc,EAAE,QAFF;AAGdC,IAAAA,iBAAiB,EAAE,EAHL;AAIdC,IAAAA,eAAe,EAAE;AAJH,GADW;AAO7BC,EAAAA,4BAA4B,EAAE;AAC1BJ,IAAAA,UAAU,EAAE,QADc;AAE1BC,IAAAA,cAAc,EAAE,QAFU;AAG1BI,IAAAA,gBAAgB,EAAE;AAHQ,GAPD;AAY7BC,EAAAA,mBAAmB,EAAE;AACjBC,IAAAA,KAAK,EAAEZ,gBADU;AAEjBa,IAAAA,MAAM,EAAEb,gBAFS;AAGjBc,IAAAA,YAAY,EAAEd,gBAAgB,GAAG,CAHhB;AAIjBe,IAAAA,eAAe,EAAEd;AAJA;AAZQ,CAAlB,C","sourcesContent":["import { StyleSheet } from 'react-native';\n\nconst DEFAULT_DOT_SIZE = 7;\nconst DEFAULT_DOT_COLOR = 'rgba(0, 0, 0, 0.75)';\n\nexport default StyleSheet.create({\n    sliderPagination: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingHorizontal: 20,\n        paddingVertical: 30\n    },\n    sliderPaginationDotContainer: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        marginHorizontal: 8\n    },\n    sliderPaginationDot: {\n        width: DEFAULT_DOT_SIZE,\n        height: DEFAULT_DOT_SIZE,\n        borderRadius: DEFAULT_DOT_SIZE / 2,\n        backgroundColor: DEFAULT_DOT_COLOR\n    }\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js
deleted file mode 100644
index 26e5a6f..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js
+++ /dev/null
@@ -1,150 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = void 0;
-
-var _react = _interopRequireWildcard(require("react"));
-
-var _reactNative = require("react-native");
-
-var _Pagination = _interopRequireDefault(require("./Pagination.style"));
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
-
-class PaginationDot extends _react.PureComponent {
-  constructor(props) {
-    super(props);
-    this.state = {
-      animColor: new _reactNative.Animated.Value(0),
-      animOpacity: new _reactNative.Animated.Value(0),
-      animTransform: new _reactNative.Animated.Value(0)
-    };
-  }
-
-  componentDidMount() {
-    if (this.props.active) {
-      this._animate(1);
-    }
-  }
-
-  componentDidUpdate(prevProps) {
-    if (prevProps.active !== this.props.active) {
-      this._animate(this.props.active ? 1 : 0);
-    }
-  }
-
-  _animate(toValue = 0) {
-    const {
-      animColor,
-      animOpacity,
-      animTransform
-    } = this.state;
-    const {
-      animatedDuration,
-      animatedFriction,
-      animatedTension
-    } = this.props;
-    const commonProperties = {
-      toValue,
-      isInteraction: false,
-      useNativeDriver: !this._shouldAnimateColor
-    };
-    const animations = [_reactNative.Animated.timing(animOpacity, {
-      easing: _reactNative.Easing.linear,
-      duration: animatedDuration,
-      ...commonProperties
-    }), _reactNative.Animated.spring(animTransform, {
-      friction: animatedFriction,
-      tension: animatedTension,
-      ...commonProperties
-    })];
-
-    if (this._shouldAnimateColor) {
-      animations.push(_reactNative.Animated.timing(animColor, {
-        easing: _reactNative.Easing.linear,
-        ...commonProperties
-      }));
-    }
-
-    _reactNative.Animated.parallel(animations).start();
-  }
-
-  get _shouldAnimateColor() {
-    const {
-      color,
-      inactiveColor
-    } = this.props;
-    return color && inactiveColor;
-  }
-
-  render() {
-    const {
-      animColor,
-      animOpacity,
-      animTransform
-    } = this.state;
-    const {
-      active,
-      activeOpacity,
-      carouselRef,
-      color,
-      containerStyle,
-      inactiveColor,
-      inactiveStyle,
-      inactiveOpacity,
-      inactiveScale,
-      index,
-      style,
-      tappable,
-      delayPressInDot
-    } = this.props;
-    const animatedStyle = {
-      opacity: animOpacity.interpolate({
-        inputRange: [0, 1],
-        outputRange: [inactiveOpacity, 1]
-      }),
-      transform: [{
-        scale: animTransform.interpolate({
-          inputRange: [0, 1],
-          outputRange: [inactiveScale, 1]
-        })
-      }]
-    };
-    const animatedColor = this._shouldAnimateColor && inactiveColor && color ? {
-      backgroundColor: animColor.interpolate({
-        inputRange: [0, 1],
-        outputRange: [inactiveColor, color]
-      })
-    } : {};
-    const dotContainerStyle = [_Pagination.default.sliderPaginationDotContainer, containerStyle || {}];
-    const dotStyle = [_Pagination.default.sliderPaginationDot, style || {}, !active && inactiveStyle || {}, animatedStyle, animatedColor];
-    const onPress = tappable && (!!index || index === 0) ? () => {
-      try {
-        const currentRef = carouselRef && 'current' in carouselRef ? carouselRef.current : carouselRef; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-
-        currentRef._snapToItem(currentRef._getPositionIndex(index));
-      } catch (error) {
-        console.warn('react-native-snap-carousel | Pagination: ' + '`carouselRef` has to be a Carousel ref.\n' + error);
-      }
-    } : undefined;
-    return /*#__PURE__*/_react.default.createElement(_reactNative.TouchableOpacity, {
-      accessible: false,
-      style: dotContainerStyle,
-      activeOpacity: tappable ? activeOpacity : 1,
-      onPress: onPress,
-      delayPressIn: delayPressInDot
-    }, /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, {
-      style: dotStyle
-    }));
-  }
-
-}
-
-exports.default = PaginationDot;
-//# sourceMappingURL=PaginationDot.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js.map
deleted file mode 100644
index e40f975..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/pagination/PaginationDot.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["PaginationDot.tsx"],"names":["PaginationDot","PureComponent","constructor","props","state","animColor","Animated","Value","animOpacity","animTransform","componentDidMount","active","_animate","componentDidUpdate","prevProps","toValue","animatedDuration","animatedFriction","animatedTension","commonProperties","isInteraction","useNativeDriver","_shouldAnimateColor","animations","timing","easing","Easing","linear","duration","spring","friction","tension","push","parallel","start","color","inactiveColor","render","activeOpacity","carouselRef","containerStyle","inactiveStyle","inactiveOpacity","inactiveScale","index","style","tappable","delayPressInDot","animatedStyle","opacity","interpolate","inputRange","outputRange","transform","scale","animatedColor","backgroundColor","dotContainerStyle","styles","sliderPaginationDotContainer","dotStyle","sliderPaginationDot","onPress","currentRef","current","_snapToItem","_getPositionIndex","error","console","warn","undefined"],"mappings":"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","sourcesContent":["import React, { PureComponent, RefObject } from 'react';\nimport {\n    Animated,\n    Easing,\n    TouchableOpacity,\n    StyleProp,\n    ViewStyle\n} from 'react-native';\nimport styles from './Pagination.style';\nimport type Carousel from 'src/carousel/Carousel';\n\ntype PaginationDotProps<TData> = {\n  inactiveOpacity: number;\n  inactiveScale: number;\n  active?: boolean;\n  activeOpacity?: number;\n  animatedDuration?: number;\n  animatedFriction?: number;\n  animatedTension?: number;\n  carouselRef?: Carousel<TData> | RefObject<Carousel<TData>> | null;\n  color?: string;\n  containerStyle?: StyleProp<ViewStyle>;\n  delayPressInDot?: number;\n  inactiveColor?: string;\n  inactiveStyle?: StyleProp<ViewStyle>;\n  index?: number;\n  style?: StyleProp<ViewStyle>;\n  tappable?: boolean;\n};\n\ntype PaginationDotState = {\n  animColor: Animated.Value;\n  animOpacity: Animated.Value;\n  animTransform: Animated.Value;\n};\n\nexport default class PaginationDot<TData> extends PureComponent<\n  PaginationDotProps<TData>,\n  PaginationDotState\n> {\n    constructor (props: PaginationDotProps<TData>) {\n        super(props);\n        this.state = {\n            animColor: new Animated.Value(0),\n            animOpacity: new Animated.Value(0),\n            animTransform: new Animated.Value(0)\n        };\n    }\n\n    componentDidMount () {\n        if (this.props.active) {\n            this._animate(1);\n        }\n    }\n\n    componentDidUpdate (prevProps: PaginationDotProps<TData>) {\n        if (prevProps.active !== this.props.active) {\n            this._animate(this.props.active ? 1 : 0);\n        }\n    }\n\n    _animate (toValue = 0) {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const { animatedDuration, animatedFriction, animatedTension } = this.props;\n\n        const commonProperties = {\n            toValue,\n            isInteraction: false,\n            useNativeDriver: !this._shouldAnimateColor\n        };\n\n        const animations = [\n            Animated.timing(animOpacity, {\n                easing: Easing.linear,\n                duration: animatedDuration,\n                ...commonProperties\n            }),\n            Animated.spring(animTransform, {\n                friction: animatedFriction,\n                tension: animatedTension,\n                ...commonProperties\n            })\n        ];\n\n        if (this._shouldAnimateColor) {\n            animations.push(\n                Animated.timing(animColor, {\n                    easing: Easing.linear,\n                    ...commonProperties\n                })\n            );\n        }\n\n        Animated.parallel(animations).start();\n    }\n\n    get _shouldAnimateColor () {\n        const { color, inactiveColor } = this.props;\n        return color && inactiveColor;\n    }\n\n    render () {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const {\n            active,\n            activeOpacity,\n            carouselRef,\n            color,\n            containerStyle,\n            inactiveColor,\n            inactiveStyle,\n            inactiveOpacity,\n            inactiveScale,\n            index,\n            style,\n            tappable,\n            delayPressInDot\n        } = this.props;\n\n        const animatedStyle = {\n            opacity: animOpacity.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveOpacity, 1]\n            }),\n            transform: [\n                {\n                    scale: animTransform.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: [inactiveScale, 1]\n                    })\n                }\n            ]\n        };\n        const animatedColor =\n      this._shouldAnimateColor && inactiveColor && color ?\n          {\n              backgroundColor: animColor.interpolate({\n                  inputRange: [0, 1],\n                  outputRange: [inactiveColor, color]\n              })\n          } :\n          {};\n\n        const dotContainerStyle = [\n            styles.sliderPaginationDotContainer,\n            containerStyle || {}\n        ];\n\n        const dotStyle = [\n            styles.sliderPaginationDot,\n            style || {},\n            (!active && inactiveStyle) || {},\n            animatedStyle,\n            animatedColor\n        ];\n\n        const onPress =\n      tappable && (!!index || index === 0) ?\n          () => {\n              try {\n                  const currentRef =\n                carouselRef && 'current' in carouselRef ?\n                    carouselRef.current :\n                    carouselRef;\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              currentRef!._snapToItem(currentRef!._getPositionIndex(index));\n              } catch (error) {\n                  console.warn(\n                      'react-native-snap-carousel | Pagination: ' +\n                  '`carouselRef` has to be a Carousel ref.\\n' +\n                  error\n                  );\n              }\n          } :\n          undefined;\n\n        return (\n            <TouchableOpacity\n              accessible={false}\n              style={dotContainerStyle}\n              activeOpacity={tappable ? activeOpacity : 1}\n              onPress={onPress}\n              delayPressIn={delayPressInDot}\n            >\n                <Animated.View style={dotStyle} />\n            </TouchableOpacity>\n        );\n    }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js b/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js
deleted file mode 100644
index 0c42e3c..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js
+++ /dev/null
@@ -1,232 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = exports.ParallaxImageStatus = void 0;
-
-var _react = _interopRequireWildcard(require("react"));
-
-var _reactNative = require("react-native");
-
-var _ParallaxImage = _interopRequireDefault(require("./ParallaxImage.style"));
-
-function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
-
-function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
-
-function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
-
-function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
-
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-let ParallaxImageStatus;
-exports.ParallaxImageStatus = ParallaxImageStatus;
-
-(function (ParallaxImageStatus) {
-  ParallaxImageStatus[ParallaxImageStatus["LOADING"] = 1] = "LOADING";
-  ParallaxImageStatus[ParallaxImageStatus["LOADED"] = 2] = "LOADED";
-  ParallaxImageStatus[ParallaxImageStatus["TRANSITION_FINISHED"] = 3] = "TRANSITION_FINISHED";
-  ParallaxImageStatus[ParallaxImageStatus["ERROR"] = 4] = "ERROR";
-})(ParallaxImageStatus || (exports.ParallaxImageStatus = ParallaxImageStatus = {}));
-
-class ParallaxImage extends _react.Component {
-  constructor(props) {
-    super(props);
-
-    _defineProperty(this, "_container", void 0);
-
-    _defineProperty(this, "_mounted", void 0);
-
-    this.state = {
-      offset: 0,
-      width: 0,
-      height: 0,
-      status: ParallaxImageStatus.LOADING,
-      animOpacity: new _reactNative.Animated.Value(0)
-    };
-    this._onLoad = this._onLoad.bind(this);
-    this._onError = this._onError.bind(this);
-    this._measureLayout = this._measureLayout.bind(this);
-  }
-
-  setNativeProps(nativeProps) {
-    var _this$_container;
-
-    (_this$_container = this._container) === null || _this$_container === void 0 ? void 0 : _this$_container.setNativeProps(nativeProps);
-  }
-
-  componentDidMount() {
-    this._mounted = true;
-    setTimeout(() => {
-      this._measureLayout();
-    }, 0);
-  }
-
-  componentWillUnmount() {
-    this._mounted = false;
-  }
-
-  _measureLayout() {
-    if (this._container) {
-      const {
-        dimensions,
-        carouselRef
-      } = this.props;
-      const nodeHandle = (0, _reactNative.findNodeHandle)(carouselRef);
-
-      if (carouselRef && nodeHandle) {
-        this._container.measureLayout(nodeHandle, (x, y, width, height) => {
-          const offset = this.props.vertical ? y - (this.props.sliderHeight - this.props.itemHeight) / 2 : x - (this.props.sliderWidth - this.props.itemWidth) / 2;
-          this.setState({
-            offset: offset,
-            width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),
-            height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)
-          });
-        }, // eslint-disable-next-line @typescript-eslint/no-empty-function
-        () => {});
-      }
-    }
-  }
-
-  _onLoad(event) {
-    const {
-      animOpacity
-    } = this.state;
-    const {
-      fadeDuration,
-      onLoad
-    } = this.props;
-
-    if (!this._mounted) {
-      return;
-    }
-
-    this.setState({
-      status: ParallaxImageStatus.LOADED
-    });
-
-    if (onLoad) {
-      onLoad(event);
-    }
-
-    _reactNative.Animated.timing(animOpacity, {
-      toValue: 1,
-      duration: fadeDuration,
-      easing: _reactNative.Easing.out(_reactNative.Easing.quad),
-      isInteraction: false,
-      useNativeDriver: true
-    }).start(() => {
-      this.setState({
-        status: ParallaxImageStatus.TRANSITION_FINISHED
-      });
-    });
-  } // If arg is missing from method signature, it just won't be called
-
-
-  _onError(event) {
-    const {
-      onError
-    } = this.props;
-    this.setState({
-      status: ParallaxImageStatus.ERROR
-    });
-
-    if (onError) {
-      onError(event);
-    }
-  }
-
-  get image() {
-    const {
-      status,
-      animOpacity,
-      offset,
-      width,
-      height
-    } = this.state;
-    const {
-      scrollPosition,
-      // False positive :( other doesn't have the dimension key
-      // eslint-disable-next-line @typescript-eslint/no-unused-vars
-      dimensions,
-      parallaxFactor,
-      style,
-      AnimatedImageComponent,
-      ...other
-    } = this.props;
-    const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;
-    const requiredStyles = {
-      position: 'relative'
-    };
-    const dynamicStyles = {
-      width: this.props.vertical ? width : width + parallaxPadding * 2,
-      height: this.props.vertical ? height + parallaxPadding * 2 : height,
-      opacity: animOpacity,
-      transform: scrollPosition ? [{
-        translateX: !this.props.vertical ? scrollPosition.interpolate({
-          inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],
-          outputRange: [-parallaxPadding, parallaxPadding],
-          extrapolate: 'clamp'
-        }) : 0
-      }, {
-        translateY: this.props.vertical ? scrollPosition.interpolate({
-          inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],
-          outputRange: [-parallaxPadding, parallaxPadding],
-          extrapolate: 'clamp'
-        }) : 0
-      }] : []
-    };
-    return /*#__PURE__*/_react.default.createElement(AnimatedImageComponent, _extends({}, other, {
-      style: [_ParallaxImage.default.image, style, requiredStyles, dynamicStyles],
-      onLoad: this._onLoad,
-      onError: status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined // prevent infinite-loop bug
-
-    }));
-  }
-
-  get spinner() {
-    const {
-      status
-    } = this.state;
-    const {
-      showSpinner,
-      spinnerColor
-    } = this.props;
-    return status === ParallaxImageStatus.LOADING && showSpinner ? /*#__PURE__*/_react.default.createElement(_reactNative.View, {
-      style: _ParallaxImage.default.loaderContainer
-    }, /*#__PURE__*/_react.default.createElement(_reactNative.ActivityIndicator, {
-      size: "small",
-      color: spinnerColor,
-      animating: true
-    })) : false;
-  }
-
-  render() {
-    const {
-      containerStyle
-    } = this.props;
-    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
-      ref: c => {
-        this._container = c;
-      },
-      pointerEvents: "none",
-      style: [containerStyle, _ParallaxImage.default.container],
-      onLayout: this._measureLayout
-    }, this.image, this.spinner);
-  }
-
-}
-
-exports.default = ParallaxImage;
-
-_defineProperty(ParallaxImage, "defaultProps", {
-  containerStyle: {},
-  fadeDuration: 500,
-  parallaxFactor: 0.3,
-  showSpinner: true,
-  spinnerColor: 'rgba(0, 0, 0, 0.4)',
-  AnimatedImageComponent: _reactNative.Animated.Image
-});
-//# sourceMappingURL=ParallaxImage.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js.map
deleted file mode 100644
index fa8f5a1..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["ParallaxImage.tsx"],"names":["ParallaxImageStatus","ParallaxImage","Component","constructor","props","state","offset","width","height","status","LOADING","animOpacity","Animated","Value","_onLoad","bind","_onError","_measureLayout","setNativeProps","nativeProps","_container","componentDidMount","_mounted","setTimeout","componentWillUnmount","dimensions","carouselRef","nodeHandle","measureLayout","x","y","vertical","sliderHeight","itemHeight","sliderWidth","itemWidth","setState","Math","ceil","event","fadeDuration","onLoad","LOADED","timing","toValue","duration","easing","Easing","out","quad","isInteraction","useNativeDriver","start","TRANSITION_FINISHED","onError","ERROR","image","scrollPosition","parallaxFactor","style","AnimatedImageComponent","other","parallaxPadding","requiredStyles","position","dynamicStyles","opacity","transform","translateX","interpolate","inputRange","outputRange","extrapolate","translateY","styles","undefined","spinner","showSpinner","spinnerColor","loaderContainer","render","containerStyle","c","container","Image"],"mappings":"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","sourcesContent":["// Parallax effect inspired by https://github.com/oblador/react-native-parallax/\n\nimport React, { Component } from 'react';\nimport {\n    View,\n    Animated,\n    Easing,\n    ActivityIndicator,\n    findNodeHandle,\n    ImageProps,\n    StyleProp,\n    ViewStyle,\n    NativeSyntheticEvent,\n    ImageLoadEventData,\n    ImageErrorEventData\n} from 'react-native';\nimport styles from './ParallaxImage.style';\n\ntype VerticalProps = {\n    vertical: true;\n    sliderHeight: number; // passed from <Carousel />\n    itemHeight: number; // passed from <Carousel />\n}\ntype HorizontalProps = {\n    vertical: false;\n    sliderWidth: number; // passed from <Carousel />\n    itemWidth: number; // passed from <Carousel />\n}\n\ntype ParallaxImageProps = {\n  carouselRef: Parameters<typeof findNodeHandle>[0]; // passed from <Carousel />\n  scrollPosition: Animated.Value | undefined; // passed from <Carousel />\n  containerStyle: StyleProp<ViewStyle>;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n  fadeDuration: number;\n  parallaxFactor: number;\n  showSpinner: boolean;\n  spinnerColor: string;\n  AnimatedImageComponent: typeof Animated.Image;\n} & ImageProps & (VerticalProps | HorizontalProps);\n\nexport enum ParallaxImageStatus {\n    'LOADING' = 1,\n    'LOADED' = 2,\n    'TRANSITION_FINISHED' = 3,\n    'ERROR' = 4\n}\n\ntype ParallaxImageState = {\n  offset: number;\n  width: number;\n  height: number;\n  status: ParallaxImageStatus;\n  animOpacity: Animated.Value;\n};\n\nexport default class ParallaxImage extends Component<\n  ParallaxImageProps,\n  ParallaxImageState\n> {\n  static defaultProps = {\n      containerStyle: {},\n      fadeDuration: 500,\n      parallaxFactor: 0.3,\n      showSpinner: true,\n      spinnerColor: 'rgba(0, 0, 0, 0.4)',\n      AnimatedImageComponent: Animated.Image\n  };\n\n  _container?: View | null;\n  _mounted?: boolean;\n\n  constructor (props: ParallaxImageProps) {\n      super(props);\n      this.state = {\n          offset: 0,\n          width: 0,\n          height: 0,\n          status: ParallaxImageStatus.LOADING,\n          animOpacity: new Animated.Value(0)\n      };\n      this._onLoad = this._onLoad.bind(this);\n      this._onError = this._onError.bind(this);\n      this._measureLayout = this._measureLayout.bind(this);\n  }\n\n  setNativeProps (nativeProps: { [key: string]: unknown }) {\n    this._container?.setNativeProps(nativeProps);\n  }\n\n  componentDidMount () {\n      this._mounted = true;\n\n      setTimeout(() => {\n          this._measureLayout();\n      }, 0);\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n  }\n\n  _measureLayout () {\n      if (this._container) {\n          const {\n              dimensions,\n              carouselRef\n          } = this.props;\n\n          const nodeHandle = findNodeHandle(carouselRef);\n\n          if (carouselRef && nodeHandle) {\n              this._container.measureLayout(\n                  nodeHandle,\n                  (x, y, width, height) => {\n                      const offset = this.props.vertical ?\n                          y - (this.props.sliderHeight - this.props.itemHeight) / 2 :\n                          x - (this.props.sliderWidth - this.props.itemWidth) / 2;\n\n                      this.setState({\n                          offset: offset,\n                          width:\n                dimensions && dimensions.width ?\n                    dimensions.width :\n                    Math.ceil(width),\n                          height:\n                dimensions && dimensions.height ?\n                    dimensions.height :\n                    Math.ceil(height)\n                      });\n                  },\n                  // eslint-disable-next-line @typescript-eslint/no-empty-function\n                  () => {}\n              );\n          }\n      }\n  }\n\n  _onLoad (event: NativeSyntheticEvent<ImageLoadEventData>) {\n      const { animOpacity } = this.state;\n      const { fadeDuration, onLoad } = this.props;\n\n      if (!this._mounted) {\n          return;\n      }\n\n      this.setState({ status: ParallaxImageStatus.LOADED });\n\n      if (onLoad) {\n          onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n          toValue: 1,\n          duration: fadeDuration,\n          easing: Easing.out(Easing.quad),\n          isInteraction: false,\n          useNativeDriver: true\n      }).start(() => {\n          this.setState({ status: ParallaxImageStatus.TRANSITION_FINISHED });\n      });\n  }\n\n  // If arg is missing from method signature, it just won't be called\n  _onError (event: NativeSyntheticEvent<ImageErrorEventData>) {\n      const { onError } = this.props;\n\n      this.setState({ status: ParallaxImageStatus.ERROR });\n\n      if (onError) {\n          onError(event);\n      }\n  }\n\n  get image () {\n      const { status, animOpacity, offset, width, height } = this.state;\n      const {\n          scrollPosition,\n          // False positive :( other doesn't have the dimension key\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          dimensions,\n          parallaxFactor,\n          style,\n          AnimatedImageComponent,\n          ...other\n      } = this.props;\n      const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      const requiredStyles = { position: 'relative' as const };\n      const dynamicStyles = {\n          width: this.props.vertical ? width : width + parallaxPadding * 2,\n          height: this.props.vertical ? height + parallaxPadding * 2 : height,\n          opacity: animOpacity,\n          transform: scrollPosition ?\n              [\n                  {\n                      translateX: !this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  },\n                  {\n                      translateY: this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  }\n              ] :\n              []\n      };\n\n      return (\n          <AnimatedImageComponent\n            {...other}\n            style={[styles.image, style, requiredStyles, dynamicStyles]}\n            onLoad={this._onLoad}\n            onError={status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined} // prevent infinite-loop bug\n          />\n      );\n  }\n\n  get spinner () {\n      const { status } = this.state;\n      const { showSpinner, spinnerColor } = this.props;\n\n      return status === ParallaxImageStatus.LOADING && showSpinner ? (\n          <View style={styles.loaderContainer}>\n              <ActivityIndicator\n                size='small'\n                color={spinnerColor}\n                animating={true}\n              />\n          </View>\n      ) : (\n          false\n      );\n  }\n\n  render () {\n      const { containerStyle } = this.props;\n\n      return (\n          <View\n            ref={(c) => {\n                this._container = c;\n            }}\n            pointerEvents='none'\n            style={[containerStyle, styles.container]}\n            onLayout={this._measureLayout}\n          >\n              {this.image}\n              {this.spinner}\n          </View>\n      );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js b/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js
deleted file mode 100644
index bcc1fe4..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js
+++ /dev/null
@@ -1,29 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.default = void 0;
-
-var _reactNative = require("react-native");
-
-var _default = _reactNative.StyleSheet.create({
-  container: {
-    overflow: 'hidden',
-    alignItems: 'center',
-    justifyContent: 'center'
-  },
-  image: {
-    position: 'relative',
-    resizeMode: 'cover',
-    width: undefined,
-    height: undefined
-  },
-  loaderContainer: { ..._reactNative.StyleSheet.absoluteFillObject,
-    alignItems: 'center',
-    justifyContent: 'center'
-  }
-});
-
-exports.default = _default;
-//# sourceMappingURL=ParallaxImage.style.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js.map
deleted file mode 100644
index a59102d..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/parallaximage/ParallaxImage.style.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["ParallaxImage.style.ts"],"names":["StyleSheet","create","container","overflow","alignItems","justifyContent","image","position","resizeMode","width","undefined","height","loaderContainer","absoluteFillObject"],"mappings":";;;;;;;AAAA;;eAEeA,wBAAWC,MAAX,CAAkB;AAC7BC,EAAAA,SAAS,EAAE;AACPC,IAAAA,QAAQ,EAAE,QADH;AAEPC,IAAAA,UAAU,EAAE,QAFL;AAGPC,IAAAA,cAAc,EAAE;AAHT,GADkB;AAM7BC,EAAAA,KAAK,EAAE;AACHC,IAAAA,QAAQ,EAAE,UADP;AAEHC,IAAAA,UAAU,EAAE,OAFT;AAGHC,IAAAA,KAAK,EAAEC,SAHJ;AAIHC,IAAAA,MAAM,EAAED;AAJL,GANsB;AAY7BE,EAAAA,eAAe,EAAE,EACb,GAAGZ,wBAAWa,kBADD;AAEbT,IAAAA,UAAU,EAAE,QAFC;AAGbC,IAAAA,cAAc,EAAE;AAHH;AAZY,CAAlB,C","sourcesContent":["import { StyleSheet } from 'react-native';\n\nexport default StyleSheet.create({\n    container: {\n        overflow: 'hidden',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    image: {\n        position: 'relative',\n        resizeMode: 'cover',\n        width: undefined,\n        height: undefined\n    },\n    loaderContainer: {\n        ...StyleSheet.absoluteFillObject,\n        alignItems: 'center',\n        justifyContent: 'center'\n    }\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js b/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js
deleted file mode 100644
index b29101c..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js
+++ /dev/null
@@ -1,298 +0,0 @@
-"use strict";
-
-Object.defineProperty(exports, "__esModule", {
-  value: true
-});
-exports.getInputRangeFromIndexes = getInputRangeFromIndexes;
-exports.defaultScrollInterpolator = defaultScrollInterpolator;
-exports.defaultAnimatedStyles = defaultAnimatedStyles;
-exports.shiftAnimatedStyles = shiftAnimatedStyles;
-exports.stackScrollInterpolator = stackScrollInterpolator;
-exports.stackAnimatedStyles = stackAnimatedStyles;
-exports.tinderScrollInterpolator = tinderScrollInterpolator;
-exports.tinderAnimatedStyles = tinderAnimatedStyles;
-
-var _reactNative = require("react-native");
-
-const IS_ANDROID = _reactNative.Platform.OS === 'android'; // Get scroll interpolator's input range from an array of slide indexes
-// Indexes are relative to the current active slide (index 0)
-// For example, using [3, 2, 1, 0, -1] will return:
-// [
-//     (index - 3) * sizeRef, // active + 3
-//     (index - 2) * sizeRef, // active + 2
-//     (index - 1) * sizeRef, // active + 1
-//     index * sizeRef, // active
-//     (index + 1) * sizeRef // active - 1
-// ]
-
-function getInputRangeFromIndexes(range, index, carouselProps) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const inputRange = [];
-
-  for (let i = 0; i < range.length; i++) {
-    inputRange.push((index - range[i]) * sizeRef);
-  }
-
-  return inputRange;
-} // Default behavior
-// Scale and/or opacity effect
-// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'
-
-
-function defaultScrollInterpolator(index, carouselProps) {
-  const range = [1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = [0, 1, 0];
-  return {
-    inputRange,
-    outputRange
-  };
-}
-
-function defaultAnimatedStyles(_index, animatedValue, carouselProps) {
-  let animatedOpacity = {};
-  let animatedScale = {};
-
-  if (carouselProps.inactiveSlideOpacity < 1) {
-    animatedOpacity = {
-      opacity: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideOpacity, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideScale < 1) {
-    animatedScale = {
-      transform: [{
-        scale: animatedValue.interpolate({
-          inputRange: [0, 1],
-          outputRange: [carouselProps.inactiveSlideScale, 1]
-        })
-      }]
-    };
-  }
-
-  return { ...animatedOpacity,
-    ...animatedScale
-  };
-} // Shift animation
-// Same as the default one, but the active slide is also shifted up or down
-// Based on prop 'inactiveSlideShift'
-
-
-function shiftAnimatedStyles(_index, animatedValue, carouselProps) {
-  let animatedOpacity = {};
-  let animatedScale = {};
-  let animatedTranslate = {};
-
-  if (carouselProps.inactiveSlideOpacity < 1) {
-    animatedOpacity = {
-      opacity: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideOpacity, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideScale < 1) {
-    animatedScale = {
-      scale: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideScale, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideShift !== 0) {
-    const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';
-    animatedTranslate = {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideShift, 0]
-      })
-    };
-  }
-
-  return { ...animatedOpacity,
-    transform: [{ ...animatedScale
-    }, { ...animatedTranslate
-    }]
-  };
-} // Stack animation
-// Imitate a deck/stack of cards (see #195)
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-
-
-function stackScrollInterpolator(index, carouselProps) {
-  const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = range;
-  return {
-    inputRange,
-    outputRange
-  };
-}
-
-function stackAnimatedStyles(index, animatedValue, carouselProps, cardOffset) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
-  const card1Scale = 0.9;
-  const card2Scale = 0.8;
-  const newCardOffset = cardOffset !== null && cardOffset !== void 0 ? cardOffset : 18;
-
-  const getTranslateFromScale = (cardIndex, scale) => {
-    const centerFactor = 1 / scale * cardIndex;
-    const centeredPosition = -Math.round(sizeRef * centerFactor);
-    const edgeAlignment = Math.round((sizeRef - sizeRef * scale) / 2);
-    const offset = Math.round(newCardOffset * Math.abs(cardIndex) / scale);
-    return IS_ANDROID ? centeredPosition - edgeAlignment - offset : centeredPosition + edgeAlignment + offset;
-  };
-
-  const opacityOutputRange = carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];
-  return IS_ANDROID ? {
-    // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-    opacity: animatedValue.interpolate({
-      inputRange: [-3, -2, -1, 0],
-      outputRange: opacityOutputRange.reverse(),
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-2, -1, 0, 1],
-        outputRange: [card2Scale, card1Scale, 1, card1Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0, 1],
-        outputRange: [getTranslateFromScale(-3, card2Scale), getTranslateFromScale(-2, card2Scale), getTranslateFromScale(-1, card1Scale), 0, sizeRef * 0.5],
-        extrapolate: 'clamp'
-      })
-    }]
-  } : {
-    zIndex: carouselProps.data.length - index,
-    opacity: animatedValue.interpolate({
-      inputRange: [0, 1, 2, 3],
-      outputRange: opacityOutputRange,
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2],
-        outputRange: [card1Scale, 1, card1Scale, card2Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2, 3],
-        outputRange: [-sizeRef * 0.5, 0, getTranslateFromScale(1, card1Scale), getTranslateFromScale(2, card2Scale), getTranslateFromScale(3, card2Scale)],
-        extrapolate: 'clamp'
-      })
-    }]
-  };
-} // Tinder animation
-// Imitate the popular Tinder layout
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-
-
-function tinderScrollInterpolator(index, carouselProps) {
-  const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = range;
-  return {
-    inputRange,
-    outputRange
-  };
-}
-
-function tinderAnimatedStyles(index, animatedValue, carouselProps, cardOffset) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const mainTranslateProp = carouselProps.vertical ? 'translateY' : 'translateX';
-  const secondaryTranslateProp = carouselProps.vertical ? 'translateX' : 'translateY';
-  const card1Scale = 0.96;
-  const card2Scale = 0.92;
-  const card3Scale = 0.88;
-  const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;
-  const newCardOffset = cardOffset !== null && cardOffset !== void 0 ? cardOffset : 9;
-
-  const getMainTranslateFromScale = (cardIndex, scale) => {
-    const centerFactor = 1 / scale * cardIndex;
-    return -Math.round(sizeRef * centerFactor);
-  };
-
-  const getSecondaryTranslateFromScale = (cardIndex, scale) => {
-    return Math.round(newCardOffset * Math.abs(cardIndex) / scale);
-  };
-
-  return IS_ANDROID ? {
-    // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-    opacity: animatedValue.interpolate({
-      inputRange: [-3, -2, -1, 0, 1],
-      outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0],
-        outputRange: [card3Scale, card2Scale, card1Scale, 1],
-        extrapolate: 'clamp'
-      })
-    }, {
-      rotate: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: ['0deg', '22deg'],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [mainTranslateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0, 1],
-        outputRange: [getMainTranslateFromScale(-3, card3Scale), getMainTranslateFromScale(-2, card2Scale), getMainTranslateFromScale(-1, card1Scale), 0, sizeRef * 1.1],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [secondaryTranslateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0],
-        outputRange: [getSecondaryTranslateFromScale(-3, card3Scale), getSecondaryTranslateFromScale(-2, card2Scale), getSecondaryTranslateFromScale(-1, card1Scale), 0],
-        extrapolate: 'clamp'
-      })
-    }]
-  } : {
-    zIndex: carouselProps.data.length - index,
-    opacity: animatedValue.interpolate({
-      inputRange: [-1, 0, 1, 2, 3],
-      outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [0, 1, 2, 3],
-        outputRange: [1, card1Scale, card2Scale, card3Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      rotate: animatedValue.interpolate({
-        inputRange: [-1, 0],
-        outputRange: ['-22deg', '0deg'],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [mainTranslateProp]: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2, 3],
-        outputRange: [-sizeRef * 1.1, 0, getMainTranslateFromScale(1, card1Scale), getMainTranslateFromScale(2, card2Scale), getMainTranslateFromScale(3, card3Scale)],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [secondaryTranslateProp]: animatedValue.interpolate({
-        inputRange: [0, 1, 2, 3],
-        outputRange: [0, getSecondaryTranslateFromScale(1, card1Scale), getSecondaryTranslateFromScale(2, card2Scale), getSecondaryTranslateFromScale(3, card3Scale)],
-        extrapolate: 'clamp'
-      })
-    }]
-  };
-}
-//# sourceMappingURL=animations.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js.map b/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js.map
deleted file mode 100644
index 9c933f7..0000000
--- a/node_modules/react-native-snap-carousel/lib/commonjs/utils/animations.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["animations.ts"],"names":["IS_ANDROID","Platform","OS","getInputRangeFromIndexes","range","index","carouselProps","sizeRef","vertical","itemHeight","itemWidth","inputRange","i","length","push","defaultScrollInterpolator","outputRange","defaultAnimatedStyles","_index","animatedValue","animatedOpacity","animatedScale","inactiveSlideOpacity","opacity","interpolate","inactiveSlideScale","transform","scale","shiftAnimatedStyles","animatedTranslate","inactiveSlideShift","translateProp","stackScrollInterpolator","stackAnimatedStyles","cardOffset","card1Scale","card2Scale","newCardOffset","getTranslateFromScale","cardIndex","centerFactor","centeredPosition","Math","round","edgeAlignment","offset","abs","opacityOutputRange","reverse","extrapolate","zIndex","data","tinderScrollInterpolator","tinderAnimatedStyles","mainTranslateProp","secondaryTranslateProp","card3Scale","peekingCardsOpacity","getMainTranslateFromScale","getSecondaryTranslateFromScale","rotate"],"mappings":"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","sourcesContent":["import { Platform, Animated } from 'react-native';\nimport type { CarouselProps } from 'src/carousel/types';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// Get scroll interpolator's input range from an array of slide indexes\n// Indexes are relative to the current active slide (index 0)\n// For example, using [3, 2, 1, 0, -1] will return:\n// [\n//     (index - 3) * sizeRef, // active + 3\n//     (index - 2) * sizeRef, // active + 2\n//     (index - 1) * sizeRef, // active + 1\n//     index * sizeRef, // active\n//     (index + 1) * sizeRef // active - 1\n// ]\nexport function getInputRangeFromIndexes<TData> (\n    range: number[],\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const inputRange = [];\n\n    for (let i = 0; i < range.length; i++) {\n        inputRange.push((index - range[i]) * sizeRef);\n    }\n\n    return inputRange;\n}\n\n// Default behavior\n// Scale and/or opacity effect\n// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'\nexport function defaultScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = [1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = [0, 1, 0];\n\n    return { inputRange, outputRange };\n}\nexport function defaultAnimatedStyles<TData> (\n    _index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>\n) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: [carouselProps.inactiveSlideScale, 1]\n                    })\n                }\n            ]\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        ...animatedScale\n    };\n}\n\n// Shift animation\n// Same as the default one, but the active slide is also shifted up or down\n// Based on prop 'inactiveSlideShift'\nexport function shiftAnimatedStyles<TData> (\n    _index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>\n) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n    let animatedTranslate = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            scale: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideScale, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideShift !== 0) {\n        const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';\n        animatedTranslate = {\n            [translateProp]: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideShift, 0]\n            })\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        transform: [{ ...animatedScale }, { ...animatedTranslate }]\n    };\n}\n\n// Stack animation\n// Imitate a deck/stack of cards (see #195)\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function stackScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function stackAnimatedStyles<TData> (\n    index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>,\n    cardOffset?: number\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';\n\n    const card1Scale = 0.9;\n    const card2Scale = 0.8;\n\n    const newCardOffset = cardOffset ?? 18;\n\n    const getTranslateFromScale = (cardIndex: number, scale: number) => {\n        const centerFactor = (1 / scale) * cardIndex;\n        const centeredPosition = -Math.round(sizeRef * centerFactor);\n        const edgeAlignment = Math.round((sizeRef - sizeRef * scale) / 2);\n        const offset = Math.round((newCardOffset * Math.abs(cardIndex)) / scale);\n\n        return IS_ANDROID ?\n            centeredPosition - edgeAlignment - offset :\n            centeredPosition + edgeAlignment + offset;\n    };\n\n    const opacityOutputRange =\n    carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];\n\n    return IS_ANDROID ?\n        {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n            opacity: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0],\n                outputRange: opacityOutputRange.reverse(),\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-2, -1, 0, 1],\n                        outputRange: [card2Scale, card1Scale, 1, card1Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [translateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0, 1],\n                        outputRange: [\n                            getTranslateFromScale(-3, card2Scale),\n                            getTranslateFromScale(-2, card2Scale),\n                            getTranslateFromScale(-1, card1Scale),\n                            0,\n                            sizeRef * 0.5\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        } :\n        {\n            zIndex: carouselProps.data.length - index,\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1, 2, 3],\n                outputRange: opacityOutputRange,\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2],\n                        outputRange: [card1Scale, 1, card1Scale, card2Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [translateProp]: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2, 3],\n                        outputRange: [\n                            -sizeRef * 0.5,\n                            0,\n                            getTranslateFromScale(1, card1Scale),\n                            getTranslateFromScale(2, card2Scale),\n                            getTranslateFromScale(3, card2Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        };\n}\n\n// Tinder animation\n// Imitate the popular Tinder layout\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function tinderScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function tinderAnimatedStyles<TData> (\n    index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>,\n    cardOffset?: number\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const mainTranslateProp = carouselProps.vertical ?\n        'translateY' :\n        'translateX';\n    const secondaryTranslateProp = carouselProps.vertical ?\n        'translateX' :\n        'translateY';\n\n    const card1Scale = 0.96;\n    const card2Scale = 0.92;\n    const card3Scale = 0.88;\n\n    const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;\n\n    const newCardOffset = cardOffset ?? 9;\n\n    const getMainTranslateFromScale = (cardIndex: number, scale: number) => {\n        const centerFactor = (1 / scale) * cardIndex;\n        return -Math.round(sizeRef * centerFactor);\n    };\n\n    const getSecondaryTranslateFromScale = (cardIndex: number, scale: number) => {\n        return Math.round((newCardOffset * Math.abs(cardIndex)) / scale);\n    };\n\n    return IS_ANDROID ?\n        {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n            opacity: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0, 1],\n                outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0],\n                        outputRange: [card3Scale, card2Scale, card1Scale, 1],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    rotate: animatedValue.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: ['0deg', '22deg'],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [mainTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0, 1],\n                        outputRange: [\n                            getMainTranslateFromScale(-3, card3Scale),\n                            getMainTranslateFromScale(-2, card2Scale),\n                            getMainTranslateFromScale(-1, card1Scale),\n                            0,\n                            sizeRef * 1.1\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [secondaryTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0],\n                        outputRange: [\n                            getSecondaryTranslateFromScale(-3, card3Scale),\n                            getSecondaryTranslateFromScale(-2, card2Scale),\n                            getSecondaryTranslateFromScale(-1, card1Scale),\n                            0\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        } :\n        {\n            zIndex: carouselProps.data.length - index,\n            opacity: animatedValue.interpolate({\n                inputRange: [-1, 0, 1, 2, 3],\n                outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [0, 1, 2, 3],\n                        outputRange: [1, card1Scale, card2Scale, card3Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    rotate: animatedValue.interpolate({\n                        inputRange: [-1, 0],\n                        outputRange: ['-22deg', '0deg'],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [mainTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2, 3],\n                        outputRange: [\n                            -sizeRef * 1.1,\n                            0,\n                            getMainTranslateFromScale(1, card1Scale),\n                            getMainTranslateFromScale(2, card2Scale),\n                            getMainTranslateFromScale(3, card3Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [secondaryTranslateProp]: animatedValue.interpolate({\n                        inputRange: [0, 1, 2, 3],\n                        outputRange: [\n                            0,\n                            getSecondaryTranslateFromScale(1, card1Scale),\n                            getSecondaryTranslateFromScale(2, card2Scale),\n                            getSecondaryTranslateFromScale(3, card3Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js b/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js
deleted file mode 100644
index 1f45ec5..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js
+++ /dev/null
@@ -1,1298 +0,0 @@
-function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
-
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-import React from 'react';
-import { Animated, I18nManager, Platform, View } from 'react-native';
-import shallowCompare from 'react-addons-shallow-compare';
-import { defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles, shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles } from '../utils/animations';
-// Metro doesn't support dynamic imports - i.e. require() done in the component itself
-// But at the same time the following import will fail on Snack...
-// TODO: find a way to get React Native's version without having to assume the file path
-// import RN_PACKAGE from '../../../react-native/package.json';
-const IS_ANDROID = Platform.OS === 'android'; // React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView
-// See https://github.com/facebook/react-native/issues/11960
-// NOTE: the following variable is not declared in the constructor
-// otherwise it is undefined at init, which messes with custom indexes
-
-const IS_RTL = I18nManager.isRTL;
-export class Carousel extends React.Component {
-  constructor(props) {
-    super(props);
-
-    _defineProperty(this, "_activeItem", void 0);
-
-    _defineProperty(this, "_onScrollActiveItem", void 0);
-
-    _defineProperty(this, "_previousFirstItem", void 0);
-
-    _defineProperty(this, "_previousItemsLength", void 0);
-
-    _defineProperty(this, "_mounted", void 0);
-
-    _defineProperty(this, "_positions", void 0);
-
-    _defineProperty(this, "_currentScrollOffset", void 0);
-
-    _defineProperty(this, "_scrollEnabled", void 0);
-
-    _defineProperty(this, "_initTimeout", void 0);
-
-    _defineProperty(this, "_apparitionTimeout", void 0);
-
-    _defineProperty(this, "_hackSlideAnimationTimeout", void 0);
-
-    _defineProperty(this, "_enableAutoplayTimeout", void 0);
-
-    _defineProperty(this, "_autoplayTimeout", void 0);
-
-    _defineProperty(this, "_snapNoMomentumTimeout", void 0);
-
-    _defineProperty(this, "_androidRepositioningTimeout", void 0);
-
-    _defineProperty(this, "_autoplayInterval", void 0);
-
-    _defineProperty(this, "_scrollPos", void 0);
-
-    _defineProperty(this, "_onScrollHandler", void 0);
-
-    _defineProperty(this, "_carouselRef", null);
-
-    _defineProperty(this, "_autoplaying", void 0);
-
-    _defineProperty(this, "_autoplay", void 0);
-
-    _defineProperty(this, "_onLayoutInitDone", void 0);
-
-    this.state = {
-      hideCarousel: !!props.apparitionDelay,
-      interpolators: []
-    }; // this._RNVersionCode = this._getRNVersionCode();
-    // The following values are not stored in the state because 'setState()' is asynchronous
-    // and this results in an absolutely crappy behavior on Android while swiping (see #156)
-
-    const initialActiveItem = this._getFirstItem(props.firstItem);
-
-    this._activeItem = initialActiveItem;
-    this._onScrollActiveItem = initialActiveItem;
-    this._previousFirstItem = initialActiveItem;
-    this._previousItemsLength = initialActiveItem;
-    this._mounted = false;
-    this._positions = [];
-    this._currentScrollOffset = 0; // Store ScrollView's scroll position
-
-    this._scrollEnabled = props.scrollEnabled !== false;
-    this._getCellRendererComponent = this._getCellRendererComponent.bind(this);
-    this._getItemLayout = this._getItemLayout.bind(this);
-    this._getKeyExtractor = this._getKeyExtractor.bind(this);
-    this._onLayout = this._onLayout.bind(this);
-    this._onScroll = this._onScroll.bind(this);
-    this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);
-    this._onTouchStart = this._onTouchStart.bind(this);
-    this._onTouchEnd = this._onTouchEnd.bind(this);
-    this._renderItem = this._renderItem.bind(this); // WARNING: call this AFTER binding _onScroll
-
-    this._setScrollHandler(props); // Display warnings
-
-
-    this._displayWarnings(props);
-  }
-
-  componentDidMount() {
-    const {
-      apparitionDelay,
-      autoplay,
-      firstItem
-    } = this.props;
-    this._mounted = true;
-
-    this._initPositionsAndInterpolators(); // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...
-
-
-    this._initTimeout = setTimeout(() => {
-      if (!this._mounted) {
-        return;
-      }
-
-      const apparitionCallback = () => {
-        if (apparitionDelay) {
-          this.setState({
-            hideCarousel: false
-          });
-        }
-
-        if (autoplay) {
-          this.startAutoplay();
-        }
-      }; // FlatList will use its own built-in prop `initialScrollIndex`
-
-
-      if (this._needsScrollView()) {
-        const _firstItem = this._getFirstItem(firstItem);
-
-        this._snapToItem(_firstItem, false, false, true); // this._hackActiveSlideAnimation(_firstItem);
-
-      }
-
-      if (apparitionDelay) {
-        this._apparitionTimeout = setTimeout(() => {
-          apparitionCallback();
-        }, apparitionDelay);
-      } else {
-        apparitionCallback();
-      }
-    }, 1);
-  }
-
-  shouldComponentUpdate(nextProps, nextState) {
-    if (this.props.shouldOptimizeUpdates === false) {
-      return true;
-    } else {
-      return shallowCompare(this, nextProps, nextState);
-    }
-  }
-
-  componentDidUpdate(prevProps) {
-    const {
-      interpolators
-    } = this.state;
-    const {
-      firstItem,
-      scrollEnabled
-    } = this.props;
-
-    const itemsLength = this._getCustomDataLength(this.props);
-
-    if (!itemsLength) {
-      return;
-    }
-
-    const nextFirstItem = this._getFirstItem(firstItem, this.props);
-
-    let nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;
-    const hasNewSize = this.props.vertical !== prevProps.vertical || this.props.vertical && prevProps.vertical && (prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight) || !this.props.vertical && !prevProps.vertical && (prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth); // Prevent issues with dynamically removed items
-
-    if (nextActiveItem > itemsLength - 1) {
-      nextActiveItem = itemsLength - 1;
-    } // Handle changing scrollEnabled independent of user -> carousel interaction
-
-
-    if (scrollEnabled !== prevProps.scrollEnabled) {
-      this._setScrollEnabled(scrollEnabled);
-    }
-
-    if (interpolators.length !== itemsLength || hasNewSize) {
-      this._activeItem = nextActiveItem;
-      this._previousItemsLength = itemsLength;
-
-      this._initPositionsAndInterpolators(this.props); // Handle scroll issue when dynamically removing items (see #133)
-      // This also fixes first item's active state on Android
-      // Because 'initialScrollIndex' apparently doesn't trigger scroll
-
-
-      if (this._previousItemsLength > itemsLength) {
-        this._hackActiveSlideAnimation(nextActiveItem);
-      }
-
-      if (hasNewSize) {
-        this._snapToItem(nextActiveItem, false, false, true);
-      }
-    } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {
-      this._activeItem = nextFirstItem;
-      this._previousFirstItem = nextFirstItem;
-
-      this._snapToItem(nextFirstItem, false, true, true);
-    }
-
-    if (this.props.onScroll !== prevProps.onScroll) {
-      this._setScrollHandler(this.props);
-    }
-  }
-
-  componentWillUnmount() {
-    this._mounted = false;
-    this.stopAutoplay(); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._initTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._apparitionTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._hackSlideAnimationTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._enableAutoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._autoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._snapNoMomentumTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._androidRepositioningTimeout);
-  }
-
-  get realIndex() {
-    return this._activeItem;
-  }
-
-  get currentIndex() {
-    return this._getDataIndex(this._activeItem);
-  }
-
-  get currentScrollPosition() {
-    return this._currentScrollOffset;
-  }
-
-  _setScrollHandler(props) {
-    // Native driver for scroll events
-    const scrollEventConfig = {
-      listener: this._onScroll,
-      useNativeDriver: true
-    };
-    this._scrollPos = new Animated.Value(0);
-    const argMapping = props.vertical ? [{
-      nativeEvent: {
-        contentOffset: {
-          y: this._scrollPos
-        }
-      }
-    }] : [{
-      nativeEvent: {
-        contentOffset: {
-          x: this._scrollPos
-        }
-      }
-    }]; // @ts-expect-error Let's ignore for now that trick
-
-    if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {
-      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294
-      argMapping.pop(); // @ts-expect-error Let's ignore for now that trick
-
-      const [argMap] = props.onScroll._argMapping;
-
-      if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {
-        // Shares the same animated value passed in props
-        this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;
-      } // @ts-expect-error Let's ignore for now that trick
-
-
-      argMapping.push(...props.onScroll._argMapping);
-    }
-
-    this._onScrollHandler = Animated.event(argMapping, scrollEventConfig);
-  } // This will return a future-proof version code number compatible with semantic versioning
-  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002
-  // _getRNVersionCode () {
-  //     const version = RN_PACKAGE && RN_PACKAGE.version;
-  //     if (!version) {
-  //         return null;
-  //     }
-  //     const versionSplit = version.split('.');
-  //     if (!versionSplit || !versionSplit.length) {
-  //         return null;
-  //     }
-  //     return versionSplit[0] * 10000 +
-  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +
-  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);
-  // }
-
-
-  _displayWarnings(props = this.props) {
-    const pluginName = 'react-native-snap-carousel';
-    const removedProps = ['activeAnimationType', 'activeAnimationOptions', 'enableMomentum', 'lockScrollTimeoutDuration', 'lockScrollWhileSnapping', 'onBeforeSnapToItem', 'swipeThreshold']; // if (this._RNVersionCode && this._RNVersionCode < 5800) {
-    //     console.error(
-    //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +
-    //         'Please downgrade to version 3.x or update your version of React Native.'
-    //     );
-    // }
-
-    if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {
-      console.error("".concat(pluginName, ": You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels"));
-    }
-
-    if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {
-      console.error("".concat(pluginName, ": You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels"));
-    }
-
-    removedProps.forEach(removedProp => {
-      if (removedProp in props) {
-        console.warn("".concat(pluginName, ": Prop ").concat(removedProp, " has been removed in version 4 of the plugin"));
-      }
-    });
-  }
-
-  _needsScrollView() {
-    const {
-      useScrollView
-    } = this.props; // Android's cell renderer is buggy and has a stange overflow
-    // TODO: a workaround might be to pass the custom animated styles directly to it
-
-    return IS_ANDROID ? useScrollView || !Animated.FlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() : useScrollView || !Animated.FlatList;
-  }
-
-  _needsRTLAdaptations() {
-    const {
-      vertical
-    } = this.props;
-    return IS_RTL && IS_ANDROID && !vertical;
-  }
-
-  _enableLoop() {
-    const {
-      data,
-      enableSnap,
-      loop
-    } = this.props;
-    return enableSnap && loop && data && data.length && data.length > 1;
-  }
-
-  _shouldAnimateSlides(props = this.props) {
-    const {
-      inactiveSlideOpacity,
-      inactiveSlideScale,
-      scrollInterpolator,
-      slideInterpolatedStyle
-    } = props;
-    return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();
-  }
-
-  _shouldUseShiftLayout() {
-    const {
-      inactiveSlideShift,
-      layout
-    } = this.props;
-    return layout === 'default' && inactiveSlideShift !== 0;
-  }
-
-  _shouldUseStackLayout() {
-    return this.props.layout === 'stack';
-  }
-
-  _shouldUseTinderLayout() {
-    return this.props.layout === 'tinder';
-  }
-
-  _shouldRepositionScroll(index) {
-    const {
-      data,
-      enableSnap,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (!enableSnap || !dataLength || !this._enableLoop() || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {
-      return false;
-    }
-
-    return true;
-  }
-
-  _roundNumber(num, decimals = 1) {
-    // https://stackoverflow.com/a/41716722/
-    const rounder = Math.pow(10, decimals);
-    return Math.round((num + Number.EPSILON) * rounder) / rounder;
-  }
-
-  _isMultiple(x, y) {
-    // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/
-    // Required because Android viewport size can return pretty complicated decimals numbers
-    return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);
-  }
-
-  _getCustomData(props = this.props) {
-    const {
-      data,
-      loopClonesPerSide
-    } = props;
-    const dataLength = data && data.length;
-
-    if (!dataLength) {
-      return [];
-    }
-
-    if (!this._enableLoop()) {
-      return data;
-    }
-
-    let previousItems = [];
-    let nextItems = [];
-
-    if (loopClonesPerSide > dataLength) {
-      const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-      const remainder = loopClonesPerSide % dataLength;
-
-      for (let i = 0; i < dataMultiplier; i++) {
-        previousItems.push(...data);
-        nextItems.push(...data);
-      }
-
-      previousItems.unshift(...data.slice(-remainder));
-      nextItems.push(...data.slice(0, remainder));
-    } else {
-      previousItems = data.slice(-loopClonesPerSide);
-      nextItems = data.slice(0, loopClonesPerSide);
-    }
-
-    return previousItems.concat(data, nextItems);
-  }
-
-  _getCustomDataLength(props = this.props) {
-    const {
-      data,
-      loopClonesPerSide
-    } = props;
-    const dataLength = data && data.length;
-
-    if (!dataLength) {
-      return 0;
-    }
-
-    return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;
-  }
-
-  _getCustomIndex(index, props = this.props) {
-    const itemsLength = this._getCustomDataLength(props);
-
-    if (!itemsLength || typeof index === 'undefined') {
-      return 0;
-    }
-
-    return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;
-  }
-
-  _getDataIndex(index) {
-    const {
-      data,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (!this._enableLoop() || !dataLength) {
-      return index;
-    }
-
-    if (index >= dataLength + loopClonesPerSide) {
-      return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;
-    } else if (index < loopClonesPerSide) {
-      // TODO: is there a simpler way of determining the interpolated index?
-      if (loopClonesPerSide > dataLength) {
-        const baseDataIndexes = [];
-        const dataIndexes = [];
-        const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-        const remainder = loopClonesPerSide % dataLength;
-
-        for (let i = 0; i < dataLength; i++) {
-          baseDataIndexes.push(i);
-        }
-
-        for (let j = 0; j < dataMultiplier; j++) {
-          dataIndexes.push(...baseDataIndexes);
-        }
-
-        dataIndexes.unshift(...baseDataIndexes.slice(-remainder));
-        return dataIndexes[index];
-      } else {
-        return index + dataLength - loopClonesPerSide;
-      }
-    } else {
-      return index - loopClonesPerSide;
-    }
-  } // Used with `snapToItem()` and 'PaginationDot'
-
-
-  _getPositionIndex(index) {
-    const {
-      loop,
-      loopClonesPerSide
-    } = this.props;
-    return loop ? index + loopClonesPerSide : index;
-  }
-
-  _getSnapOffsets(props = this.props) {
-    const offset = this._getItemMainDimension();
-
-    return [...Array(this._getCustomDataLength(props))].map((_, i) => {
-      return i * offset;
-    });
-  }
-
-  _getFirstItem(index, props = this.props) {
-    const {
-      loopClonesPerSide
-    } = props;
-
-    const itemsLength = this._getCustomDataLength(props);
-
-    if (!itemsLength || index > itemsLength - 1 || index < 0) {
-      return 0;
-    }
-
-    return this._enableLoop() ? index + loopClonesPerSide : index;
-  }
-
-  _getWrappedRef() {
-    // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component
-    if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {
-      return this._carouselRef;
-    } // https://github.com/facebook/react-native/issues/10635
-    // https://stackoverflow.com/a/48786374/8412141
-
-
-    return this._carouselRef && // @ts-expect-error This is for before 0.62
-    this._carouselRef.getNode && // @ts-expect-error This is for before 0.62
-    this._carouselRef.getNode();
-  }
-
-  _getScrollEnabled() {
-    return this._scrollEnabled;
-  }
-
-  _setScrollEnabled(scrollEnabled = true) {
-    const wrappedRef = this._getWrappedRef();
-
-    if (!wrappedRef || !wrappedRef.setNativeProps) {
-      return;
-    } // 'setNativeProps()' is used instead of 'setState()' because the latter
-    // really takes a toll on Android behavior when momentum is disabled
-
-
-    wrappedRef.setNativeProps({
-      scrollEnabled
-    });
-    this._scrollEnabled = scrollEnabled;
-  }
-
-  _getItemMainDimension() {
-    return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;
-  }
-
-  _getItemScrollOffset(index) {
-    return this._positions && this._positions[index] && this._positions[index].start;
-  }
-
-  _getItemLayout(_, index) {
-    const itemMainDimension = this._getItemMainDimension();
-
-    return {
-      index,
-      length: itemMainDimension,
-      offset: itemMainDimension * index // + this._getContainerInnerMargin()
-
-    };
-  } // This will allow us to have a proper zIndex even with a FlatList
-  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165
-
-
-  _getCellRendererComponent({
-    children,
-    index,
-    style,
-    ...props
-  }) {
-    const cellStyle = [style, !IS_ANDROID ? {
-      zIndex: this._getCustomDataLength() - index
-    } : {}];
-    return /*#__PURE__*/React.createElement(View, _extends({
-      style: cellStyle,
-      key: index
-    }, props), children);
-  }
-
-  _getKeyExtractor(_, index) {
-    return this._needsScrollView() ? "scrollview-item-".concat(index) : "flatlist-item-".concat(index);
-  }
-
-  _getScrollOffset(event) {
-    const {
-      vertical
-    } = this.props;
-    return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;
-  }
-
-  _getContainerInnerMargin(opposite = false) {
-    const {
-      activeSlideAlignment
-    } = this.props;
-
-    if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {
-      return 0;
-    } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {
-      return this.props.vertical ? this.props.sliderHeight - this.props.itemHeight : this.props.sliderWidth - this.props.itemWidth;
-    } else {
-      return this.props.vertical ? (this.props.sliderHeight - this.props.itemHeight) / 2 : (this.props.sliderWidth - this.props.itemWidth) / 2;
-    }
-  }
-
-  _getActiveSlideOffset() {
-    const {
-      activeSlideOffset
-    } = this.props;
-
-    const itemMainDimension = this._getItemMainDimension();
-
-    const minOffset = 10; // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide
-
-    return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;
-  }
-
-  _getActiveItem(offset) {
-    const itemMainDimension = this._getItemMainDimension();
-
-    const center = offset + itemMainDimension / 2;
-
-    const activeSlideOffset = this._getActiveSlideOffset();
-
-    const lastIndex = this._positions.length - 1;
-    let itemIndex;
-
-    if (offset <= 0) {
-      return 0;
-    }
-
-    if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {
-      return lastIndex;
-    }
-
-    for (let i = 0; i < this._positions.length; i++) {
-      const {
-        start,
-        end
-      } = this._positions[i];
-
-      if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {
-        itemIndex = i;
-        break;
-      }
-    }
-
-    return itemIndex || 0;
-  }
-
-  _getSlideInterpolatedStyle(index, animatedValue) {
-    const {
-      layoutCardOffset,
-      slideInterpolatedStyle
-    } = this.props;
-
-    if (slideInterpolatedStyle) {
-      return slideInterpolatedStyle(index, animatedValue, this.props);
-    } else if (this._shouldUseTinderLayout()) {
-      return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);
-    } else if (this._shouldUseStackLayout()) {
-      return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);
-    } else if (this._shouldUseShiftLayout()) {
-      return shiftAnimatedStyles(index, animatedValue, this.props);
-    } else {
-      return defaultAnimatedStyles(index, animatedValue, this.props);
-    }
-  }
-
-  _initPositionsAndInterpolators(props = this.props) {
-    const {
-      data,
-      scrollInterpolator
-    } = props;
-
-    const itemMainDimension = this._getItemMainDimension();
-
-    if (!data || !data.length) {
-      return;
-    }
-
-    const interpolators = [];
-    this._positions = [];
-
-    this._getCustomData(props).forEach((_itemData, index) => {
-      const _index = this._getCustomIndex(index, props);
-
-      let animatedValue;
-      this._positions[index] = {
-        start: index * itemMainDimension,
-        end: index * itemMainDimension + itemMainDimension
-      };
-
-      if (!this._shouldAnimateSlides(props) || !this._scrollPos) {
-        animatedValue = new Animated.Value(1);
-      } else {
-        let interpolator;
-
-        if (scrollInterpolator) {
-          interpolator = scrollInterpolator(_index, props);
-        } else if (this._shouldUseStackLayout()) {
-          interpolator = stackScrollInterpolator(_index, props);
-        } else if (this._shouldUseTinderLayout()) {
-          interpolator = tinderScrollInterpolator(_index, props);
-        }
-
-        if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {
-          interpolator = defaultScrollInterpolator(_index, props);
-        }
-
-        animatedValue = this._scrollPos.interpolate({ ...interpolator,
-          extrapolate: 'clamp'
-        });
-      }
-
-      interpolators.push(animatedValue);
-    });
-
-    this.setState({
-      interpolators
-    });
-  }
-
-  _hackActiveSlideAnimation(index, scrollValue = 1) {
-    const offset = this._getItemScrollOffset(index);
-
-    if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {
-      return;
-    }
-
-    const multiplier = this._currentScrollOffset === 0 ? 1 : -1;
-    const scrollDelta = scrollValue * multiplier;
-
-    this._scrollTo({
-      offset: offset + scrollDelta,
-      animated: false
-    }); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-
-    clearTimeout(this._hackSlideAnimationTimeout);
-    this._hackSlideAnimationTimeout = setTimeout(() => {
-      this._scrollTo({
-        offset,
-        animated: false
-      });
-    }, 1); // works randomly when set to '0'
-  }
-
-  _repositionScroll(index, animated = false) {
-    const {
-      data,
-      loopClonesPerSide
-    } = this.props;
-    const dataLength = data && data.length;
-
-    if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {
-      return;
-    }
-
-    let repositionTo = index;
-
-    if (index >= dataLength + loopClonesPerSide) {
-      repositionTo = index - dataLength;
-    } else if (index < loopClonesPerSide) {
-      repositionTo = index + dataLength;
-    }
-
-    this._snapToItem(repositionTo, animated, false);
-  }
-
-  _scrollTo({
-    offset,
-    index,
-    animated = true
-  }) {
-    const {
-      vertical
-    } = this.props;
-
-    const wrappedRef = this._getWrappedRef();
-
-    if (!this._mounted || !wrappedRef || typeof offset === 'undefined' && typeof index === 'undefined') {
-      return;
-    }
-
-    let scrollToOffset;
-
-    if (typeof index !== 'undefined') {
-      scrollToOffset = this._getItemScrollOffset(index);
-    } else {
-      scrollToOffset = offset;
-    }
-
-    if (typeof scrollToOffset === 'undefined') {
-      return;
-    }
-
-    const options = this._needsScrollView() ? {
-      x: vertical ? 0 : offset,
-      y: vertical ? offset : 0,
-      animated
-    } : {
-      offset,
-      animated
-    };
-
-    if (this._needsScrollView()) {
-      wrappedRef.scrollTo(options);
-    } else {
-      wrappedRef.scrollToOffset(options);
-    }
-  }
-
-  _onTouchStart(event) {
-    const {
-      onTouchStart
-    } = this.props; // `onTouchStart` is fired even when `scrollEnabled` is set to `false`
-
-    if (this._getScrollEnabled() !== false && this._autoplaying) {
-      this.pauseAutoPlay();
-    }
-
-    onTouchStart && onTouchStart(event);
-  }
-
-  _onTouchEnd(event) {
-    const {
-      onTouchEnd
-    } = this.props;
-
-    if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {
-      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()
-      this.startAutoplay();
-    }
-
-    onTouchEnd && onTouchEnd(event);
-  }
-
-  _onScroll(event) {
-    const {
-      onScroll,
-      onScrollIndexChanged
-    } = this.props;
-    const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
-
-    const nextActiveItem = this._getActiveItem(scrollOffset);
-
-    this._currentScrollOffset = scrollOffset;
-
-    if (nextActiveItem !== this._onScrollActiveItem) {
-      this._onScrollActiveItem = nextActiveItem;
-      onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));
-    }
-
-    if (typeof onScroll === 'function' && event) {
-      onScroll(event);
-    }
-  }
-
-  _onMomentumScrollEnd(event) {
-    const {
-      autoplayDelay,
-      onMomentumScrollEnd,
-      onSnapToItem
-    } = this.props;
-    const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
-
-    const nextActiveItem = this._getActiveItem(scrollOffset);
-
-    const hasSnapped = this._isMultiple(scrollOffset, this.props.vertical ? this.props.itemHeight : this.props.itemWidth); // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:
-    // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated
-    // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically
-
-
-    if (nextActiveItem !== this._activeItem) {
-      this._activeItem = nextActiveItem;
-      onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));
-
-      if (hasSnapped) {
-        this._repositionScroll(nextActiveItem);
-      }
-    }
-
-    onMomentumScrollEnd && onMomentumScrollEnd(event); // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed
-    // https://github.com/facebook/react-native/issues/9439
-
-    if (IS_ANDROID && this._autoplay && !this._autoplaying) {
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._enableAutoplayTimeout);
-      this._enableAutoplayTimeout = setTimeout(() => {
-        this.startAutoplay();
-      }, autoplayDelay);
-    }
-  }
-
-  _onLayout(event) {
-    const {
-      onLayout
-    } = this.props; // Prevent unneeded actions during the first 'onLayout' (triggered on init)
-
-    if (this._onLayoutInitDone) {
-      this._initPositionsAndInterpolators();
-
-      this._snapToItem(this._activeItem, false, false, true);
-    } else {
-      this._onLayoutInitDone = true;
-    }
-
-    onLayout && onLayout(event);
-  }
-
-  _snapToItem(index, animated = true, fireCallback = true, forceScrollTo = false) {
-    const {
-      onSnapToItem
-    } = this.props;
-
-    const itemsLength = this._getCustomDataLength();
-
-    const wrappedRef = this._getWrappedRef();
-
-    if (!itemsLength || !wrappedRef) {
-      return;
-    }
-
-    if (!index || index < 0) {
-      index = 0;
-    } else if (itemsLength > 0 && index >= itemsLength) {
-      index = itemsLength - 1;
-    }
-
-    if (index === this._activeItem && !forceScrollTo) {
-      return;
-    }
-
-    const offset = this._getItemScrollOffset(index);
-
-    if (offset === undefined) {
-      return;
-    }
-
-    this._scrollTo({
-      offset,
-      animated
-    }); // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated
-    // so we need to trigger the callback manually
-    // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically
-    // Therefore everything critical needs to be manually called here as well, even though the timing might be off
-
-
-    const requiresManualTrigger = !animated || IS_ANDROID;
-
-    if (requiresManualTrigger) {
-      this._activeItem = index;
-
-      if (fireCallback) {
-        onSnapToItem && onSnapToItem(this._getDataIndex(index));
-      } // Repositioning on Android
-
-
-      if (IS_ANDROID && this._shouldRepositionScroll(index)) {
-        if (animated) {
-          this._androidRepositioningTimeout = setTimeout(() => {
-            // Without scroll animation, the behavior is completely buggy...
-            this._repositionScroll(index, true);
-          }, 400); // Approximate scroll duration on Android
-        } else {
-          this._repositionScroll(index);
-        }
-      }
-    }
-  }
-
-  startAutoplay() {
-    const {
-      autoplayInterval,
-      autoplayDelay
-    } = this.props;
-    this._autoplay = true;
-
-    if (this._autoplaying) {
-      return;
-    } // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-
-    clearTimeout(this._autoplayTimeout);
-    this._autoplayTimeout = setTimeout(() => {
-      this._autoplaying = true;
-      this._autoplayInterval = setInterval(() => {
-        if (this._autoplaying) {
-          this.snapToNext();
-        }
-      }, autoplayInterval);
-    }, autoplayDelay);
-  }
-
-  pauseAutoPlay() {
-    this._autoplaying = false; // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._autoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearTimeout(this._enableAutoplayTimeout); // @ts-expect-error setTimeout / clearTiemout is buggy :/
-
-    clearInterval(this._autoplayInterval);
-  }
-
-  stopAutoplay() {
-    this._autoplay = false;
-    this.pauseAutoPlay();
-  }
-
-  snapToItem(index, animated = true, fireCallback = true) {
-    if (!index || index < 0) {
-      index = 0;
-    }
-
-    const positionIndex = this._getPositionIndex(index);
-
-    if (positionIndex === this._activeItem) {
-      return;
-    }
-
-    this._snapToItem(positionIndex, animated, fireCallback);
-  }
-
-  snapToNext(animated = true, fireCallback = true) {
-    const itemsLength = this._getCustomDataLength();
-
-    let newIndex = this._activeItem + 1;
-
-    if (newIndex > itemsLength - 1) {
-      newIndex = 0;
-    }
-
-    this._snapToItem(newIndex, animated, fireCallback);
-  }
-
-  snapToPrev(animated = true, fireCallback = true) {
-    const itemsLength = this._getCustomDataLength();
-
-    let newIndex = this._activeItem - 1;
-
-    if (newIndex < 0) {
-      newIndex = itemsLength - 1;
-    }
-
-    this._snapToItem(newIndex, animated, fireCallback);
-  } // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668
-
-
-  triggerRenderingHack(offset = 1) {
-    this._hackActiveSlideAnimation(this._activeItem, offset);
-  }
-
-  _renderItem({
-    item,
-    index
-  }) {
-    const {
-      interpolators
-    } = this.state;
-    const {
-      keyExtractor,
-      slideStyle
-    } = this.props;
-    const animatedValue = interpolators && interpolators[index];
-
-    if (typeof animatedValue === 'undefined') {
-      return null;
-    }
-
-    const animate = this._shouldAnimateSlides();
-
-    const Component = animate ? Animated.View : View;
-    const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};
-
-    const dataIndex = this._getDataIndex(index);
-
-    const mainDimension = this.props.vertical ? {
-      height: this.props.itemHeight
-    } : {
-      width: this.props.itemWidth
-    };
-    const specificProps = this._needsScrollView() ? {
-      key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)
-    } : {};
-    return /*#__PURE__*/React.createElement(Component, _extends({
-      style: [mainDimension, slideStyle, animatedStyle],
-      pointerEvents: "box-none"
-    }, specificProps), this.props.vertical ? this.props.renderItem({
-      item,
-      index,
-      dataIndex
-    }, {
-      scrollPosition: this._scrollPos,
-      carouselRef: this._carouselRef,
-      vertical: this.props.vertical,
-      sliderHeight: this.props.sliderHeight,
-      itemHeight: this.props.itemHeight
-    }) : this.props.renderItem({
-      item,
-      index,
-      dataIndex
-    }, {
-      scrollPosition: this._scrollPos,
-      carouselRef: this._carouselRef,
-      vertical: !!this.props.vertical,
-      sliderWidth: this.props.sliderWidth,
-      itemWidth: this.props.itemWidth
-    }));
-  }
-
-  _getComponentOverridableProps() {
-    const {
-      hideCarousel
-    } = this.state;
-    const {
-      loopClonesPerSide
-    } = this.props;
-    const visibleItems = Math.ceil(this.props.vertical ? this.props.sliderHeight / this.props.itemHeight : this.props.sliderWidth / this.props.itemWidth) + 1;
-    const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;
-    const initialNumToRender = visibleItems + initialNumPerSide * 2;
-    const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;
-    const windowSize = maxToRenderPerBatch;
-    const specificProps = !this._needsScrollView() ? {
-      initialNumToRender,
-      maxToRenderPerBatch,
-      windowSize // updateCellsBatchingPeriod
-
-    } : {};
-    return { ...specificProps,
-      automaticallyAdjustContentInsets: false,
-      decelerationRate: 'fast',
-      directionalLockEnabled: true,
-      disableScrollViewPanResponder: false,
-      // If set to `true`, touch events will be triggered too easily
-      inverted: this._needsRTLAdaptations(),
-      overScrollMode: 'never',
-      pinchGestureEnabled: false,
-      pointerEvents: hideCarousel ? 'none' : 'auto',
-      // removeClippedSubviews: !this._needsScrollView(),
-      // renderToHardwareTextureAndroid: true,
-      scrollsToTop: false,
-      showsHorizontalScrollIndicator: false,
-      showsVerticalScrollIndicator: false
-    };
-  }
-
-  _getComponentStaticProps() {
-    const {
-      hideCarousel
-    } = this.state;
-    const {
-      activeSlideAlignment,
-      CellRendererComponent,
-      containerCustomStyle,
-      contentContainerCustomStyle,
-      firstItem,
-      getItemLayout,
-      keyExtractor,
-      style,
-      useExperimentalSnap
-    } = this.props;
-    const containerStyle = [// { overflow: 'hidden' },
-    containerCustomStyle || style || {}, hideCarousel ? {
-      opacity: 0
-    } : {}, this.props.vertical ? {
-      height: this.props.sliderHeight,
-      flexDirection: 'column'
-    } : // LTR hack; see https://github.com/facebook/react-native/issues/11960
-    // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423
-    {
-      width: this.props.sliderWidth,
-      flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'
-    }];
-    const innerMarginStyle = this.props.vertical ? {
-      paddingTop: this._getContainerInnerMargin(),
-      paddingBottom: this._getContainerInnerMargin(true)
-    } : {
-      paddingLeft: this._getContainerInnerMargin(),
-      paddingRight: this._getContainerInnerMargin(true)
-    };
-    const contentContainerStyle = [!useExperimentalSnap ? innerMarginStyle : {}, contentContainerCustomStyle || {}]; // WARNING: `snapToAlignment` won't work as intended because of the following:
-    // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755
-    // - Snap points will be off
-    // - Slide animations will be off
-    // - Last items won't be set as active (no `onSnapToItem` callback)
-    // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being
-
-    const snapProps = useExperimentalSnap ? {
-      // disableIntervalMomentum: true, // Slide ± one item at a time
-      snapToAlignment: activeSlideAlignment,
-      snapToInterval: this._getItemMainDimension()
-    } : {
-      snapToOffsets: this._getSnapOffsets()
-    }; // Flatlist specifics
-
-    const specificProps = !this._needsScrollView() ? {
-      CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,
-      getItemLayout: getItemLayout || this._getItemLayout,
-      initialScrollIndex: this._getFirstItem(firstItem),
-      keyExtractor: keyExtractor || this._getKeyExtractor,
-      numColumns: 1,
-      renderItem: this._renderItem
-    } : {};
-    return { ...specificProps,
-      ...snapProps,
-      // eslint-disable-next-line @typescript-eslint/no-explicit-any
-      ref: c => {
-        this._carouselRef = c;
-      },
-      contentContainerStyle: contentContainerStyle,
-      data: this._getCustomData(),
-      horizontal: !this.props.vertical,
-      scrollEventThrottle: 1,
-      style: containerStyle,
-      onLayout: this._onLayout,
-      onMomentumScrollEnd: this._onMomentumScrollEnd,
-      onScroll: this._onScrollHandler,
-      onTouchStart: this._onTouchStart,
-      onTouchEnd: this._onTouchEnd
-    };
-  }
-
-  render() {
-    const {
-      data,
-      renderItem,
-      useScrollView
-    } = this.props;
-
-    if (!data || !renderItem) {
-      return null;
-    }
-
-    const props = { ...this._getComponentOverridableProps(),
-      ...this.props,
-      ...this._getComponentStaticProps()
-    };
-    const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;
-    return this._needsScrollView() || !Animated.FlatList ? /*#__PURE__*/React.createElement(ScrollViewComponent, props, this._getCustomData().map((item, index) => {
-      return this._renderItem({
-        item,
-        index
-      });
-    })) :
-    /*#__PURE__*/
-    // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between
-    // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.
-    React.createElement(Animated.FlatList, props);
-  }
-
-}
-
-_defineProperty(Carousel, "defaultProps", {
-  activeSlideAlignment: 'center',
-  activeSlideOffset: 20,
-  apparitionDelay: 0,
-  autoplay: false,
-  autoplayDelay: 1000,
-  autoplayInterval: 3000,
-  callbackOffsetMargin: 5,
-  containerCustomStyle: {},
-  contentContainerCustomStyle: {},
-  enableSnap: true,
-  firstItem: 0,
-  hasParallaxImages: false,
-  inactiveSlideOpacity: 0.7,
-  inactiveSlideScale: 0.9,
-  inactiveSlideShift: 0,
-  layout: 'default',
-  loop: false,
-  loopClonesPerSide: 3,
-  scrollEnabled: true,
-  slideStyle: {},
-  shouldOptimizeUpdates: true,
-  useExperimentalSnap: false,
-  useScrollView: !Animated.FlatList
-});
-
-export default Carousel;
-//# sourceMappingURL=Carousel.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js.map b/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js.map
deleted file mode 100644
index 12e91df..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/carousel/Carousel.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Carousel.tsx"],"names":["React","Animated","I18nManager","Platform","View","shallowCompare","defaultScrollInterpolator","stackScrollInterpolator","tinderScrollInterpolator","defaultAnimatedStyles","shiftAnimatedStyles","stackAnimatedStyles","tinderAnimatedStyles","IS_ANDROID","OS","IS_RTL","isRTL","Carousel","Component","constructor","props","state","hideCarousel","apparitionDelay","interpolators","initialActiveItem","_getFirstItem","firstItem","_activeItem","_onScrollActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentScrollOffset","_scrollEnabled","scrollEnabled","_getCellRendererComponent","bind","_getItemLayout","_getKeyExtractor","_onLayout","_onScroll","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_renderItem","_setScrollHandler","_displayWarnings","componentDidMount","autoplay","_initPositionsAndInterpolators","_initTimeout","setTimeout","apparitionCallback","setState","startAutoplay","_needsScrollView","_firstItem","_snapToItem","_apparitionTimeout","shouldComponentUpdate","nextProps","nextState","shouldOptimizeUpdates","componentDidUpdate","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSize","vertical","itemHeight","sliderHeight","itemWidth","sliderWidth","_setScrollEnabled","length","_hackActiveSlideAnimation","onScroll","componentWillUnmount","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_androidRepositioningTimeout","realIndex","currentIndex","_getDataIndex","currentScrollPosition","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","pluginName","removedProps","console","error","forEach","removedProp","warn","useScrollView","FlatList","_shouldUseStackLayout","_shouldUseTinderLayout","_needsRTLAdaptations","_enableLoop","data","enableSnap","loop","_shouldAnimateSlides","inactiveSlideOpacity","inactiveSlideScale","scrollInterpolator","slideInterpolatedStyle","_shouldUseShiftLayout","inactiveSlideShift","layout","_shouldRepositionScroll","index","loopClonesPerSide","dataLength","_roundNumber","num","decimals","rounder","Math","pow","round","Number","EPSILON","_isMultiple","_getCustomData","previousItems","nextItems","dataMultiplier","floor","remainder","i","unshift","slice","concat","_getCustomIndex","baseDataIndexes","dataIndexes","j","_getPositionIndex","_getSnapOffsets","offset","_getItemMainDimension","map","_","_getWrappedRef","_carouselRef","scrollTo","scrollToOffset","getNode","_getScrollEnabled","wrappedRef","setNativeProps","_getItemScrollOffset","start","itemMainDimension","children","style","cellStyle","zIndex","_getScrollOffset","_getContainerInnerMargin","opposite","activeSlideAlignment","_getActiveSlideOffset","activeSlideOffset","minOffset","_getActiveItem","center","lastIndex","itemIndex","end","_getSlideInterpolatedStyle","animatedValue","layoutCardOffset","_itemData","_index","interpolator","inputRange","outputRange","interpolate","extrapolate","scrollValue","multiplier","scrollDelta","_scrollTo","animated","_repositionScroll","repositionTo","options","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollIndexChanged","scrollOffset","autoplayDelay","onMomentumScrollEnd","onSnapToItem","hasSnapped","onLayout","_onLayoutInitDone","fireCallback","forceScrollTo","undefined","requiresManualTrigger","autoplayInterval","_autoplayInterval","setInterval","snapToNext","clearInterval","snapToItem","positionIndex","newIndex","snapToPrev","triggerRenderingHack","item","keyExtractor","slideStyle","animate","animatedStyle","dataIndex","mainDimension","height","width","specificProps","key","renderItem","scrollPosition","carouselRef","_getComponentOverridableProps","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","automaticallyAdjustContentInsets","decelerationRate","directionalLockEnabled","disableScrollViewPanResponder","inverted","overScrollMode","pinchGestureEnabled","pointerEvents","scrollsToTop","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","_getComponentStaticProps","CellRendererComponent","containerCustomStyle","contentContainerCustomStyle","getItemLayout","useExperimentalSnap","containerStyle","opacity","flexDirection","innerMarginStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","contentContainerStyle","snapProps","snapToAlignment","snapToInterval","snapToOffsets","initialScrollIndex","numColumns","ref","c","horizontal","scrollEventThrottle","render","ScrollViewComponent","ScrollView","callbackOffsetMargin","hasParallaxImages"],"mappings":"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","sourcesContent":["import React, { PropsWithChildren } from 'react';\nimport {\n    Animated,\n    FlatList,\n    I18nManager,\n    Platform,\n    ScrollView,\n    View,\n    StyleProp,\n    NativeSyntheticEvent,\n    NativeScrollEvent,\n    LayoutChangeEvent,\n    GestureResponderEvent,\n    ViewStyle\n} from 'react-native';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\nimport type { CarouselProps, CarouselState } from './types';\n\n// Metro doesn't support dynamic imports - i.e. require() done in the component itself\n// But at the same time the following import will fail on Snack...\n// TODO: find a way to get React Native's version without having to assume the file path\n// import RN_PACKAGE from '../../../react-native/package.json';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport class Carousel<TData> extends React.Component<\n  CarouselProps<TData>,\n  CarouselState\n> {\n  static defaultProps = {\n      activeSlideAlignment: 'center',\n      activeSlideOffset: 20,\n      apparitionDelay: 0,\n      autoplay: false,\n      autoplayDelay: 1000,\n      autoplayInterval: 3000,\n      callbackOffsetMargin: 5,\n      containerCustomStyle: {},\n      contentContainerCustomStyle: {},\n      enableSnap: true,\n      firstItem: 0,\n      hasParallaxImages: false,\n      inactiveSlideOpacity: 0.7,\n      inactiveSlideScale: 0.9,\n      inactiveSlideShift: 0,\n      layout: 'default',\n      loop: false,\n      loopClonesPerSide: 3,\n      scrollEnabled: true,\n      slideStyle: {},\n      shouldOptimizeUpdates: true,\n      useExperimentalSnap: false,\n      useScrollView: !Animated.FlatList\n  };\n\n  _activeItem: number;\n  _onScrollActiveItem: number;\n  _previousFirstItem: number;\n  _previousItemsLength: number;\n  _mounted: boolean;\n  _positions: { start: number; end: number }[];\n  _currentScrollOffset: number;\n  _scrollEnabled: boolean;\n\n  _initTimeout?: ReturnType<typeof setTimeout>;\n  _apparitionTimeout?: ReturnType<typeof setTimeout>;\n  _hackSlideAnimationTimeout?: ReturnType<typeof setTimeout>;\n  _enableAutoplayTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayTimeout?: ReturnType<typeof setTimeout>;\n  _snapNoMomentumTimeout?: ReturnType<typeof setTimeout>;\n  _androidRepositioningTimeout?: ReturnType<typeof setTimeout>;\n  _autoplayInterval?: ReturnType<typeof setInterval>;\n\n  _scrollPos?: Animated.Value;\n\n  _onScrollHandler?: ReturnType<typeof Animated.event>;\n\n  _carouselRef: ScrollView | FlatList<TData> | null = null;\n\n  _autoplaying?: boolean;\n  _autoplay?: boolean;\n\n  _onLayoutInitDone?: boolean;\n\n  constructor (props: CarouselProps<TData>) {\n      super(props);\n\n      this.state = {\n          hideCarousel: !!props.apparitionDelay,\n          interpolators: []\n      };\n\n      // this._RNVersionCode = this._getRNVersionCode();\n\n      // The following values are not stored in the state because 'setState()' is asynchronous\n      // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n      const initialActiveItem = this._getFirstItem(props.firstItem);\n      this._activeItem = initialActiveItem;\n      this._onScrollActiveItem = initialActiveItem;\n      this._previousFirstItem = initialActiveItem;\n      this._previousItemsLength = initialActiveItem;\n\n      this._mounted = false;\n      this._positions = [];\n      this._currentScrollOffset = 0; // Store ScrollView's scroll position\n      this._scrollEnabled = props.scrollEnabled !== false;\n\n      this._getCellRendererComponent = this._getCellRendererComponent.bind(this);\n      this._getItemLayout = this._getItemLayout.bind(this);\n      this._getKeyExtractor = this._getKeyExtractor.bind(this);\n      this._onLayout = this._onLayout.bind(this);\n      this._onScroll = this._onScroll.bind(this);\n      this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);\n      this._onTouchStart = this._onTouchStart.bind(this);\n      this._onTouchEnd = this._onTouchEnd.bind(this);\n      this._renderItem = this._renderItem.bind(this);\n\n      // WARNING: call this AFTER binding _onScroll\n      this._setScrollHandler(props);\n\n      // Display warnings\n      this._displayWarnings(props);\n  }\n\n  componentDidMount () {\n      const { apparitionDelay, autoplay, firstItem } = this.props;\n\n      this._mounted = true;\n      this._initPositionsAndInterpolators();\n\n      // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n      this._initTimeout = setTimeout(() => {\n          if (!this._mounted) {\n              return;\n          }\n\n          const apparitionCallback = () => {\n              if (apparitionDelay) {\n                  this.setState({ hideCarousel: false });\n              }\n              if (autoplay) {\n                  this.startAutoplay();\n              }\n          };\n\n          // FlatList will use its own built-in prop `initialScrollIndex`\n          if (this._needsScrollView()) {\n              const _firstItem = this._getFirstItem(firstItem);\n              this._snapToItem(_firstItem, false, false, true);\n              // this._hackActiveSlideAnimation(_firstItem);\n          }\n\n          if (apparitionDelay) {\n              this._apparitionTimeout = setTimeout(() => {\n                  apparitionCallback();\n              }, apparitionDelay);\n          } else {\n              apparitionCallback();\n          }\n      }, 1);\n  }\n\n  shouldComponentUpdate (\n      nextProps: CarouselProps<TData>,\n      nextState: CarouselState\n  ): boolean {\n      if (this.props.shouldOptimizeUpdates === false) {\n          return true;\n      } else {\n          return shallowCompare(this, nextProps, nextState);\n      }\n  }\n\n  componentDidUpdate (prevProps: CarouselProps<TData>) {\n      const { interpolators } = this.state;\n      const {\n          firstItem,\n          scrollEnabled\n      } = this.props;\n      const itemsLength = this._getCustomDataLength(this.props);\n\n      if (!itemsLength) {\n          return;\n      }\n\n      const nextFirstItem = this._getFirstItem(firstItem, this.props);\n      let nextActiveItem =\n      typeof this._activeItem !== 'undefined' ?\n          this._activeItem :\n          nextFirstItem;\n\n      const hasNewSize = this.props.vertical !== prevProps.vertical ||\n       (\n           this.props.vertical && prevProps.vertical && (\n               prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight\n           )\n       ) || (\n          !this.props.vertical && !prevProps.vertical && (\n              prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth\n          )\n      );\n\n      // Prevent issues with dynamically removed items\n      if (nextActiveItem > itemsLength - 1) {\n          nextActiveItem = itemsLength - 1;\n      }\n\n      // Handle changing scrollEnabled independent of user -> carousel interaction\n      if (scrollEnabled !== prevProps.scrollEnabled) {\n          this._setScrollEnabled(scrollEnabled);\n      }\n\n      if (\n          interpolators.length !== itemsLength ||\n          hasNewSize\n      ) {\n          this._activeItem = nextActiveItem;\n          this._previousItemsLength = itemsLength;\n\n          this._initPositionsAndInterpolators(this.props);\n\n          // Handle scroll issue when dynamically removing items (see #133)\n          // This also fixes first item's active state on Android\n          // Because 'initialScrollIndex' apparently doesn't trigger scroll\n          if (this._previousItemsLength > itemsLength) {\n              this._hackActiveSlideAnimation(nextActiveItem);\n          }\n\n          if (hasNewSize) {\n              this._snapToItem(nextActiveItem, false, false, true);\n          }\n      } else if (\n          nextFirstItem !== this._previousFirstItem &&\n      nextFirstItem !== this._activeItem\n      ) {\n          this._activeItem = nextFirstItem;\n          this._previousFirstItem = nextFirstItem;\n          this._snapToItem(nextFirstItem, false, true, true);\n      }\n\n      if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n      }\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n      this.stopAutoplay();\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._initTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._apparitionTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._snapNoMomentumTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._androidRepositioningTimeout);\n  }\n\n  get realIndex () {\n      return this._activeItem;\n  }\n\n  get currentIndex () {\n      return this._getDataIndex(this._activeItem);\n  }\n\n  get currentScrollPosition () {\n      return this._currentScrollOffset;\n  }\n\n  _setScrollHandler (props: CarouselProps<TData>) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n          listener: this._onScroll,\n          useNativeDriver: true\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical ?\n          [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :\n          [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      // @ts-expect-error Let's ignore for now that trick\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n          argMapping.pop();\n          // @ts-expect-error Let's ignore for now that trick\n          const [argMap] = props.onScroll._argMapping;\n          if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n              // Shares the same animated value passed in props\n              this._scrollPos =\n          argMap.nativeEvent.contentOffset.x ||\n          argMap.nativeEvent.contentOffset.y ||\n          this._scrollPos;\n          }\n          // @ts-expect-error Let's ignore for now that trick\n          argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event<NativeScrollEvent>(\n          argMapping,\n          scrollEventConfig\n      );\n  }\n\n  // This will return a future-proof version code number compatible with semantic versioning\n  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002\n  // _getRNVersionCode () {\n  //     const version = RN_PACKAGE && RN_PACKAGE.version;\n  //     if (!version) {\n  //         return null;\n  //     }\n  //     const versionSplit = version.split('.');\n  //     if (!versionSplit || !versionSplit.length) {\n  //         return null;\n  //     }\n  //     return versionSplit[0] * 10000 +\n  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +\n  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);\n  // }\n\n  _displayWarnings (props: CarouselProps<TData> = this.props) {\n      const pluginName = 'react-native-snap-carousel';\n      const removedProps = [\n          'activeAnimationType',\n          'activeAnimationOptions',\n          'enableMomentum',\n          'lockScrollTimeoutDuration',\n          'lockScrollWhileSnapping',\n          'onBeforeSnapToItem',\n          'swipeThreshold'\n      ] as const;\n\n      // if (this._RNVersionCode && this._RNVersionCode < 5800) {\n      //     console.error(\n      //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +\n      //         'Please downgrade to version 3.x or update your version of React Native.'\n      //     );\n      // }\n      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`\n          );\n      }\n      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n          console.error(\n              `${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`\n          );\n      }\n\n      removedProps.forEach((removedProp) => {\n          if (removedProp in props) {\n              console.warn(\n                  `${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`\n              );\n          }\n      });\n  }\n\n  _needsScrollView () {\n      const { useScrollView } = this.props;\n      // Android's cell renderer is buggy and has a stange overflow\n      // TODO: a workaround might be to pass the custom animated styles directly to it\n      return IS_ANDROID ?\n          useScrollView ||\n          !Animated.FlatList ||\n          this._shouldUseStackLayout() ||\n          this._shouldUseTinderLayout() :\n          useScrollView || !Animated.FlatList;\n  }\n\n  _needsRTLAdaptations () {\n      const { vertical } = this.props;\n      return IS_RTL && IS_ANDROID && !vertical;\n  }\n\n  _enableLoop () {\n      const { data, enableSnap, loop } = this.props;\n      return enableSnap && loop && data && data.length && data.length > 1;\n  }\n\n  _shouldAnimateSlides (props: CarouselProps<TData> = this.props) {\n      const {\n          inactiveSlideOpacity,\n          inactiveSlideScale,\n          scrollInterpolator,\n          slideInterpolatedStyle\n      } = props;\n      return (\n          inactiveSlideOpacity < 1 ||\n      inactiveSlideScale < 1 ||\n      !!scrollInterpolator ||\n      !!slideInterpolatedStyle ||\n      this._shouldUseShiftLayout() ||\n      this._shouldUseStackLayout() ||\n      this._shouldUseTinderLayout()\n      );\n  }\n\n  _shouldUseShiftLayout () {\n      const { inactiveSlideShift, layout } = this.props;\n      return layout === 'default' && inactiveSlideShift !== 0;\n  }\n\n  _shouldUseStackLayout () {\n      return this.props.layout === 'stack';\n  }\n\n  _shouldUseTinderLayout () {\n      return this.props.layout === 'tinder';\n  }\n\n  _shouldRepositionScroll (index: number) {\n      const { data, enableSnap, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n      if (\n          !enableSnap ||\n      !dataLength ||\n      !this._enableLoop() ||\n      (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)\n      ) {\n          return false;\n      }\n      return true;\n  }\n\n  _roundNumber (num: number, decimals = 1) {\n      // https://stackoverflow.com/a/41716722/\n      const rounder = Math.pow(10, decimals);\n      return Math.round((num + Number.EPSILON) * rounder) / rounder;\n  }\n\n  _isMultiple (x: number, y: number) {\n      // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/\n      // Required because Android viewport size can return pretty complicated decimals numbers\n      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);\n  }\n\n  _getCustomData (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return [];\n      }\n\n      if (!this._enableLoop()) {\n          return data;\n      }\n\n      let previousItems = [];\n      let nextItems = [];\n\n      if (loopClonesPerSide > dataLength) {\n          const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n          const remainder = loopClonesPerSide % dataLength;\n\n          for (let i = 0; i < dataMultiplier; i++) {\n              previousItems.push(...data);\n              nextItems.push(...data);\n          }\n\n          previousItems.unshift(...data.slice(-remainder));\n          nextItems.push(...data.slice(0, remainder));\n      } else {\n          previousItems = data.slice(-loopClonesPerSide);\n          nextItems = data.slice(0, loopClonesPerSide);\n      }\n\n      return previousItems.concat(data, nextItems);\n  }\n\n  _getCustomDataLength (props: CarouselProps<TData> = this.props) {\n      const { data, loopClonesPerSide } = props;\n      const dataLength = data && data.length;\n\n      if (!dataLength) {\n          return 0;\n      }\n\n      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n  }\n\n  _getCustomIndex (index: number, props: CarouselProps<TData> = this.props) {\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || typeof index === 'undefined') {\n          return 0;\n      }\n\n      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n  }\n\n  _getDataIndex (index: number) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (!this._enableLoop() || !dataLength) {\n          return index;\n      }\n\n      if (index >= dataLength + loopClonesPerSide) {\n          return loopClonesPerSide > dataLength ?\n              (index - loopClonesPerSide) % dataLength :\n              index - dataLength - loopClonesPerSide;\n      } else if (index < loopClonesPerSide) {\n      // TODO: is there a simpler way of determining the interpolated index?\n          if (loopClonesPerSide > dataLength) {\n              const baseDataIndexes = [];\n              const dataIndexes = [];\n              const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n              const remainder = loopClonesPerSide % dataLength;\n\n              for (let i = 0; i < dataLength; i++) {\n                  baseDataIndexes.push(i);\n              }\n\n              for (let j = 0; j < dataMultiplier; j++) {\n                  dataIndexes.push(...baseDataIndexes);\n              }\n\n              dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n              return dataIndexes[index];\n          } else {\n              return index + dataLength - loopClonesPerSide;\n          }\n      } else {\n          return index - loopClonesPerSide;\n      }\n  }\n\n  // Used with `snapToItem()` and 'PaginationDot'\n  _getPositionIndex (index: number) {\n      const { loop, loopClonesPerSide } = this.props;\n      return loop ? index + loopClonesPerSide : index;\n  }\n\n  _getSnapOffsets (props: CarouselProps<TData> = this.props) {\n      const offset = this._getItemMainDimension();\n      return [...Array(this._getCustomDataLength(props))].map((_, i) => {\n          return i * offset;\n      });\n  }\n\n  _getFirstItem (index: number, props: CarouselProps<TData> = this.props) {\n      const { loopClonesPerSide } = props;\n      const itemsLength = this._getCustomDataLength(props);\n\n      if (!itemsLength || index > itemsLength - 1 || index < 0) {\n          return 0;\n      }\n\n      return this._enableLoop() ? index + loopClonesPerSide : index;\n  }\n\n  _getWrappedRef () {\n      // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component\n      if (\n          this._carouselRef &&\n      ((this._needsScrollView() &&\n        (this._carouselRef as ScrollView).scrollTo) ||\n        (!this._needsScrollView() &&\n          (this._carouselRef as FlatList).scrollToOffset))\n      ) {\n          return this._carouselRef;\n      }\n      // https://github.com/facebook/react-native/issues/10635\n      // https://stackoverflow.com/a/48786374/8412141\n      return (\n          this._carouselRef &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode &&\n      // @ts-expect-error This is for before 0.62\n      this._carouselRef.getNode()\n      );\n  }\n\n  _getScrollEnabled () {\n      return this._scrollEnabled;\n  }\n\n  _setScrollEnabled (scrollEnabled = true) {\n      const wrappedRef = this._getWrappedRef();\n\n      if (!wrappedRef || !wrappedRef.setNativeProps) {\n          return;\n      }\n\n      // 'setNativeProps()' is used instead of 'setState()' because the latter\n      // really takes a toll on Android behavior when momentum is disabled\n      wrappedRef.setNativeProps({ scrollEnabled });\n      this._scrollEnabled = scrollEnabled;\n  }\n\n  _getItemMainDimension () {\n      return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;\n  }\n\n  _getItemScrollOffset (index: number) {\n      return (\n          this._positions && this._positions[index] && this._positions[index].start\n      );\n  }\n\n  _getItemLayout (_: TData[], index: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      return {\n          index,\n          length: itemMainDimension,\n          offset: itemMainDimension * index // + this._getContainerInnerMargin()\n      };\n  }\n\n  // This will allow us to have a proper zIndex even with a FlatList\n  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165\n  _getCellRendererComponent ({\n      children,\n      index,\n      style,\n      ...props\n  }: PropsWithChildren<{ index: number; style: StyleProp<ViewStyle> }>) {\n      const cellStyle = [\n          style,\n          !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}\n      ];\n\n      return (\n          <View style={cellStyle} key={index} {...props}>\n              {children}\n          </View>\n      );\n  }\n\n  _getKeyExtractor (_: TData, index: number) {\n      return this._needsScrollView() ?\n          `scrollview-item-${index}` :\n          `flatlist-item-${index}`;\n  }\n\n  _getScrollOffset (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { vertical } = this.props;\n      return (\n          (event &&\n        event.nativeEvent &&\n        event.nativeEvent.contentOffset &&\n        event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) ||\n      0\n      );\n  }\n\n  _getContainerInnerMargin (opposite = false) {\n      const { activeSlideAlignment } = this.props;\n\n      if (\n          (activeSlideAlignment === 'start' && !opposite) ||\n      (activeSlideAlignment === 'end' && opposite)\n      ) {\n          return 0;\n      } else if (\n          (activeSlideAlignment === 'end' && !opposite) ||\n      (activeSlideAlignment === 'start' && opposite)\n      ) {\n          return this.props.vertical ?\n              this.props.sliderHeight - this.props.itemHeight :\n              this.props.sliderWidth - this.props.itemWidth;\n      } else {\n          return this.props.vertical ?\n              (this.props.sliderHeight - this.props.itemHeight) / 2 :\n              (this.props.sliderWidth - this.props.itemWidth) / 2;\n      }\n  }\n\n  _getActiveSlideOffset () {\n      const { activeSlideOffset } = this.props;\n      const itemMainDimension = this._getItemMainDimension();\n      const minOffset = 10;\n      // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide\n      return itemMainDimension / 2 - activeSlideOffset >= minOffset ?\n          activeSlideOffset :\n          minOffset;\n  }\n\n  _getActiveItem (offset: number) {\n      const itemMainDimension = this._getItemMainDimension();\n      const center = offset + itemMainDimension / 2;\n      const activeSlideOffset = this._getActiveSlideOffset();\n      const lastIndex = this._positions.length - 1;\n      let itemIndex;\n\n      if (offset <= 0) {\n          return 0;\n      }\n\n      if (\n          this._positions[lastIndex] &&\n      offset >= this._positions[lastIndex].start\n      ) {\n          return lastIndex;\n      }\n\n      for (let i = 0; i < this._positions.length; i++) {\n          const { start, end } = this._positions[i];\n          if (\n              center + activeSlideOffset >= start &&\n        center - activeSlideOffset <= end\n          ) {\n              itemIndex = i;\n              break;\n          }\n      }\n\n      return itemIndex || 0;\n  }\n\n  _getSlideInterpolatedStyle (index: number, animatedValue: Animated.AnimatedInterpolation) {\n      const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n      if (slideInterpolatedStyle) {\n          return slideInterpolatedStyle(index, animatedValue, this.props);\n      } else if (this._shouldUseTinderLayout()) {\n          return tinderAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseStackLayout()) {\n          return stackAnimatedStyles(\n              index,\n              animatedValue,\n              this.props,\n              layoutCardOffset\n          );\n      } else if (this._shouldUseShiftLayout()) {\n          return shiftAnimatedStyles(index, animatedValue, this.props);\n      } else {\n          return defaultAnimatedStyles(index, animatedValue, this.props);\n      }\n  }\n\n  _initPositionsAndInterpolators (props: CarouselProps<TData> = this.props) {\n      const { data, scrollInterpolator } = props;\n      const itemMainDimension = this._getItemMainDimension();\n\n      if (!data || !data.length) {\n          return;\n      }\n\n      const interpolators: Animated.AnimatedInterpolation[] = [];\n      this._positions = [];\n\n      this._getCustomData(props).forEach((_itemData, index) => {\n          const _index = this._getCustomIndex(index, props);\n          let animatedValue: Animated.AnimatedInterpolation;\n\n          this._positions[index] = {\n              start: index * itemMainDimension,\n              end: index * itemMainDimension + itemMainDimension\n          };\n\n          if (!this._shouldAnimateSlides(props) || !this._scrollPos) {\n              animatedValue = new Animated.Value(1);\n          } else {\n              let interpolator;\n\n              if (scrollInterpolator) {\n                  interpolator = scrollInterpolator(_index, props);\n              } else if (this._shouldUseStackLayout()) {\n                  interpolator = stackScrollInterpolator(_index, props);\n              } else if (this._shouldUseTinderLayout()) {\n                  interpolator = tinderScrollInterpolator(_index, props);\n              }\n\n              if (\n                  !interpolator ||\n          !interpolator.inputRange ||\n          !interpolator.outputRange\n              ) {\n                  interpolator = defaultScrollInterpolator(_index, props);\n              }\n\n              animatedValue = this._scrollPos.interpolate({\n                  ...interpolator,\n                  extrapolate: 'clamp'\n              });\n          }\n\n          interpolators.push(animatedValue);\n      });\n\n      this.setState({ interpolators });\n  }\n\n  _hackActiveSlideAnimation (index: number, scrollValue = 1) {\n      const offset = this._getItemScrollOffset(index);\n\n      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {\n          return;\n      }\n\n      const multiplier = this._currentScrollOffset === 0 ? 1 : -1;\n      const scrollDelta = scrollValue * multiplier;\n\n      this._scrollTo({ offset: offset + scrollDelta, animated: false });\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._hackSlideAnimationTimeout);\n      this._hackSlideAnimationTimeout = setTimeout(() => {\n          this._scrollTo({ offset, animated: false });\n      }, 1); // works randomly when set to '0'\n  }\n\n  _repositionScroll (index: number, animated = false) {\n      const { data, loopClonesPerSide } = this.props;\n      const dataLength = data && data.length;\n\n      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {\n          return;\n      }\n\n      let repositionTo = index;\n\n      if (index >= dataLength + loopClonesPerSide) {\n          repositionTo = index - dataLength;\n      } else if (index < loopClonesPerSide) {\n          repositionTo = index + dataLength;\n      }\n\n      this._snapToItem(repositionTo, animated, false);\n  }\n\n  _scrollTo ({\n      offset,\n      index,\n      animated = true\n  }: {\n    offset: number;\n    index?: number;\n    animated: boolean;\n  }) {\n      const { vertical } = this.props;\n      const wrappedRef = this._getWrappedRef();\n      if (\n          !this._mounted ||\n      !wrappedRef ||\n      (typeof offset === 'undefined' && typeof index === 'undefined')\n      ) {\n          return;\n      }\n\n      let scrollToOffset;\n      if (typeof index !== 'undefined') {\n          scrollToOffset = this._getItemScrollOffset(index);\n      } else {\n          scrollToOffset = offset;\n      }\n\n      if (typeof scrollToOffset === 'undefined') {\n          return;\n      }\n\n      const options = this._needsScrollView() ?\n          {\n              x: vertical ? 0 : offset,\n              y: vertical ? offset : 0,\n              animated\n          } :\n          {\n              offset,\n              animated\n          };\n\n      if (this._needsScrollView()) {\n          wrappedRef.scrollTo(options);\n      } else {\n          wrappedRef.scrollToOffset(options);\n      }\n  }\n\n  _onTouchStart (event: GestureResponderEvent) {\n      const { onTouchStart } = this.props;\n\n      // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n      if (this._getScrollEnabled() !== false && this._autoplaying) {\n          this.pauseAutoPlay();\n      }\n\n      onTouchStart && onTouchStart(event);\n  }\n\n  _onTouchEnd (event: GestureResponderEvent) {\n      const { onTouchEnd } = this.props;\n\n      if (\n          this._getScrollEnabled() !== false &&\n      this._autoplay &&\n      !this._autoplaying\n      ) {\n      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()\n          this.startAutoplay();\n      }\n\n      onTouchEnd && onTouchEnd(event);\n  }\n\n  _onScroll (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { onScroll, onScrollIndexChanged } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n\n      this._currentScrollOffset = scrollOffset;\n\n      if (nextActiveItem !== this._onScrollActiveItem) {\n          this._onScrollActiveItem = nextActiveItem;\n          onScrollIndexChanged &&\n        onScrollIndexChanged(this._getDataIndex(nextActiveItem));\n      }\n\n      if (typeof onScroll === 'function' && event) {\n          onScroll(event);\n      }\n  }\n\n  _onMomentumScrollEnd (event: NativeSyntheticEvent<NativeScrollEvent>) {\n      const { autoplayDelay, onMomentumScrollEnd, onSnapToItem } = this.props;\n      const scrollOffset = event ?\n          this._getScrollOffset(event) :\n          this._currentScrollOffset;\n      const nextActiveItem = this._getActiveItem(scrollOffset);\n      const hasSnapped = this._isMultiple(\n          scrollOffset,\n          this.props.vertical ? this.props.itemHeight : this.props.itemWidth\n      );\n\n      // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:\n      // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated\n      // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically\n      if (nextActiveItem !== this._activeItem) {\n          this._activeItem = nextActiveItem;\n          onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));\n\n          if (hasSnapped) {\n              this._repositionScroll(nextActiveItem);\n          }\n      }\n\n      onMomentumScrollEnd && onMomentumScrollEnd(event);\n\n      // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n      // https://github.com/facebook/react-native/issues/9439\n      if (IS_ANDROID && this._autoplay && !this._autoplaying) {\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n          clearTimeout(this._enableAutoplayTimeout);\n          this._enableAutoplayTimeout = setTimeout(() => {\n              this.startAutoplay();\n          }, autoplayDelay);\n      }\n  }\n\n  _onLayout (event: LayoutChangeEvent) {\n      const { onLayout } = this.props;\n\n      // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n      if (this._onLayoutInitDone) {\n          this._initPositionsAndInterpolators();\n          this._snapToItem(this._activeItem, false, false, true);\n      } else {\n          this._onLayoutInitDone = true;\n      }\n\n      onLayout && onLayout(event);\n  }\n\n  _snapToItem (\n      index: number,\n      animated = true,\n      fireCallback = true,\n      forceScrollTo = false\n  ) {\n      const { onSnapToItem } = this.props;\n      const itemsLength = this._getCustomDataLength();\n      const wrappedRef = this._getWrappedRef();\n\n      if (!itemsLength || !wrappedRef) {\n          return;\n      }\n\n      if (!index || index < 0) {\n          index = 0;\n      } else if (itemsLength > 0 && index >= itemsLength) {\n          index = itemsLength - 1;\n      }\n\n      if (index === this._activeItem && !forceScrollTo) {\n          return;\n      }\n\n      const offset = this._getItemScrollOffset(index);\n\n      if (offset === undefined) {\n          return;\n      }\n\n      this._scrollTo({ offset, animated });\n\n      // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated\n      // so we need to trigger the callback manually\n      // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically\n      // Therefore everything critical needs to be manually called here as well, even though the timing might be off\n      const requiresManualTrigger = !animated || IS_ANDROID;\n      if (requiresManualTrigger) {\n          this._activeItem = index;\n\n          if (fireCallback) {\n              onSnapToItem && onSnapToItem(this._getDataIndex(index));\n          }\n\n          // Repositioning on Android\n          if (IS_ANDROID && this._shouldRepositionScroll(index)) {\n              if (animated) {\n                  this._androidRepositioningTimeout = setTimeout(() => {\n                      // Without scroll animation, the behavior is completely buggy...\n                      this._repositionScroll(index, true);\n                  }, 400); // Approximate scroll duration on Android\n              } else {\n                  this._repositionScroll(index);\n              }\n          }\n      }\n  }\n\n  startAutoplay () {\n      const { autoplayInterval, autoplayDelay } = this.props;\n      this._autoplay = true;\n\n      if (this._autoplaying) {\n          return;\n      }\n\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      this._autoplayTimeout = setTimeout(() => {\n          this._autoplaying = true;\n          this._autoplayInterval = setInterval(() => {\n              if (this._autoplaying) {\n                  this.snapToNext();\n              }\n          }, autoplayInterval);\n      }, autoplayDelay);\n  }\n\n  pauseAutoPlay () {\n      this._autoplaying = false;\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._autoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearTimeout(this._enableAutoplayTimeout);\n      // @ts-expect-error setTimeout / clearTiemout is buggy :/\n      clearInterval(this._autoplayInterval);\n  }\n\n  stopAutoplay () {\n      this._autoplay = false;\n      this.pauseAutoPlay();\n  }\n\n  snapToItem (index: number, animated = true, fireCallback = true) {\n      if (!index || index < 0) {\n          index = 0;\n      }\n\n      const positionIndex = this._getPositionIndex(index);\n\n      if (positionIndex === this._activeItem) {\n          return;\n      }\n\n      this._snapToItem(positionIndex, animated, fireCallback);\n  }\n\n  snapToNext (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem + 1;\n      if (newIndex > itemsLength - 1) {\n          newIndex = 0;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  snapToPrev (animated = true, fireCallback = true) {\n      const itemsLength = this._getCustomDataLength();\n\n      let newIndex = this._activeItem - 1;\n      if (newIndex < 0) {\n          newIndex = itemsLength - 1;\n      }\n      this._snapToItem(newIndex, animated, fireCallback);\n  }\n\n  // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n  triggerRenderingHack (offset = 1) {\n      this._hackActiveSlideAnimation(this._activeItem, offset);\n  }\n\n  _renderItem ({ item, index }: { item: TData; index: number }) {\n      const { interpolators } = this.state;\n      const {\n          keyExtractor,\n          slideStyle\n      } = this.props;\n      const animatedValue = interpolators && interpolators[index];\n\n      if (typeof animatedValue === 'undefined') {\n          return null;\n      }\n\n      const animate = this._shouldAnimateSlides();\n      const Component = animate ? Animated.View : View;\n      const animatedStyle = animate ?\n          this._getSlideInterpolatedStyle(index, animatedValue) :\n          {};\n      const dataIndex = this._getDataIndex(index);\n\n      const mainDimension = this.props.vertical ?\n          { height: this.props.itemHeight } :\n          { width: this.props.itemWidth };\n      const specificProps = this._needsScrollView() ?\n          {\n              key: keyExtractor ?\n                  keyExtractor(item, index) :\n                  this._getKeyExtractor(item, index)\n          } :\n          {};\n\n      return (\n          <Component\n            style={[mainDimension, slideStyle, animatedStyle]}\n            pointerEvents='box-none'\n            {...specificProps}\n          >\n              {this.props.vertical ? this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: this.props.vertical,\n                  sliderHeight: this.props.sliderHeight,\n                  itemHeight: this.props.itemHeight\n              }) : this.props.renderItem({ item, index, dataIndex }, {\n                  scrollPosition: this._scrollPos,\n                  carouselRef: this._carouselRef,\n                  vertical: !!this.props.vertical,\n                  sliderWidth: this.props.sliderWidth,\n                  itemWidth: this.props.itemWidth\n              })}\n          </Component>\n      );\n  }\n\n  _getComponentOverridableProps () {\n      const { hideCarousel } = this.state;\n      const { loopClonesPerSide } = this.props;\n      const visibleItems =\n      Math.ceil(\n          this.props.vertical ?\n              this.props.sliderHeight / this.props.itemHeight :\n              this.props.sliderWidth / this.props.itemWidth\n      ) + 1;\n      const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n      const initialNumToRender = visibleItems + initialNumPerSide * 2;\n      const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;\n      const windowSize = maxToRenderPerBatch;\n\n      const specificProps = !this._needsScrollView() ?\n          {\n              initialNumToRender,\n              maxToRenderPerBatch,\n              windowSize\n          // updateCellsBatchingPeriod\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          automaticallyAdjustContentInsets: false,\n          decelerationRate: 'fast' as const,\n          directionalLockEnabled: true,\n          disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily\n          inverted: this._needsRTLAdaptations(),\n          overScrollMode: 'never' as const,\n          pinchGestureEnabled: false,\n          pointerEvents: hideCarousel ? 'none' as const : 'auto' as const,\n          // removeClippedSubviews: !this._needsScrollView(),\n          // renderToHardwareTextureAndroid: true,\n          scrollsToTop: false,\n          showsHorizontalScrollIndicator: false,\n          showsVerticalScrollIndicator: false\n      };\n  }\n\n  _getComponentStaticProps () {\n      const { hideCarousel } = this.state;\n      const {\n          activeSlideAlignment,\n          CellRendererComponent,\n          containerCustomStyle,\n          contentContainerCustomStyle,\n          firstItem,\n          getItemLayout,\n          keyExtractor,\n          style,\n          useExperimentalSnap\n      } = this.props;\n\n      const containerStyle = [\n      // { overflow: 'hidden' },\n          containerCustomStyle || style || {},\n          hideCarousel ? { opacity: 0 } : {},\n          this.props.vertical ?\n              { height: this.props.sliderHeight, flexDirection: 'column' as const } : // LTR hack; see https://github.com/facebook/react-native/issues/11960\n          // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n              {\n                  width: this.props.sliderWidth,\n                  flexDirection: this._needsRTLAdaptations() ? 'row-reverse' as const : 'row' as const\n              }\n      ];\n\n      const innerMarginStyle = this.props.vertical ?\n          {\n              paddingTop: this._getContainerInnerMargin(),\n              paddingBottom: this._getContainerInnerMargin(true)\n          } :\n          {\n              paddingLeft: this._getContainerInnerMargin(),\n              paddingRight: this._getContainerInnerMargin(true)\n          };\n\n      const contentContainerStyle = [\n          !useExperimentalSnap ? innerMarginStyle : {},\n          contentContainerCustomStyle || {}\n      ];\n\n      // WARNING: `snapToAlignment` won't work as intended because of the following:\n      // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755\n      // - Snap points will be off\n      // - Slide animations will be off\n      // - Last items won't be set as active (no `onSnapToItem` callback)\n      // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being\n      const snapProps = useExperimentalSnap ?\n          {\n          // disableIntervalMomentum: true, // Slide ± one item at a time\n              snapToAlignment: activeSlideAlignment,\n              snapToInterval: this._getItemMainDimension()\n          } :\n          {\n              snapToOffsets: this._getSnapOffsets()\n          };\n\n      // Flatlist specifics\n      const specificProps = !this._needsScrollView() ?\n          {\n              CellRendererComponent:\n            CellRendererComponent || this._getCellRendererComponent,\n              getItemLayout: getItemLayout || this._getItemLayout,\n              initialScrollIndex: this._getFirstItem(firstItem),\n              keyExtractor: keyExtractor || this._getKeyExtractor,\n              numColumns: 1,\n              renderItem: this._renderItem\n          } :\n          {};\n\n      return {\n          ...specificProps,\n          ...snapProps,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          ref: (c: any) => {\n              this._carouselRef = c as FlatList<TData> | ScrollView;\n          },\n          contentContainerStyle: contentContainerStyle,\n          data: this._getCustomData(),\n          horizontal: !this.props.vertical,\n          scrollEventThrottle: 1,\n          style: containerStyle,\n          onLayout: this._onLayout,\n          onMomentumScrollEnd: this._onMomentumScrollEnd,\n          onScroll: this._onScrollHandler,\n          onTouchStart: this._onTouchStart,\n          onTouchEnd: this._onTouchEnd\n      };\n  }\n\n  render () {\n      const { data, renderItem, useScrollView } = this.props;\n\n      if (!data || !renderItem) {\n          return null;\n      }\n\n      const props = {\n          ...this._getComponentOverridableProps(),\n          ...this.props,\n          ...this._getComponentStaticProps()\n      };\n\n      const ScrollViewComponent =\n      typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;\n\n      return this._needsScrollView() || !Animated.FlatList ? (\n          <ScrollViewComponent {...props}>\n              {this._getCustomData().map((item, index) => {\n                  return this._renderItem({ item, index });\n              })}\n          </ScrollViewComponent>\n      ) : (\n          // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between\n          // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.\n          <Animated.FlatList {...props} />\n      );\n  }\n}\n\nexport default Carousel;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/carousel/types.js b/node_modules/react-native-snap-carousel/lib/module/carousel/types.js
deleted file mode 100644
index 63b2c4c..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/carousel/types.js
+++ /dev/null
@@ -1,2 +0,0 @@
-
-//# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/carousel/types.js.map b/node_modules/react-native-snap-carousel/lib/module/carousel/types.js.map
deleted file mode 100644
index 9ffd4b2..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/carousel/types.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/index.js b/node_modules/react-native-snap-carousel/lib/module/index.js
deleted file mode 100644
index 2f8f43d..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/index.js
+++ /dev/null
@@ -1,6 +0,0 @@
-import Carousel from './carousel/Carousel';
-import Pagination from './pagination/Pagination';
-import ParallaxImage, { ParallaxImageStatus } from './parallaximage/ParallaxImage';
-import { getInputRangeFromIndexes } from './utils/animations';
-export { Carousel as default, Carousel, Pagination, ParallaxImage, ParallaxImageStatus, getInputRangeFromIndexes };
-//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/index.js.map b/node_modules/react-native-snap-carousel/lib/module/index.js.map
deleted file mode 100644
index 6fed10e..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/index.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["index.ts"],"names":["Carousel","Pagination","ParallaxImage","ParallaxImageStatus","getInputRangeFromIndexes","default"],"mappings":"AAAA,OAAOA,QAAP,MAAqB,qBAArB;AACA,OAAOC,UAAP,MAAuB,yBAAvB;AACA,OAAOC,aAAP,IAAwBC,mBAAxB,QAAmD,+BAAnD;AACA,SAASC,wBAAT,QAAyC,oBAAzC;AAEA,SACIJ,QAAQ,IAAIK,OADhB,EAEIL,QAFJ,EAGIC,UAHJ,EAIIC,aAJJ,EAKIC,mBALJ,EAMIC,wBANJ","sourcesContent":["import Carousel from './carousel/Carousel';\nimport Pagination from './pagination/Pagination';\nimport ParallaxImage, { ParallaxImageStatus } from './parallaximage/ParallaxImage';\nimport { getInputRangeFromIndexes } from './utils/animations';\n\nexport {\n    Carousel as default,\n    Carousel,\n    Pagination,\n    ParallaxImage,\n    ParallaxImageStatus,\n    getInputRangeFromIndexes\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js b/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js
deleted file mode 100644
index 95216a5..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js
+++ /dev/null
@@ -1,129 +0,0 @@
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-import React, { PureComponent } from 'react';
-import { I18nManager, Platform, View } from 'react-native';
-import PaginationDot from './PaginationDot';
-import styles from './Pagination.style';
-const IS_IOS = Platform.OS === 'ios';
-const IS_RTL = I18nManager.isRTL;
-export default class Pagination extends PureComponent {
-  constructor(props) {
-    super(props); // Warnings
-
-    if (props.dotColor && !props.inactiveDotColor || !props.dotColor && props.inactiveDotColor) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You need to specify both `dotColor` and `inactiveDotColor`');
-    }
-
-    if (props.dotElement && !props.inactiveDotElement || !props.dotElement && props.inactiveDotElement) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You need to specify both `dotElement` and `inactiveDotElement`');
-    }
-
-    if (props.tappableDots && props.carouselRef === undefined) {
-      console.warn('react-native-snap-carousel | Pagination: ' + 'You must specify prop `carouselRef` when setting `tappableDots` to `true`');
-    }
-  }
-
-  _needsRTLAdaptations() {
-    const {
-      vertical
-    } = this.props;
-    return IS_RTL && !IS_IOS && !vertical;
-  }
-
-  get _activeDotIndex() {
-    const {
-      activeDotIndex,
-      dotsLength
-    } = this.props;
-    return this._needsRTLAdaptations() ? dotsLength - activeDotIndex - 1 : activeDotIndex;
-  }
-
-  get dots() {
-    const {
-      activeOpacity,
-      carouselRef,
-      dotsLength,
-      dotColor,
-      dotContainerStyle,
-      dotElement,
-      dotStyle,
-      inactiveDotColor,
-      inactiveDotElement,
-      inactiveDotOpacity,
-      inactiveDotScale,
-      inactiveDotStyle,
-      renderDots,
-      tappableDots,
-      animatedDuration,
-      animatedFriction,
-      animatedTension,
-      delayPressInDot
-    } = this.props;
-
-    if (renderDots) {
-      return renderDots(this._activeDotIndex, dotsLength, this);
-    }
-
-    const DefaultDot = /*#__PURE__*/React.createElement(PaginationDot, {
-      carouselRef: carouselRef,
-      tappable: tappableDots && typeof carouselRef !== 'undefined',
-      activeOpacity: activeOpacity,
-      color: dotColor,
-      containerStyle: dotContainerStyle,
-      style: dotStyle,
-      inactiveColor: inactiveDotColor,
-      inactiveOpacity: inactiveDotOpacity,
-      inactiveScale: inactiveDotScale,
-      inactiveStyle: inactiveDotStyle,
-      animatedDuration: animatedDuration,
-      animatedFriction: animatedFriction,
-      animatedTension: animatedTension,
-      delayPressInDot: delayPressInDot
-    });
-    const dots = [...Array(dotsLength).keys()].map(i => {
-      const isActive = i === this._activeDotIndex;
-      return /*#__PURE__*/React.cloneElement((isActive ? dotElement : inactiveDotElement) || DefaultDot, {
-        key: "pagination-dot-".concat(i),
-        active: isActive,
-        index: i
-      });
-    });
-    return dots;
-  }
-
-  render() {
-    const {
-      dotsLength,
-      containerStyle,
-      vertical,
-      accessibilityLabel
-    } = this.props;
-
-    if (!dotsLength || dotsLength < 2) {
-      return false;
-    }
-
-    const style = [styles.sliderPagination, {
-      flexDirection: vertical ? 'column' : this._needsRTLAdaptations() ? 'row-reverse' : 'row'
-    }, containerStyle || {}];
-    return /*#__PURE__*/React.createElement(View, {
-      pointerEvents: "box-none",
-      style: style,
-      accessible: !!accessibilityLabel,
-      accessibilityLabel: accessibilityLabel
-    }, this.dots);
-  }
-
-}
-
-_defineProperty(Pagination, "defaultProps", {
-  inactiveDotOpacity: 0.5,
-  inactiveDotScale: 0.5,
-  tappableDots: false,
-  vertical: false,
-  animatedDuration: 250,
-  animatedFriction: 4,
-  animatedTension: 50,
-  delayPressInDot: 0
-});
-//# sourceMappingURL=Pagination.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js.map b/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js.map
deleted file mode 100644
index 7950bb4..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Pagination.tsx"],"names":["React","PureComponent","I18nManager","Platform","View","PaginationDot","styles","IS_IOS","OS","IS_RTL","isRTL","Pagination","constructor","props","dotColor","inactiveDotColor","console","warn","dotElement","inactiveDotElement","tappableDots","carouselRef","undefined","_needsRTLAdaptations","vertical","_activeDotIndex","activeDotIndex","dotsLength","dots","activeOpacity","dotContainerStyle","dotStyle","inactiveDotOpacity","inactiveDotScale","inactiveDotStyle","renderDots","animatedDuration","animatedFriction","animatedTension","delayPressInDot","DefaultDot","Array","keys","map","i","isActive","cloneElement","key","active","index","render","containerStyle","accessibilityLabel","style","sliderPagination","flexDirection"],"mappings":"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","sourcesContent":["import React, { PureComponent, ReactElement } from 'react';\nimport {\n    I18nManager,\n    Platform,\n    View,\n    StyleProp,\n    ViewStyle\n} from 'react-native';\nimport PaginationDot from './PaginationDot';\nimport styles from './Pagination.style';\nimport type Carousel from 'src/carousel/Carousel';\n\nconst IS_IOS = Platform.OS === 'ios';\nconst IS_RTL = I18nManager.isRTL;\n\ntype PaginationProps<TData> = {\n  activeDotIndex: number;\n  dotsLength: number;\n  activeOpacity?: number;\n  carouselRef?: Carousel<TData> | null;\n  containerStyle?: StyleProp<ViewStyle>;\n  dotColor?: string;\n  dotContainerStyle?: StyleProp<ViewStyle>;\n  dotElement?: ReactElement;\n  dotStyle?: StyleProp<ViewStyle>;\n  inactiveDotColor?: string;\n  inactiveDotElement?: ReactElement;\n  inactiveDotOpacity: number;\n  inactiveDotScale: number;\n  inactiveDotStyle?: StyleProp<ViewStyle>;\n  renderDots?: (\n    activeIndex: number,\n    length: number,\n    context: Pagination<TData>\n  ) => ReactElement;\n  tappableDots: boolean;\n  vertical: boolean;\n  accessibilityLabel?: string;\n  animatedDuration: number;\n  animatedFriction: number;\n  animatedTension: number;\n  delayPressInDot: number;\n};\n\nexport default class Pagination<TData> extends PureComponent<PaginationProps<TData>> {\n  static defaultProps = {\n      inactiveDotOpacity: 0.5,\n      inactiveDotScale: 0.5,\n      tappableDots: false,\n      vertical: false,\n      animatedDuration: 250,\n      animatedFriction: 4,\n      animatedTension: 50,\n      delayPressInDot: 0\n  };\n\n  constructor (props: PaginationProps<TData>) {\n      super(props);\n\n      // Warnings\n      if (\n          (props.dotColor && !props.inactiveDotColor) ||\n      (!props.dotColor && props.inactiveDotColor)\n      ) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You need to specify both `dotColor` and `inactiveDotColor`'\n          );\n      }\n      if (\n          (props.dotElement && !props.inactiveDotElement) ||\n      (!props.dotElement && props.inactiveDotElement)\n      ) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You need to specify both `dotElement` and `inactiveDotElement`'\n          );\n      }\n      if (props.tappableDots && props.carouselRef === undefined) {\n          console.warn(\n              'react-native-snap-carousel | Pagination: ' +\n          'You must specify prop `carouselRef` when setting `tappableDots` to `true`'\n          );\n      }\n  }\n\n  _needsRTLAdaptations () {\n      const { vertical } = this.props;\n      return IS_RTL && !IS_IOS && !vertical;\n  }\n\n  get _activeDotIndex () {\n      const { activeDotIndex, dotsLength } = this.props;\n      return this._needsRTLAdaptations() ?\n          dotsLength - activeDotIndex - 1 :\n          activeDotIndex;\n  }\n\n  get dots () {\n      const {\n          activeOpacity,\n          carouselRef,\n          dotsLength,\n          dotColor,\n          dotContainerStyle,\n          dotElement,\n          dotStyle,\n          inactiveDotColor,\n          inactiveDotElement,\n          inactiveDotOpacity,\n          inactiveDotScale,\n          inactiveDotStyle,\n          renderDots,\n          tappableDots,\n          animatedDuration,\n          animatedFriction,\n          animatedTension,\n          delayPressInDot\n      } = this.props;\n\n      if (renderDots) {\n          return renderDots(this._activeDotIndex, dotsLength, this);\n      }\n\n      const DefaultDot = (\n          <PaginationDot\n            carouselRef={carouselRef}\n            tappable={tappableDots && typeof carouselRef !== 'undefined'}\n            activeOpacity={activeOpacity}\n            color={dotColor}\n            containerStyle={dotContainerStyle}\n            style={dotStyle}\n            inactiveColor={inactiveDotColor}\n            inactiveOpacity={inactiveDotOpacity}\n            inactiveScale={inactiveDotScale}\n            inactiveStyle={inactiveDotStyle}\n            animatedDuration={animatedDuration}\n            animatedFriction={animatedFriction}\n            animatedTension={animatedTension}\n            delayPressInDot={delayPressInDot}\n          />\n      );\n\n      const dots = [...Array(dotsLength).keys()].map((i) => {\n          const isActive = i === this._activeDotIndex;\n          return React.cloneElement(\n              (isActive ? dotElement : inactiveDotElement) || DefaultDot,\n              {\n                  key: `pagination-dot-${i}`,\n                  active: isActive,\n                  index: i\n              }\n          );\n      });\n\n      return dots;\n  }\n\n  render () {\n      const {\n          dotsLength,\n          containerStyle,\n          vertical,\n          accessibilityLabel\n      } = this.props;\n\n      if (!dotsLength || dotsLength < 2) {\n          return false;\n      }\n\n      const style = [\n          styles.sliderPagination,\n          {\n              flexDirection: vertical ?\n                  ('column' as const) :\n                  this._needsRTLAdaptations() ?\n                      ('row-reverse' as const) :\n                      ('row' as const)\n          },\n          containerStyle || {}\n      ];\n\n      return (\n          <View\n            pointerEvents='box-none'\n            style={style}\n            accessible={!!accessibilityLabel}\n            accessibilityLabel={accessibilityLabel}\n          >\n              {this.dots}\n          </View>\n      );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js b/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js
deleted file mode 100644
index 7ce7154..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js
+++ /dev/null
@@ -1,23 +0,0 @@
-import { StyleSheet } from 'react-native';
-const DEFAULT_DOT_SIZE = 7;
-const DEFAULT_DOT_COLOR = 'rgba(0, 0, 0, 0.75)';
-export default StyleSheet.create({
-  sliderPagination: {
-    alignItems: 'center',
-    justifyContent: 'center',
-    paddingHorizontal: 20,
-    paddingVertical: 30
-  },
-  sliderPaginationDotContainer: {
-    alignItems: 'center',
-    justifyContent: 'center',
-    marginHorizontal: 8
-  },
-  sliderPaginationDot: {
-    width: DEFAULT_DOT_SIZE,
-    height: DEFAULT_DOT_SIZE,
-    borderRadius: DEFAULT_DOT_SIZE / 2,
-    backgroundColor: DEFAULT_DOT_COLOR
-  }
-});
-//# sourceMappingURL=Pagination.style.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js.map b/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js.map
deleted file mode 100644
index 8d22513..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/Pagination.style.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["Pagination.style.ts"],"names":["StyleSheet","DEFAULT_DOT_SIZE","DEFAULT_DOT_COLOR","create","sliderPagination","alignItems","justifyContent","paddingHorizontal","paddingVertical","sliderPaginationDotContainer","marginHorizontal","sliderPaginationDot","width","height","borderRadius","backgroundColor"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AAEA,MAAMC,gBAAgB,GAAG,CAAzB;AACA,MAAMC,iBAAiB,GAAG,qBAA1B;AAEA,eAAeF,UAAU,CAACG,MAAX,CAAkB;AAC7BC,EAAAA,gBAAgB,EAAE;AACdC,IAAAA,UAAU,EAAE,QADE;AAEdC,IAAAA,cAAc,EAAE,QAFF;AAGdC,IAAAA,iBAAiB,EAAE,EAHL;AAIdC,IAAAA,eAAe,EAAE;AAJH,GADW;AAO7BC,EAAAA,4BAA4B,EAAE;AAC1BJ,IAAAA,UAAU,EAAE,QADc;AAE1BC,IAAAA,cAAc,EAAE,QAFU;AAG1BI,IAAAA,gBAAgB,EAAE;AAHQ,GAPD;AAY7BC,EAAAA,mBAAmB,EAAE;AACjBC,IAAAA,KAAK,EAAEX,gBADU;AAEjBY,IAAAA,MAAM,EAAEZ,gBAFS;AAGjBa,IAAAA,YAAY,EAAEb,gBAAgB,GAAG,CAHhB;AAIjBc,IAAAA,eAAe,EAAEb;AAJA;AAZQ,CAAlB,CAAf","sourcesContent":["import { StyleSheet } from 'react-native';\n\nconst DEFAULT_DOT_SIZE = 7;\nconst DEFAULT_DOT_COLOR = 'rgba(0, 0, 0, 0.75)';\n\nexport default StyleSheet.create({\n    sliderPagination: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingHorizontal: 20,\n        paddingVertical: 30\n    },\n    sliderPaginationDotContainer: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        marginHorizontal: 8\n    },\n    sliderPaginationDot: {\n        width: DEFAULT_DOT_SIZE,\n        height: DEFAULT_DOT_SIZE,\n        borderRadius: DEFAULT_DOT_SIZE / 2,\n        backgroundColor: DEFAULT_DOT_COLOR\n    }\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js b/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js
deleted file mode 100644
index 659e51e..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js
+++ /dev/null
@@ -1,132 +0,0 @@
-import React, { PureComponent } from 'react';
-import { Animated, Easing, TouchableOpacity } from 'react-native';
-import styles from './Pagination.style';
-export default class PaginationDot extends PureComponent {
-  constructor(props) {
-    super(props);
-    this.state = {
-      animColor: new Animated.Value(0),
-      animOpacity: new Animated.Value(0),
-      animTransform: new Animated.Value(0)
-    };
-  }
-
-  componentDidMount() {
-    if (this.props.active) {
-      this._animate(1);
-    }
-  }
-
-  componentDidUpdate(prevProps) {
-    if (prevProps.active !== this.props.active) {
-      this._animate(this.props.active ? 1 : 0);
-    }
-  }
-
-  _animate(toValue = 0) {
-    const {
-      animColor,
-      animOpacity,
-      animTransform
-    } = this.state;
-    const {
-      animatedDuration,
-      animatedFriction,
-      animatedTension
-    } = this.props;
-    const commonProperties = {
-      toValue,
-      isInteraction: false,
-      useNativeDriver: !this._shouldAnimateColor
-    };
-    const animations = [Animated.timing(animOpacity, {
-      easing: Easing.linear,
-      duration: animatedDuration,
-      ...commonProperties
-    }), Animated.spring(animTransform, {
-      friction: animatedFriction,
-      tension: animatedTension,
-      ...commonProperties
-    })];
-
-    if (this._shouldAnimateColor) {
-      animations.push(Animated.timing(animColor, {
-        easing: Easing.linear,
-        ...commonProperties
-      }));
-    }
-
-    Animated.parallel(animations).start();
-  }
-
-  get _shouldAnimateColor() {
-    const {
-      color,
-      inactiveColor
-    } = this.props;
-    return color && inactiveColor;
-  }
-
-  render() {
-    const {
-      animColor,
-      animOpacity,
-      animTransform
-    } = this.state;
-    const {
-      active,
-      activeOpacity,
-      carouselRef,
-      color,
-      containerStyle,
-      inactiveColor,
-      inactiveStyle,
-      inactiveOpacity,
-      inactiveScale,
-      index,
-      style,
-      tappable,
-      delayPressInDot
-    } = this.props;
-    const animatedStyle = {
-      opacity: animOpacity.interpolate({
-        inputRange: [0, 1],
-        outputRange: [inactiveOpacity, 1]
-      }),
-      transform: [{
-        scale: animTransform.interpolate({
-          inputRange: [0, 1],
-          outputRange: [inactiveScale, 1]
-        })
-      }]
-    };
-    const animatedColor = this._shouldAnimateColor && inactiveColor && color ? {
-      backgroundColor: animColor.interpolate({
-        inputRange: [0, 1],
-        outputRange: [inactiveColor, color]
-      })
-    } : {};
-    const dotContainerStyle = [styles.sliderPaginationDotContainer, containerStyle || {}];
-    const dotStyle = [styles.sliderPaginationDot, style || {}, !active && inactiveStyle || {}, animatedStyle, animatedColor];
-    const onPress = tappable && (!!index || index === 0) ? () => {
-      try {
-        const currentRef = carouselRef && 'current' in carouselRef ? carouselRef.current : carouselRef; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-
-        currentRef._snapToItem(currentRef._getPositionIndex(index));
-      } catch (error) {
-        console.warn('react-native-snap-carousel | Pagination: ' + '`carouselRef` has to be a Carousel ref.\n' + error);
-      }
-    } : undefined;
-    return /*#__PURE__*/React.createElement(TouchableOpacity, {
-      accessible: false,
-      style: dotContainerStyle,
-      activeOpacity: tappable ? activeOpacity : 1,
-      onPress: onPress,
-      delayPressIn: delayPressInDot
-    }, /*#__PURE__*/React.createElement(Animated.View, {
-      style: dotStyle
-    }));
-  }
-
-}
-//# sourceMappingURL=PaginationDot.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js.map b/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js.map
deleted file mode 100644
index 61a6d39..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/pagination/PaginationDot.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["PaginationDot.tsx"],"names":["React","PureComponent","Animated","Easing","TouchableOpacity","styles","PaginationDot","constructor","props","state","animColor","Value","animOpacity","animTransform","componentDidMount","active","_animate","componentDidUpdate","prevProps","toValue","animatedDuration","animatedFriction","animatedTension","commonProperties","isInteraction","useNativeDriver","_shouldAnimateColor","animations","timing","easing","linear","duration","spring","friction","tension","push","parallel","start","color","inactiveColor","render","activeOpacity","carouselRef","containerStyle","inactiveStyle","inactiveOpacity","inactiveScale","index","style","tappable","delayPressInDot","animatedStyle","opacity","interpolate","inputRange","outputRange","transform","scale","animatedColor","backgroundColor","dotContainerStyle","sliderPaginationDotContainer","dotStyle","sliderPaginationDot","onPress","currentRef","current","_snapToItem","_getPositionIndex","error","console","warn","undefined"],"mappings":"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","sourcesContent":["import React, { PureComponent, RefObject } from 'react';\nimport {\n    Animated,\n    Easing,\n    TouchableOpacity,\n    StyleProp,\n    ViewStyle\n} from 'react-native';\nimport styles from './Pagination.style';\nimport type Carousel from 'src/carousel/Carousel';\n\ntype PaginationDotProps<TData> = {\n  inactiveOpacity: number;\n  inactiveScale: number;\n  active?: boolean;\n  activeOpacity?: number;\n  animatedDuration?: number;\n  animatedFriction?: number;\n  animatedTension?: number;\n  carouselRef?: Carousel<TData> | RefObject<Carousel<TData>> | null;\n  color?: string;\n  containerStyle?: StyleProp<ViewStyle>;\n  delayPressInDot?: number;\n  inactiveColor?: string;\n  inactiveStyle?: StyleProp<ViewStyle>;\n  index?: number;\n  style?: StyleProp<ViewStyle>;\n  tappable?: boolean;\n};\n\ntype PaginationDotState = {\n  animColor: Animated.Value;\n  animOpacity: Animated.Value;\n  animTransform: Animated.Value;\n};\n\nexport default class PaginationDot<TData> extends PureComponent<\n  PaginationDotProps<TData>,\n  PaginationDotState\n> {\n    constructor (props: PaginationDotProps<TData>) {\n        super(props);\n        this.state = {\n            animColor: new Animated.Value(0),\n            animOpacity: new Animated.Value(0),\n            animTransform: new Animated.Value(0)\n        };\n    }\n\n    componentDidMount () {\n        if (this.props.active) {\n            this._animate(1);\n        }\n    }\n\n    componentDidUpdate (prevProps: PaginationDotProps<TData>) {\n        if (prevProps.active !== this.props.active) {\n            this._animate(this.props.active ? 1 : 0);\n        }\n    }\n\n    _animate (toValue = 0) {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const { animatedDuration, animatedFriction, animatedTension } = this.props;\n\n        const commonProperties = {\n            toValue,\n            isInteraction: false,\n            useNativeDriver: !this._shouldAnimateColor\n        };\n\n        const animations = [\n            Animated.timing(animOpacity, {\n                easing: Easing.linear,\n                duration: animatedDuration,\n                ...commonProperties\n            }),\n            Animated.spring(animTransform, {\n                friction: animatedFriction,\n                tension: animatedTension,\n                ...commonProperties\n            })\n        ];\n\n        if (this._shouldAnimateColor) {\n            animations.push(\n                Animated.timing(animColor, {\n                    easing: Easing.linear,\n                    ...commonProperties\n                })\n            );\n        }\n\n        Animated.parallel(animations).start();\n    }\n\n    get _shouldAnimateColor () {\n        const { color, inactiveColor } = this.props;\n        return color && inactiveColor;\n    }\n\n    render () {\n        const { animColor, animOpacity, animTransform } = this.state;\n        const {\n            active,\n            activeOpacity,\n            carouselRef,\n            color,\n            containerStyle,\n            inactiveColor,\n            inactiveStyle,\n            inactiveOpacity,\n            inactiveScale,\n            index,\n            style,\n            tappable,\n            delayPressInDot\n        } = this.props;\n\n        const animatedStyle = {\n            opacity: animOpacity.interpolate({\n                inputRange: [0, 1],\n                outputRange: [inactiveOpacity, 1]\n            }),\n            transform: [\n                {\n                    scale: animTransform.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: [inactiveScale, 1]\n                    })\n                }\n            ]\n        };\n        const animatedColor =\n      this._shouldAnimateColor && inactiveColor && color ?\n          {\n              backgroundColor: animColor.interpolate({\n                  inputRange: [0, 1],\n                  outputRange: [inactiveColor, color]\n              })\n          } :\n          {};\n\n        const dotContainerStyle = [\n            styles.sliderPaginationDotContainer,\n            containerStyle || {}\n        ];\n\n        const dotStyle = [\n            styles.sliderPaginationDot,\n            style || {},\n            (!active && inactiveStyle) || {},\n            animatedStyle,\n            animatedColor\n        ];\n\n        const onPress =\n      tappable && (!!index || index === 0) ?\n          () => {\n              try {\n                  const currentRef =\n                carouselRef && 'current' in carouselRef ?\n                    carouselRef.current :\n                    carouselRef;\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              currentRef!._snapToItem(currentRef!._getPositionIndex(index));\n              } catch (error) {\n                  console.warn(\n                      'react-native-snap-carousel | Pagination: ' +\n                  '`carouselRef` has to be a Carousel ref.\\n' +\n                  error\n                  );\n              }\n          } :\n          undefined;\n\n        return (\n            <TouchableOpacity\n              accessible={false}\n              style={dotContainerStyle}\n              activeOpacity={tappable ? activeOpacity : 1}\n              onPress={onPress}\n              delayPressIn={delayPressInDot}\n            >\n                <Animated.View style={dotStyle} />\n            </TouchableOpacity>\n        );\n    }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js b/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js
deleted file mode 100644
index d49762c..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js
+++ /dev/null
@@ -1,214 +0,0 @@
-function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
-
-function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
-
-// Parallax effect inspired by https://github.com/oblador/react-native-parallax/
-import React, { Component } from 'react';
-import { View, Animated, Easing, ActivityIndicator, findNodeHandle } from 'react-native';
-import styles from './ParallaxImage.style';
-export let ParallaxImageStatus;
-
-(function (ParallaxImageStatus) {
-  ParallaxImageStatus[ParallaxImageStatus["LOADING"] = 1] = "LOADING";
-  ParallaxImageStatus[ParallaxImageStatus["LOADED"] = 2] = "LOADED";
-  ParallaxImageStatus[ParallaxImageStatus["TRANSITION_FINISHED"] = 3] = "TRANSITION_FINISHED";
-  ParallaxImageStatus[ParallaxImageStatus["ERROR"] = 4] = "ERROR";
-})(ParallaxImageStatus || (ParallaxImageStatus = {}));
-
-export default class ParallaxImage extends Component {
-  constructor(props) {
-    super(props);
-
-    _defineProperty(this, "_container", void 0);
-
-    _defineProperty(this, "_mounted", void 0);
-
-    this.state = {
-      offset: 0,
-      width: 0,
-      height: 0,
-      status: ParallaxImageStatus.LOADING,
-      animOpacity: new Animated.Value(0)
-    };
-    this._onLoad = this._onLoad.bind(this);
-    this._onError = this._onError.bind(this);
-    this._measureLayout = this._measureLayout.bind(this);
-  }
-
-  setNativeProps(nativeProps) {
-    var _this$_container;
-
-    (_this$_container = this._container) === null || _this$_container === void 0 ? void 0 : _this$_container.setNativeProps(nativeProps);
-  }
-
-  componentDidMount() {
-    this._mounted = true;
-    setTimeout(() => {
-      this._measureLayout();
-    }, 0);
-  }
-
-  componentWillUnmount() {
-    this._mounted = false;
-  }
-
-  _measureLayout() {
-    if (this._container) {
-      const {
-        dimensions,
-        carouselRef
-      } = this.props;
-      const nodeHandle = findNodeHandle(carouselRef);
-
-      if (carouselRef && nodeHandle) {
-        this._container.measureLayout(nodeHandle, (x, y, width, height) => {
-          const offset = this.props.vertical ? y - (this.props.sliderHeight - this.props.itemHeight) / 2 : x - (this.props.sliderWidth - this.props.itemWidth) / 2;
-          this.setState({
-            offset: offset,
-            width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),
-            height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)
-          });
-        }, // eslint-disable-next-line @typescript-eslint/no-empty-function
-        () => {});
-      }
-    }
-  }
-
-  _onLoad(event) {
-    const {
-      animOpacity
-    } = this.state;
-    const {
-      fadeDuration,
-      onLoad
-    } = this.props;
-
-    if (!this._mounted) {
-      return;
-    }
-
-    this.setState({
-      status: ParallaxImageStatus.LOADED
-    });
-
-    if (onLoad) {
-      onLoad(event);
-    }
-
-    Animated.timing(animOpacity, {
-      toValue: 1,
-      duration: fadeDuration,
-      easing: Easing.out(Easing.quad),
-      isInteraction: false,
-      useNativeDriver: true
-    }).start(() => {
-      this.setState({
-        status: ParallaxImageStatus.TRANSITION_FINISHED
-      });
-    });
-  } // If arg is missing from method signature, it just won't be called
-
-
-  _onError(event) {
-    const {
-      onError
-    } = this.props;
-    this.setState({
-      status: ParallaxImageStatus.ERROR
-    });
-
-    if (onError) {
-      onError(event);
-    }
-  }
-
-  get image() {
-    const {
-      status,
-      animOpacity,
-      offset,
-      width,
-      height
-    } = this.state;
-    const {
-      scrollPosition,
-      // False positive :( other doesn't have the dimension key
-      // eslint-disable-next-line @typescript-eslint/no-unused-vars
-      dimensions,
-      parallaxFactor,
-      style,
-      AnimatedImageComponent,
-      ...other
-    } = this.props;
-    const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;
-    const requiredStyles = {
-      position: 'relative'
-    };
-    const dynamicStyles = {
-      width: this.props.vertical ? width : width + parallaxPadding * 2,
-      height: this.props.vertical ? height + parallaxPadding * 2 : height,
-      opacity: animOpacity,
-      transform: scrollPosition ? [{
-        translateX: !this.props.vertical ? scrollPosition.interpolate({
-          inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],
-          outputRange: [-parallaxPadding, parallaxPadding],
-          extrapolate: 'clamp'
-        }) : 0
-      }, {
-        translateY: this.props.vertical ? scrollPosition.interpolate({
-          inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],
-          outputRange: [-parallaxPadding, parallaxPadding],
-          extrapolate: 'clamp'
-        }) : 0
-      }] : []
-    };
-    return /*#__PURE__*/React.createElement(AnimatedImageComponent, _extends({}, other, {
-      style: [styles.image, style, requiredStyles, dynamicStyles],
-      onLoad: this._onLoad,
-      onError: status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined // prevent infinite-loop bug
-
-    }));
-  }
-
-  get spinner() {
-    const {
-      status
-    } = this.state;
-    const {
-      showSpinner,
-      spinnerColor
-    } = this.props;
-    return status === ParallaxImageStatus.LOADING && showSpinner ? /*#__PURE__*/React.createElement(View, {
-      style: styles.loaderContainer
-    }, /*#__PURE__*/React.createElement(ActivityIndicator, {
-      size: "small",
-      color: spinnerColor,
-      animating: true
-    })) : false;
-  }
-
-  render() {
-    const {
-      containerStyle
-    } = this.props;
-    return /*#__PURE__*/React.createElement(View, {
-      ref: c => {
-        this._container = c;
-      },
-      pointerEvents: "none",
-      style: [containerStyle, styles.container],
-      onLayout: this._measureLayout
-    }, this.image, this.spinner);
-  }
-
-}
-
-_defineProperty(ParallaxImage, "defaultProps", {
-  containerStyle: {},
-  fadeDuration: 500,
-  parallaxFactor: 0.3,
-  showSpinner: true,
-  spinnerColor: 'rgba(0, 0, 0, 0.4)',
-  AnimatedImageComponent: Animated.Image
-});
-//# sourceMappingURL=ParallaxImage.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js.map b/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js.map
deleted file mode 100644
index 4112e15..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["ParallaxImage.tsx"],"names":["React","Component","View","Animated","Easing","ActivityIndicator","findNodeHandle","styles","ParallaxImageStatus","ParallaxImage","constructor","props","state","offset","width","height","status","LOADING","animOpacity","Value","_onLoad","bind","_onError","_measureLayout","setNativeProps","nativeProps","_container","componentDidMount","_mounted","setTimeout","componentWillUnmount","dimensions","carouselRef","nodeHandle","measureLayout","x","y","vertical","sliderHeight","itemHeight","sliderWidth","itemWidth","setState","Math","ceil","event","fadeDuration","onLoad","LOADED","timing","toValue","duration","easing","out","quad","isInteraction","useNativeDriver","start","TRANSITION_FINISHED","onError","ERROR","image","scrollPosition","parallaxFactor","style","AnimatedImageComponent","other","parallaxPadding","requiredStyles","position","dynamicStyles","opacity","transform","translateX","interpolate","inputRange","outputRange","extrapolate","translateY","undefined","spinner","showSpinner","spinnerColor","loaderContainer","render","containerStyle","c","container","Image"],"mappings":"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","sourcesContent":["// Parallax effect inspired by https://github.com/oblador/react-native-parallax/\n\nimport React, { Component } from 'react';\nimport {\n    View,\n    Animated,\n    Easing,\n    ActivityIndicator,\n    findNodeHandle,\n    ImageProps,\n    StyleProp,\n    ViewStyle,\n    NativeSyntheticEvent,\n    ImageLoadEventData,\n    ImageErrorEventData\n} from 'react-native';\nimport styles from './ParallaxImage.style';\n\ntype VerticalProps = {\n    vertical: true;\n    sliderHeight: number; // passed from <Carousel />\n    itemHeight: number; // passed from <Carousel />\n}\ntype HorizontalProps = {\n    vertical: false;\n    sliderWidth: number; // passed from <Carousel />\n    itemWidth: number; // passed from <Carousel />\n}\n\ntype ParallaxImageProps = {\n  carouselRef: Parameters<typeof findNodeHandle>[0]; // passed from <Carousel />\n  scrollPosition: Animated.Value | undefined; // passed from <Carousel />\n  containerStyle: StyleProp<ViewStyle>;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n  fadeDuration: number;\n  parallaxFactor: number;\n  showSpinner: boolean;\n  spinnerColor: string;\n  AnimatedImageComponent: typeof Animated.Image;\n} & ImageProps & (VerticalProps | HorizontalProps);\n\nexport enum ParallaxImageStatus {\n    'LOADING' = 1,\n    'LOADED' = 2,\n    'TRANSITION_FINISHED' = 3,\n    'ERROR' = 4\n}\n\ntype ParallaxImageState = {\n  offset: number;\n  width: number;\n  height: number;\n  status: ParallaxImageStatus;\n  animOpacity: Animated.Value;\n};\n\nexport default class ParallaxImage extends Component<\n  ParallaxImageProps,\n  ParallaxImageState\n> {\n  static defaultProps = {\n      containerStyle: {},\n      fadeDuration: 500,\n      parallaxFactor: 0.3,\n      showSpinner: true,\n      spinnerColor: 'rgba(0, 0, 0, 0.4)',\n      AnimatedImageComponent: Animated.Image\n  };\n\n  _container?: View | null;\n  _mounted?: boolean;\n\n  constructor (props: ParallaxImageProps) {\n      super(props);\n      this.state = {\n          offset: 0,\n          width: 0,\n          height: 0,\n          status: ParallaxImageStatus.LOADING,\n          animOpacity: new Animated.Value(0)\n      };\n      this._onLoad = this._onLoad.bind(this);\n      this._onError = this._onError.bind(this);\n      this._measureLayout = this._measureLayout.bind(this);\n  }\n\n  setNativeProps (nativeProps: { [key: string]: unknown }) {\n    this._container?.setNativeProps(nativeProps);\n  }\n\n  componentDidMount () {\n      this._mounted = true;\n\n      setTimeout(() => {\n          this._measureLayout();\n      }, 0);\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n  }\n\n  _measureLayout () {\n      if (this._container) {\n          const {\n              dimensions,\n              carouselRef\n          } = this.props;\n\n          const nodeHandle = findNodeHandle(carouselRef);\n\n          if (carouselRef && nodeHandle) {\n              this._container.measureLayout(\n                  nodeHandle,\n                  (x, y, width, height) => {\n                      const offset = this.props.vertical ?\n                          y - (this.props.sliderHeight - this.props.itemHeight) / 2 :\n                          x - (this.props.sliderWidth - this.props.itemWidth) / 2;\n\n                      this.setState({\n                          offset: offset,\n                          width:\n                dimensions && dimensions.width ?\n                    dimensions.width :\n                    Math.ceil(width),\n                          height:\n                dimensions && dimensions.height ?\n                    dimensions.height :\n                    Math.ceil(height)\n                      });\n                  },\n                  // eslint-disable-next-line @typescript-eslint/no-empty-function\n                  () => {}\n              );\n          }\n      }\n  }\n\n  _onLoad (event: NativeSyntheticEvent<ImageLoadEventData>) {\n      const { animOpacity } = this.state;\n      const { fadeDuration, onLoad } = this.props;\n\n      if (!this._mounted) {\n          return;\n      }\n\n      this.setState({ status: ParallaxImageStatus.LOADED });\n\n      if (onLoad) {\n          onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n          toValue: 1,\n          duration: fadeDuration,\n          easing: Easing.out(Easing.quad),\n          isInteraction: false,\n          useNativeDriver: true\n      }).start(() => {\n          this.setState({ status: ParallaxImageStatus.TRANSITION_FINISHED });\n      });\n  }\n\n  // If arg is missing from method signature, it just won't be called\n  _onError (event: NativeSyntheticEvent<ImageErrorEventData>) {\n      const { onError } = this.props;\n\n      this.setState({ status: ParallaxImageStatus.ERROR });\n\n      if (onError) {\n          onError(event);\n      }\n  }\n\n  get image () {\n      const { status, animOpacity, offset, width, height } = this.state;\n      const {\n          scrollPosition,\n          // False positive :( other doesn't have the dimension key\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          dimensions,\n          parallaxFactor,\n          style,\n          AnimatedImageComponent,\n          ...other\n      } = this.props;\n      const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      const requiredStyles = { position: 'relative' as const };\n      const dynamicStyles = {\n          width: this.props.vertical ? width : width + parallaxPadding * 2,\n          height: this.props.vertical ? height + parallaxPadding * 2 : height,\n          opacity: animOpacity,\n          transform: scrollPosition ?\n              [\n                  {\n                      translateX: !this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  },\n                  {\n                      translateY: this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  }\n              ] :\n              []\n      };\n\n      return (\n          <AnimatedImageComponent\n            {...other}\n            style={[styles.image, style, requiredStyles, dynamicStyles]}\n            onLoad={this._onLoad}\n            onError={status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined} // prevent infinite-loop bug\n          />\n      );\n  }\n\n  get spinner () {\n      const { status } = this.state;\n      const { showSpinner, spinnerColor } = this.props;\n\n      return status === ParallaxImageStatus.LOADING && showSpinner ? (\n          <View style={styles.loaderContainer}>\n              <ActivityIndicator\n                size='small'\n                color={spinnerColor}\n                animating={true}\n              />\n          </View>\n      ) : (\n          false\n      );\n  }\n\n  render () {\n      const { containerStyle } = this.props;\n\n      return (\n          <View\n            ref={(c) => {\n                this._container = c;\n            }}\n            pointerEvents='none'\n            style={[containerStyle, styles.container]}\n            onLayout={this._measureLayout}\n          >\n              {this.image}\n              {this.spinner}\n          </View>\n      );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js b/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js
deleted file mode 100644
index 8a18fec..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js
+++ /dev/null
@@ -1,19 +0,0 @@
-import { StyleSheet } from 'react-native';
-export default StyleSheet.create({
-  container: {
-    overflow: 'hidden',
-    alignItems: 'center',
-    justifyContent: 'center'
-  },
-  image: {
-    position: 'relative',
-    resizeMode: 'cover',
-    width: undefined,
-    height: undefined
-  },
-  loaderContainer: { ...StyleSheet.absoluteFillObject,
-    alignItems: 'center',
-    justifyContent: 'center'
-  }
-});
-//# sourceMappingURL=ParallaxImage.style.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js.map b/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js.map
deleted file mode 100644
index c11909a..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/parallaximage/ParallaxImage.style.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["ParallaxImage.style.ts"],"names":["StyleSheet","create","container","overflow","alignItems","justifyContent","image","position","resizeMode","width","undefined","height","loaderContainer","absoluteFillObject"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AAEA,eAAeA,UAAU,CAACC,MAAX,CAAkB;AAC7BC,EAAAA,SAAS,EAAE;AACPC,IAAAA,QAAQ,EAAE,QADH;AAEPC,IAAAA,UAAU,EAAE,QAFL;AAGPC,IAAAA,cAAc,EAAE;AAHT,GADkB;AAM7BC,EAAAA,KAAK,EAAE;AACHC,IAAAA,QAAQ,EAAE,UADP;AAEHC,IAAAA,UAAU,EAAE,OAFT;AAGHC,IAAAA,KAAK,EAAEC,SAHJ;AAIHC,IAAAA,MAAM,EAAED;AAJL,GANsB;AAY7BE,EAAAA,eAAe,EAAE,EACb,GAAGZ,UAAU,CAACa,kBADD;AAEbT,IAAAA,UAAU,EAAE,QAFC;AAGbC,IAAAA,cAAc,EAAE;AAHH;AAZY,CAAlB,CAAf","sourcesContent":["import { StyleSheet } from 'react-native';\n\nexport default StyleSheet.create({\n    container: {\n        overflow: 'hidden',\n        alignItems: 'center',\n        justifyContent: 'center'\n    },\n    image: {\n        position: 'relative',\n        resizeMode: 'cover',\n        width: undefined,\n        height: undefined\n    },\n    loaderContainer: {\n        ...StyleSheet.absoluteFillObject,\n        alignItems: 'center',\n        justifyContent: 'center'\n    }\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/utils/animations.js b/node_modules/react-native-snap-carousel/lib/module/utils/animations.js
deleted file mode 100644
index 7931c51..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/utils/animations.js
+++ /dev/null
@@ -1,276 +0,0 @@
-import { Platform } from 'react-native';
-const IS_ANDROID = Platform.OS === 'android'; // Get scroll interpolator's input range from an array of slide indexes
-// Indexes are relative to the current active slide (index 0)
-// For example, using [3, 2, 1, 0, -1] will return:
-// [
-//     (index - 3) * sizeRef, // active + 3
-//     (index - 2) * sizeRef, // active + 2
-//     (index - 1) * sizeRef, // active + 1
-//     index * sizeRef, // active
-//     (index + 1) * sizeRef // active - 1
-// ]
-
-export function getInputRangeFromIndexes(range, index, carouselProps) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const inputRange = [];
-
-  for (let i = 0; i < range.length; i++) {
-    inputRange.push((index - range[i]) * sizeRef);
-  }
-
-  return inputRange;
-} // Default behavior
-// Scale and/or opacity effect
-// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'
-
-export function defaultScrollInterpolator(index, carouselProps) {
-  const range = [1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = [0, 1, 0];
-  return {
-    inputRange,
-    outputRange
-  };
-}
-export function defaultAnimatedStyles(_index, animatedValue, carouselProps) {
-  let animatedOpacity = {};
-  let animatedScale = {};
-
-  if (carouselProps.inactiveSlideOpacity < 1) {
-    animatedOpacity = {
-      opacity: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideOpacity, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideScale < 1) {
-    animatedScale = {
-      transform: [{
-        scale: animatedValue.interpolate({
-          inputRange: [0, 1],
-          outputRange: [carouselProps.inactiveSlideScale, 1]
-        })
-      }]
-    };
-  }
-
-  return { ...animatedOpacity,
-    ...animatedScale
-  };
-} // Shift animation
-// Same as the default one, but the active slide is also shifted up or down
-// Based on prop 'inactiveSlideShift'
-
-export function shiftAnimatedStyles(_index, animatedValue, carouselProps) {
-  let animatedOpacity = {};
-  let animatedScale = {};
-  let animatedTranslate = {};
-
-  if (carouselProps.inactiveSlideOpacity < 1) {
-    animatedOpacity = {
-      opacity: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideOpacity, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideScale < 1) {
-    animatedScale = {
-      scale: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideScale, 1]
-      })
-    };
-  }
-
-  if (carouselProps.inactiveSlideShift !== 0) {
-    const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';
-    animatedTranslate = {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: [carouselProps.inactiveSlideShift, 0]
-      })
-    };
-  }
-
-  return { ...animatedOpacity,
-    transform: [{ ...animatedScale
-    }, { ...animatedTranslate
-    }]
-  };
-} // Stack animation
-// Imitate a deck/stack of cards (see #195)
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-
-export function stackScrollInterpolator(index, carouselProps) {
-  const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = range;
-  return {
-    inputRange,
-    outputRange
-  };
-}
-export function stackAnimatedStyles(index, animatedValue, carouselProps, cardOffset) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
-  const card1Scale = 0.9;
-  const card2Scale = 0.8;
-  const newCardOffset = cardOffset !== null && cardOffset !== void 0 ? cardOffset : 18;
-
-  const getTranslateFromScale = (cardIndex, scale) => {
-    const centerFactor = 1 / scale * cardIndex;
-    const centeredPosition = -Math.round(sizeRef * centerFactor);
-    const edgeAlignment = Math.round((sizeRef - sizeRef * scale) / 2);
-    const offset = Math.round(newCardOffset * Math.abs(cardIndex) / scale);
-    return IS_ANDROID ? centeredPosition - edgeAlignment - offset : centeredPosition + edgeAlignment + offset;
-  };
-
-  const opacityOutputRange = carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];
-  return IS_ANDROID ? {
-    // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-    opacity: animatedValue.interpolate({
-      inputRange: [-3, -2, -1, 0],
-      outputRange: opacityOutputRange.reverse(),
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-2, -1, 0, 1],
-        outputRange: [card2Scale, card1Scale, 1, card1Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0, 1],
-        outputRange: [getTranslateFromScale(-3, card2Scale), getTranslateFromScale(-2, card2Scale), getTranslateFromScale(-1, card1Scale), 0, sizeRef * 0.5],
-        extrapolate: 'clamp'
-      })
-    }]
-  } : {
-    zIndex: carouselProps.data.length - index,
-    opacity: animatedValue.interpolate({
-      inputRange: [0, 1, 2, 3],
-      outputRange: opacityOutputRange,
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2],
-        outputRange: [card1Scale, 1, card1Scale, card2Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [translateProp]: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2, 3],
-        outputRange: [-sizeRef * 0.5, 0, getTranslateFromScale(1, card1Scale), getTranslateFromScale(2, card2Scale), getTranslateFromScale(3, card2Scale)],
-        extrapolate: 'clamp'
-      })
-    }]
-  };
-} // Tinder animation
-// Imitate the popular Tinder layout
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-
-export function tinderScrollInterpolator(index, carouselProps) {
-  const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-  const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-  const outputRange = range;
-  return {
-    inputRange,
-    outputRange
-  };
-}
-export function tinderAnimatedStyles(index, animatedValue, carouselProps, cardOffset) {
-  const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
-  const mainTranslateProp = carouselProps.vertical ? 'translateY' : 'translateX';
-  const secondaryTranslateProp = carouselProps.vertical ? 'translateX' : 'translateY';
-  const card1Scale = 0.96;
-  const card2Scale = 0.92;
-  const card3Scale = 0.88;
-  const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;
-  const newCardOffset = cardOffset !== null && cardOffset !== void 0 ? cardOffset : 9;
-
-  const getMainTranslateFromScale = (cardIndex, scale) => {
-    const centerFactor = 1 / scale * cardIndex;
-    return -Math.round(sizeRef * centerFactor);
-  };
-
-  const getSecondaryTranslateFromScale = (cardIndex, scale) => {
-    return Math.round(newCardOffset * Math.abs(cardIndex) / scale);
-  };
-
-  return IS_ANDROID ? {
-    // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-    opacity: animatedValue.interpolate({
-      inputRange: [-3, -2, -1, 0, 1],
-      outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0],
-        outputRange: [card3Scale, card2Scale, card1Scale, 1],
-        extrapolate: 'clamp'
-      })
-    }, {
-      rotate: animatedValue.interpolate({
-        inputRange: [0, 1],
-        outputRange: ['0deg', '22deg'],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [mainTranslateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0, 1],
-        outputRange: [getMainTranslateFromScale(-3, card3Scale), getMainTranslateFromScale(-2, card2Scale), getMainTranslateFromScale(-1, card1Scale), 0, sizeRef * 1.1],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [secondaryTranslateProp]: animatedValue.interpolate({
-        inputRange: [-3, -2, -1, 0],
-        outputRange: [getSecondaryTranslateFromScale(-3, card3Scale), getSecondaryTranslateFromScale(-2, card2Scale), getSecondaryTranslateFromScale(-1, card1Scale), 0],
-        extrapolate: 'clamp'
-      })
-    }]
-  } : {
-    zIndex: carouselProps.data.length - index,
-    opacity: animatedValue.interpolate({
-      inputRange: [-1, 0, 1, 2, 3],
-      outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],
-      extrapolate: 'clamp'
-    }),
-    transform: [{
-      scale: animatedValue.interpolate({
-        inputRange: [0, 1, 2, 3],
-        outputRange: [1, card1Scale, card2Scale, card3Scale],
-        extrapolate: 'clamp'
-      })
-    }, {
-      rotate: animatedValue.interpolate({
-        inputRange: [-1, 0],
-        outputRange: ['-22deg', '0deg'],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [mainTranslateProp]: animatedValue.interpolate({
-        inputRange: [-1, 0, 1, 2, 3],
-        outputRange: [-sizeRef * 1.1, 0, getMainTranslateFromScale(1, card1Scale), getMainTranslateFromScale(2, card2Scale), getMainTranslateFromScale(3, card3Scale)],
-        extrapolate: 'clamp'
-      })
-    }, {
-      [secondaryTranslateProp]: animatedValue.interpolate({
-        inputRange: [0, 1, 2, 3],
-        outputRange: [0, getSecondaryTranslateFromScale(1, card1Scale), getSecondaryTranslateFromScale(2, card2Scale), getSecondaryTranslateFromScale(3, card3Scale)],
-        extrapolate: 'clamp'
-      })
-    }]
-  };
-}
-//# sourceMappingURL=animations.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/module/utils/animations.js.map b/node_modules/react-native-snap-carousel/lib/module/utils/animations.js.map
deleted file mode 100644
index 2eb30f1..0000000
--- a/node_modules/react-native-snap-carousel/lib/module/utils/animations.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"sources":["animations.ts"],"names":["Platform","IS_ANDROID","OS","getInputRangeFromIndexes","range","index","carouselProps","sizeRef","vertical","itemHeight","itemWidth","inputRange","i","length","push","defaultScrollInterpolator","outputRange","defaultAnimatedStyles","_index","animatedValue","animatedOpacity","animatedScale","inactiveSlideOpacity","opacity","interpolate","inactiveSlideScale","transform","scale","shiftAnimatedStyles","animatedTranslate","inactiveSlideShift","translateProp","stackScrollInterpolator","stackAnimatedStyles","cardOffset","card1Scale","card2Scale","newCardOffset","getTranslateFromScale","cardIndex","centerFactor","centeredPosition","Math","round","edgeAlignment","offset","abs","opacityOutputRange","reverse","extrapolate","zIndex","data","tinderScrollInterpolator","tinderAnimatedStyles","mainTranslateProp","secondaryTranslateProp","card3Scale","peekingCardsOpacity","getMainTranslateFromScale","getSecondaryTranslateFromScale","rotate"],"mappings":"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","sourcesContent":["import { Platform, Animated } from 'react-native';\nimport type { CarouselProps } from 'src/carousel/types';\n\nconst IS_ANDROID = Platform.OS === 'android';\n\n// Get scroll interpolator's input range from an array of slide indexes\n// Indexes are relative to the current active slide (index 0)\n// For example, using [3, 2, 1, 0, -1] will return:\n// [\n//     (index - 3) * sizeRef, // active + 3\n//     (index - 2) * sizeRef, // active + 2\n//     (index - 1) * sizeRef, // active + 1\n//     index * sizeRef, // active\n//     (index + 1) * sizeRef // active - 1\n// ]\nexport function getInputRangeFromIndexes<TData> (\n    range: number[],\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const inputRange = [];\n\n    for (let i = 0; i < range.length; i++) {\n        inputRange.push((index - range[i]) * sizeRef);\n    }\n\n    return inputRange;\n}\n\n// Default behavior\n// Scale and/or opacity effect\n// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'\nexport function defaultScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = [1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = [0, 1, 0];\n\n    return { inputRange, outputRange };\n}\nexport function defaultAnimatedStyles<TData> (\n    _index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>\n) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: [carouselProps.inactiveSlideScale, 1]\n                    })\n                }\n            ]\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        ...animatedScale\n    };\n}\n\n// Shift animation\n// Same as the default one, but the active slide is also shifted up or down\n// Based on prop 'inactiveSlideShift'\nexport function shiftAnimatedStyles<TData> (\n    _index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>\n) {\n    let animatedOpacity = {};\n    let animatedScale = {};\n    let animatedTranslate = {};\n\n    if (carouselProps.inactiveSlideOpacity < 1) {\n        animatedOpacity = {\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideOpacity, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideScale < 1) {\n        animatedScale = {\n            scale: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideScale, 1]\n            })\n        };\n    }\n\n    if (carouselProps.inactiveSlideShift !== 0) {\n        const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';\n        animatedTranslate = {\n            [translateProp]: animatedValue.interpolate({\n                inputRange: [0, 1],\n                outputRange: [carouselProps.inactiveSlideShift, 0]\n            })\n        };\n    }\n\n    return {\n        ...animatedOpacity,\n        transform: [{ ...animatedScale }, { ...animatedTranslate }]\n    };\n}\n\n// Stack animation\n// Imitate a deck/stack of cards (see #195)\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function stackScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function stackAnimatedStyles<TData> (\n    index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>,\n    cardOffset?: number\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';\n\n    const card1Scale = 0.9;\n    const card2Scale = 0.8;\n\n    const newCardOffset = cardOffset ?? 18;\n\n    const getTranslateFromScale = (cardIndex: number, scale: number) => {\n        const centerFactor = (1 / scale) * cardIndex;\n        const centeredPosition = -Math.round(sizeRef * centerFactor);\n        const edgeAlignment = Math.round((sizeRef - sizeRef * scale) / 2);\n        const offset = Math.round((newCardOffset * Math.abs(cardIndex)) / scale);\n\n        return IS_ANDROID ?\n            centeredPosition - edgeAlignment - offset :\n            centeredPosition + edgeAlignment + offset;\n    };\n\n    const opacityOutputRange =\n    carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];\n\n    return IS_ANDROID ?\n        {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n            opacity: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0],\n                outputRange: opacityOutputRange.reverse(),\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-2, -1, 0, 1],\n                        outputRange: [card2Scale, card1Scale, 1, card1Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [translateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0, 1],\n                        outputRange: [\n                            getTranslateFromScale(-3, card2Scale),\n                            getTranslateFromScale(-2, card2Scale),\n                            getTranslateFromScale(-1, card1Scale),\n                            0,\n                            sizeRef * 0.5\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        } :\n        {\n            zIndex: carouselProps.data.length - index,\n            opacity: animatedValue.interpolate({\n                inputRange: [0, 1, 2, 3],\n                outputRange: opacityOutputRange,\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2],\n                        outputRange: [card1Scale, 1, card1Scale, card2Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [translateProp]: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2, 3],\n                        outputRange: [\n                            -sizeRef * 0.5,\n                            0,\n                            getTranslateFromScale(1, card1Scale),\n                            getTranslateFromScale(2, card2Scale),\n                            getTranslateFromScale(3, card2Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        };\n}\n\n// Tinder animation\n// Imitate the popular Tinder layout\n// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property\n// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item\n// The `elevation` property compensates for that only visually, which is not good enough\nexport function tinderScrollInterpolator<TData> (\n    index: number,\n    carouselProps: CarouselProps<TData>\n) {\n    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];\n    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);\n    const outputRange = range;\n\n    return { inputRange, outputRange };\n}\nexport function tinderAnimatedStyles<TData> (\n    index: number,\n    animatedValue: Animated.AnimatedInterpolation,\n    carouselProps: CarouselProps<TData>,\n    cardOffset?: number\n) {\n    const sizeRef = carouselProps.vertical ?\n        carouselProps.itemHeight :\n        carouselProps.itemWidth;\n    const mainTranslateProp = carouselProps.vertical ?\n        'translateY' :\n        'translateX';\n    const secondaryTranslateProp = carouselProps.vertical ?\n        'translateX' :\n        'translateY';\n\n    const card1Scale = 0.96;\n    const card2Scale = 0.92;\n    const card3Scale = 0.88;\n\n    const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;\n\n    const newCardOffset = cardOffset ?? 9;\n\n    const getMainTranslateFromScale = (cardIndex: number, scale: number) => {\n        const centerFactor = (1 / scale) * cardIndex;\n        return -Math.round(sizeRef * centerFactor);\n    };\n\n    const getSecondaryTranslateFromScale = (cardIndex: number, scale: number) => {\n        return Math.round((newCardOffset * Math.abs(cardIndex)) / scale);\n    };\n\n    return IS_ANDROID ?\n        {\n        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view\n            opacity: animatedValue.interpolate({\n                inputRange: [-3, -2, -1, 0, 1],\n                outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0],\n                        outputRange: [card3Scale, card2Scale, card1Scale, 1],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    rotate: animatedValue.interpolate({\n                        inputRange: [0, 1],\n                        outputRange: ['0deg', '22deg'],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [mainTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0, 1],\n                        outputRange: [\n                            getMainTranslateFromScale(-3, card3Scale),\n                            getMainTranslateFromScale(-2, card2Scale),\n                            getMainTranslateFromScale(-1, card1Scale),\n                            0,\n                            sizeRef * 1.1\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [secondaryTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-3, -2, -1, 0],\n                        outputRange: [\n                            getSecondaryTranslateFromScale(-3, card3Scale),\n                            getSecondaryTranslateFromScale(-2, card2Scale),\n                            getSecondaryTranslateFromScale(-1, card1Scale),\n                            0\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        } :\n        {\n            zIndex: carouselProps.data.length - index,\n            opacity: animatedValue.interpolate({\n                inputRange: [-1, 0, 1, 2, 3],\n                outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],\n                extrapolate: 'clamp'\n            }),\n            transform: [\n                {\n                    scale: animatedValue.interpolate({\n                        inputRange: [0, 1, 2, 3],\n                        outputRange: [1, card1Scale, card2Scale, card3Scale],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    rotate: animatedValue.interpolate({\n                        inputRange: [-1, 0],\n                        outputRange: ['-22deg', '0deg'],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [mainTranslateProp]: animatedValue.interpolate({\n                        inputRange: [-1, 0, 1, 2, 3],\n                        outputRange: [\n                            -sizeRef * 1.1,\n                            0,\n                            getMainTranslateFromScale(1, card1Scale),\n                            getMainTranslateFromScale(2, card2Scale),\n                            getMainTranslateFromScale(3, card3Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                },\n                {\n                    [secondaryTranslateProp]: animatedValue.interpolate({\n                        inputRange: [0, 1, 2, 3],\n                        outputRange: [\n                            0,\n                            getSecondaryTranslateFromScale(1, card1Scale),\n                            getSecondaryTranslateFromScale(2, card2Scale),\n                            getSecondaryTranslateFromScale(3, card3Scale)\n                        ],\n                        extrapolate: 'clamp'\n                    })\n                }\n            ]\n        };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/carousel/Carousel.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/carousel/Carousel.d.ts
deleted file mode 100644
index 398a9b4..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/carousel/Carousel.d.ts
+++ /dev/null
@@ -1,306 +0,0 @@
-/// <reference types="node" />
-import React, { PropsWithChildren } from 'react';
-import { Animated, FlatList, ScrollView, StyleProp, NativeSyntheticEvent, NativeScrollEvent, LayoutChangeEvent, GestureResponderEvent, ViewStyle } from 'react-native';
-import type { CarouselProps, CarouselState } from './types';
-export declare class Carousel<TData> extends React.Component<CarouselProps<TData>, CarouselState> {
-    static defaultProps: {
-        activeSlideAlignment: string;
-        activeSlideOffset: number;
-        apparitionDelay: number;
-        autoplay: boolean;
-        autoplayDelay: number;
-        autoplayInterval: number;
-        callbackOffsetMargin: number;
-        containerCustomStyle: {};
-        contentContainerCustomStyle: {};
-        enableSnap: boolean;
-        firstItem: number;
-        hasParallaxImages: boolean;
-        inactiveSlideOpacity: number;
-        inactiveSlideScale: number;
-        inactiveSlideShift: number;
-        layout: string;
-        loop: boolean;
-        loopClonesPerSide: number;
-        scrollEnabled: boolean;
-        slideStyle: {};
-        shouldOptimizeUpdates: boolean;
-        useExperimentalSnap: boolean;
-        useScrollView: boolean;
-    };
-    _activeItem: number;
-    _onScrollActiveItem: number;
-    _previousFirstItem: number;
-    _previousItemsLength: number;
-    _mounted: boolean;
-    _positions: {
-        start: number;
-        end: number;
-    }[];
-    _currentScrollOffset: number;
-    _scrollEnabled: boolean;
-    _initTimeout?: ReturnType<typeof setTimeout>;
-    _apparitionTimeout?: ReturnType<typeof setTimeout>;
-    _hackSlideAnimationTimeout?: ReturnType<typeof setTimeout>;
-    _enableAutoplayTimeout?: ReturnType<typeof setTimeout>;
-    _autoplayTimeout?: ReturnType<typeof setTimeout>;
-    _snapNoMomentumTimeout?: ReturnType<typeof setTimeout>;
-    _androidRepositioningTimeout?: ReturnType<typeof setTimeout>;
-    _autoplayInterval?: ReturnType<typeof setInterval>;
-    _scrollPos?: Animated.Value;
-    _onScrollHandler?: ReturnType<typeof Animated.event>;
-    _carouselRef: ScrollView | FlatList<TData> | null;
-    _autoplaying?: boolean;
-    _autoplay?: boolean;
-    _onLayoutInitDone?: boolean;
-    constructor(props: CarouselProps<TData>);
-    componentDidMount(): void;
-    shouldComponentUpdate(nextProps: CarouselProps<TData>, nextState: CarouselState): boolean;
-    componentDidUpdate(prevProps: CarouselProps<TData>): void;
-    componentWillUnmount(): void;
-    get realIndex(): number;
-    get currentIndex(): number;
-    get currentScrollPosition(): number;
-    _setScrollHandler(props: CarouselProps<TData>): void;
-    _displayWarnings(props?: CarouselProps<TData>): void;
-    _needsScrollView(): boolean | React.ComponentClass<unknown, any> | React.FunctionComponent<unknown>;
-    _needsRTLAdaptations(): boolean;
-    _enableLoop(): boolean | 0;
-    _shouldAnimateSlides(props?: CarouselProps<TData>): boolean;
-    _shouldUseShiftLayout(): boolean;
-    _shouldUseStackLayout(): boolean;
-    _shouldUseTinderLayout(): boolean;
-    _shouldRepositionScroll(index: number): boolean;
-    _roundNumber(num: number, decimals?: number): number;
-    _isMultiple(x: number, y: number): boolean;
-    _getCustomData(props?: CarouselProps<TData>): TData[];
-    _getCustomDataLength(props?: CarouselProps<TData>): number;
-    _getCustomIndex(index: number, props?: CarouselProps<TData>): number;
-    _getDataIndex(index: number): number;
-    _getPositionIndex(index: number): number;
-    _getSnapOffsets(props?: CarouselProps<TData>): number[];
-    _getFirstItem(index: number, props?: CarouselProps<TData>): number;
-    _getWrappedRef(): any;
-    _getScrollEnabled(): boolean;
-    _setScrollEnabled(scrollEnabled?: boolean): void;
-    _getItemMainDimension(): number;
-    _getItemScrollOffset(index: number): number;
-    _getItemLayout(_: TData[], index: number): {
-        index: number;
-        length: number;
-        offset: number;
-    };
-    _getCellRendererComponent({ children, index, style, ...props }: PropsWithChildren<{
-        index: number;
-        style: StyleProp<ViewStyle>;
-    }>): JSX.Element;
-    _getKeyExtractor(_: TData, index: number): string;
-    _getScrollOffset(event: NativeSyntheticEvent<NativeScrollEvent>): number;
-    _getContainerInnerMargin(opposite?: boolean): number;
-    _getActiveSlideOffset(): number;
-    _getActiveItem(offset: number): number;
-    _getSlideInterpolatedStyle(index: number, animatedValue: Animated.AnimatedInterpolation): {} | null | undefined;
-    _initPositionsAndInterpolators(props?: CarouselProps<TData>): void;
-    _hackActiveSlideAnimation(index: number, scrollValue?: number): void;
-    _repositionScroll(index: number, animated?: boolean): void;
-    _scrollTo({ offset, index, animated }: {
-        offset: number;
-        index?: number;
-        animated: boolean;
-    }): void;
-    _onTouchStart(event: GestureResponderEvent): void;
-    _onTouchEnd(event: GestureResponderEvent): void;
-    _onScroll(event: NativeSyntheticEvent<NativeScrollEvent>): void;
-    _onMomentumScrollEnd(event: NativeSyntheticEvent<NativeScrollEvent>): void;
-    _onLayout(event: LayoutChangeEvent): void;
-    _snapToItem(index: number, animated?: boolean, fireCallback?: boolean, forceScrollTo?: boolean): void;
-    startAutoplay(): void;
-    pauseAutoPlay(): void;
-    stopAutoplay(): void;
-    snapToItem(index: number, animated?: boolean, fireCallback?: boolean): void;
-    snapToNext(animated?: boolean, fireCallback?: boolean): void;
-    snapToPrev(animated?: boolean, fireCallback?: boolean): void;
-    triggerRenderingHack(offset?: number): void;
-    _renderItem({ item, index }: {
-        item: TData;
-        index: number;
-    }): JSX.Element | null;
-    _getComponentOverridableProps(): {
-        automaticallyAdjustContentInsets: boolean;
-        decelerationRate: "fast";
-        directionalLockEnabled: boolean;
-        disableScrollViewPanResponder: boolean;
-        inverted: boolean;
-        overScrollMode: "never";
-        pinchGestureEnabled: boolean;
-        pointerEvents: "none" | "auto";
-        scrollsToTop: boolean;
-        showsHorizontalScrollIndicator: boolean;
-        showsVerticalScrollIndicator: boolean;
-        initialNumToRender: number;
-        maxToRenderPerBatch: number;
-        windowSize: number;
-    } | {
-        automaticallyAdjustContentInsets: boolean;
-        decelerationRate: "fast";
-        directionalLockEnabled: boolean;
-        disableScrollViewPanResponder: boolean;
-        inverted: boolean;
-        overScrollMode: "never";
-        pinchGestureEnabled: boolean;
-        pointerEvents: "none" | "auto";
-        scrollsToTop: boolean;
-        showsHorizontalScrollIndicator: boolean;
-        showsVerticalScrollIndicator: boolean;
-        initialNumToRender?: undefined;
-        maxToRenderPerBatch?: undefined;
-        windowSize?: undefined;
-    };
-    _getComponentStaticProps(): {
-        ref: (c: any) => void;
-        contentContainerStyle: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined> | {
-            paddingTop: number;
-            paddingBottom: number;
-            paddingLeft?: undefined;
-            paddingRight?: undefined;
-        } | {
-            paddingLeft: number;
-            paddingRight: number;
-            paddingTop?: undefined;
-            paddingBottom?: undefined;
-        })[];
-        data: TData[];
-        horizontal: boolean;
-        scrollEventThrottle: number;
-        style: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined>)[];
-        onLayout: (event: LayoutChangeEvent) => void;
-        onMomentumScrollEnd: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-        onScroll: ((...args: any[]) => void) | undefined;
-        onTouchStart: (event: GestureResponderEvent) => void;
-        onTouchEnd: (event: GestureResponderEvent) => void;
-        snapToAlignment: "center" | "end" | "start";
-        snapToInterval: number;
-        snapToOffsets?: undefined;
-        CellRendererComponent: React.ComponentClass<any, any> | React.FunctionComponent<any> | (({ children, index, style, ...props }: React.PropsWithChildren<{
-            index: number;
-            style: StyleProp<ViewStyle>;
-        }>) => JSX.Element);
-        getItemLayout: (_: TData[], index: number) => {
-            index: number;
-            length: number;
-            offset: number;
-        };
-        initialScrollIndex: number;
-        keyExtractor: (item: TData, index: number) => string;
-        numColumns: number;
-        renderItem: ({ item, index }: {
-            item: TData;
-            index: number;
-        }) => JSX.Element | null;
-    } | {
-        ref: (c: any) => void;
-        contentContainerStyle: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined> | {
-            paddingTop: number;
-            paddingBottom: number;
-            paddingLeft?: undefined;
-            paddingRight?: undefined;
-        } | {
-            paddingLeft: number;
-            paddingRight: number;
-            paddingTop?: undefined;
-            paddingBottom?: undefined;
-        })[];
-        data: TData[];
-        horizontal: boolean;
-        scrollEventThrottle: number;
-        style: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined>)[];
-        onLayout: (event: LayoutChangeEvent) => void;
-        onMomentumScrollEnd: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-        onScroll: ((...args: any[]) => void) | undefined;
-        onTouchStart: (event: GestureResponderEvent) => void;
-        onTouchEnd: (event: GestureResponderEvent) => void;
-        snapToOffsets: number[];
-        snapToAlignment?: undefined;
-        snapToInterval?: undefined;
-        CellRendererComponent: React.ComponentClass<any, any> | React.FunctionComponent<any> | (({ children, index, style, ...props }: React.PropsWithChildren<{
-            index: number;
-            style: StyleProp<ViewStyle>;
-        }>) => JSX.Element);
-        getItemLayout: (_: TData[], index: number) => {
-            index: number;
-            length: number;
-            offset: number;
-        };
-        initialScrollIndex: number;
-        keyExtractor: (item: TData, index: number) => string;
-        numColumns: number;
-        renderItem: ({ item, index }: {
-            item: TData;
-            index: number;
-        }) => JSX.Element | null;
-    } | {
-        ref: (c: any) => void;
-        contentContainerStyle: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined> | {
-            paddingTop: number;
-            paddingBottom: number;
-            paddingLeft?: undefined;
-            paddingRight?: undefined;
-        } | {
-            paddingLeft: number;
-            paddingRight: number;
-            paddingTop?: undefined;
-            paddingBottom?: undefined;
-        })[];
-        data: TData[];
-        horizontal: boolean;
-        scrollEventThrottle: number;
-        style: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined>)[];
-        onLayout: (event: LayoutChangeEvent) => void;
-        onMomentumScrollEnd: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-        onScroll: ((...args: any[]) => void) | undefined;
-        onTouchStart: (event: GestureResponderEvent) => void;
-        onTouchEnd: (event: GestureResponderEvent) => void;
-        snapToAlignment: "center" | "end" | "start";
-        snapToInterval: number;
-        snapToOffsets?: undefined;
-        CellRendererComponent?: undefined;
-        getItemLayout?: undefined;
-        initialScrollIndex?: undefined;
-        keyExtractor?: undefined;
-        numColumns?: undefined;
-        renderItem?: undefined;
-    } | {
-        ref: (c: any) => void;
-        contentContainerStyle: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined> | {
-            paddingTop: number;
-            paddingBottom: number;
-            paddingLeft?: undefined;
-            paddingRight?: undefined;
-        } | {
-            paddingLeft: number;
-            paddingRight: number;
-            paddingTop?: undefined;
-            paddingBottom?: undefined;
-        })[];
-        data: TData[];
-        horizontal: boolean;
-        scrollEventThrottle: number;
-        style: (ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | import("react-native").RecursiveArray<false | ViewStyle | import("react-native").RegisteredStyle<ViewStyle> | null | undefined>)[];
-        onLayout: (event: LayoutChangeEvent) => void;
-        onMomentumScrollEnd: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-        onScroll: ((...args: any[]) => void) | undefined;
-        onTouchStart: (event: GestureResponderEvent) => void;
-        onTouchEnd: (event: GestureResponderEvent) => void;
-        snapToOffsets: number[];
-        snapToAlignment?: undefined;
-        snapToInterval?: undefined;
-        CellRendererComponent?: undefined;
-        getItemLayout?: undefined;
-        initialScrollIndex?: undefined;
-        keyExtractor?: undefined;
-        numColumns?: undefined;
-        renderItem?: undefined;
-    };
-    render(): JSX.Element | null;
-}
-export default Carousel;
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/carousel/types.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/carousel/types.d.ts
deleted file mode 100644
index af4a94f..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/carousel/types.d.ts
+++ /dev/null
@@ -1,75 +0,0 @@
-import type { StyleProp, ViewStyle, Animated, NativeScrollEvent, NativeSyntheticEvent, FlatListProps, ScrollView, FlatList } from 'react-native';
-import type { ReactNode } from 'react';
-declare type CarouselBaseProps<TData> = {
-    data: TData[];
-    activeSlideAlignment: 'center' | 'end' | 'start';
-    activeSlideOffset: number;
-    apparitionDelay: number;
-    autoplay: boolean;
-    autoplayDelay: number;
-    autoplayInterval: number;
-    callbackOffsetMargin: number;
-    containerCustomStyle: StyleProp<ViewStyle>;
-    contentContainerCustomStyle: StyleProp<ViewStyle>;
-    enableSnap: boolean;
-    firstItem: number;
-    inactiveSlideOpacity: number;
-    inactiveSlideScale: number;
-    inactiveSlideShift: number;
-    layout: 'default' | 'stack' | 'tinder';
-    layoutCardOffset?: number;
-    loop: boolean;
-    loopClonesPerSide: number;
-    scrollEnabled: boolean;
-    scrollInterpolator?: (index: number, props: CarouselBaseProps<TData>) => {
-        inputRange: number[];
-        outputRange: number[];
-    };
-    slideInterpolatedStyle?: (index: number, animatedValue: Animated.AnimatedInterpolation, props: CarouselBaseProps<TData>) => StyleProp<ViewStyle>;
-    slideStyle?: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;
-    shouldOptimizeUpdates: boolean;
-    useExperimentalSnap: boolean;
-    useScrollView: boolean | React.ComponentType<unknown>;
-    onScroll?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-    onScrollIndexChanged?: (index: number) => void;
-    onSnapToItem?: (index: number) => void;
-};
-declare type InheritedPropsFromFlatlist<TData> = Pick<FlatListProps<TData>, 'onTouchStart' | 'onTouchEnd' | 'onMomentumScrollEnd' | 'onLayout' | 'keyExtractor' | 'CellRendererComponent' | 'getItemLayout' | 'style'>;
-declare type VerticalCarouselProps<TData> = {
-    vertical: true;
-    itemHeight: number;
-    sliderHeight: number;
-    renderItem: (baseData: {
-        index: number;
-        dataIndex: number;
-        item: TData;
-    }, parallaxData: {
-        scrollPosition: Animated.Value | undefined;
-        carouselRef: ScrollView | FlatList<TData> | null;
-        vertical: true;
-        itemHeight: number;
-        sliderHeight: number;
-    }) => ReactNode;
-};
-declare type HorizontalCarouselProps<TData> = {
-    vertical: false | undefined;
-    itemWidth: number;
-    sliderWidth: number;
-    renderItem: (baseData: {
-        index: number;
-        dataIndex: number;
-        item: TData;
-    }, parallaxData: {
-        scrollPosition: Animated.Value | undefined;
-        carouselRef: ScrollView | FlatList<TData> | null;
-        vertical: false;
-        itemWidth: number;
-        sliderWidth: number;
-    }) => ReactNode;
-};
-export declare type CarouselProps<TData> = CarouselBaseProps<TData> & (HorizontalCarouselProps<TData> | VerticalCarouselProps<TData>) & InheritedPropsFromFlatlist<TData>;
-export declare type CarouselState = {
-    hideCarousel: boolean;
-    interpolators: (Animated.Value | Animated.AnimatedInterpolation)[];
-};
-export {};
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/index.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/index.d.ts
deleted file mode 100644
index bca3219..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/index.d.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-import Carousel from './carousel/Carousel';
-import Pagination from './pagination/Pagination';
-import ParallaxImage, { ParallaxImageStatus } from './parallaximage/ParallaxImage';
-import { getInputRangeFromIndexes } from './utils/animations';
-export { Carousel as default, Carousel, Pagination, ParallaxImage, ParallaxImageStatus, getInputRangeFromIndexes };
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.d.ts
deleted file mode 100644
index 9adf183..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.d.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import React, { PureComponent, ReactElement } from 'react';
-import { StyleProp, ViewStyle } from 'react-native';
-import type Carousel from 'src/carousel/Carousel';
-declare type PaginationProps<TData> = {
-    activeDotIndex: number;
-    dotsLength: number;
-    activeOpacity?: number;
-    carouselRef?: Carousel<TData> | null;
-    containerStyle?: StyleProp<ViewStyle>;
-    dotColor?: string;
-    dotContainerStyle?: StyleProp<ViewStyle>;
-    dotElement?: ReactElement;
-    dotStyle?: StyleProp<ViewStyle>;
-    inactiveDotColor?: string;
-    inactiveDotElement?: ReactElement;
-    inactiveDotOpacity: number;
-    inactiveDotScale: number;
-    inactiveDotStyle?: StyleProp<ViewStyle>;
-    renderDots?: (activeIndex: number, length: number, context: Pagination<TData>) => ReactElement;
-    tappableDots: boolean;
-    vertical: boolean;
-    accessibilityLabel?: string;
-    animatedDuration: number;
-    animatedFriction: number;
-    animatedTension: number;
-    delayPressInDot: number;
-};
-export default class Pagination<TData> extends PureComponent<PaginationProps<TData>> {
-    static defaultProps: {
-        inactiveDotOpacity: number;
-        inactiveDotScale: number;
-        tappableDots: boolean;
-        vertical: boolean;
-        animatedDuration: number;
-        animatedFriction: number;
-        animatedTension: number;
-        delayPressInDot: number;
-    };
-    constructor(props: PaginationProps<TData>);
-    _needsRTLAdaptations(): boolean;
-    get _activeDotIndex(): number;
-    get dots(): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | React.FunctionComponentElement<any>[];
-    render(): false | JSX.Element;
-}
-export {};
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.style.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.style.d.ts
deleted file mode 100644
index 8d1d589..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/pagination/Pagination.style.d.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-declare const _default: {
-    sliderPagination: {
-        alignItems: "center";
-        justifyContent: "center";
-        paddingHorizontal: number;
-        paddingVertical: number;
-    };
-    sliderPaginationDotContainer: {
-        alignItems: "center";
-        justifyContent: "center";
-        marginHorizontal: number;
-    };
-    sliderPaginationDot: {
-        width: number;
-        height: number;
-        borderRadius: number;
-        backgroundColor: string;
-    };
-};
-export default _default;
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/pagination/PaginationDot.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/pagination/PaginationDot.d.ts
deleted file mode 100644
index 3fc0d5a..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/pagination/PaginationDot.d.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-import { PureComponent, RefObject } from 'react';
-import { Animated, StyleProp, ViewStyle } from 'react-native';
-import type Carousel from 'src/carousel/Carousel';
-declare type PaginationDotProps<TData> = {
-    inactiveOpacity: number;
-    inactiveScale: number;
-    active?: boolean;
-    activeOpacity?: number;
-    animatedDuration?: number;
-    animatedFriction?: number;
-    animatedTension?: number;
-    carouselRef?: Carousel<TData> | RefObject<Carousel<TData>> | null;
-    color?: string;
-    containerStyle?: StyleProp<ViewStyle>;
-    delayPressInDot?: number;
-    inactiveColor?: string;
-    inactiveStyle?: StyleProp<ViewStyle>;
-    index?: number;
-    style?: StyleProp<ViewStyle>;
-    tappable?: boolean;
-};
-declare type PaginationDotState = {
-    animColor: Animated.Value;
-    animOpacity: Animated.Value;
-    animTransform: Animated.Value;
-};
-export default class PaginationDot<TData> extends PureComponent<PaginationDotProps<TData>, PaginationDotState> {
-    constructor(props: PaginationDotProps<TData>);
-    componentDidMount(): void;
-    componentDidUpdate(prevProps: PaginationDotProps<TData>): void;
-    _animate(toValue?: number): void;
-    get _shouldAnimateColor(): string | undefined;
-    render(): JSX.Element;
-}
-export {};
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.d.ts
deleted file mode 100644
index 3340d31..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.d.ts
+++ /dev/null
@@ -1,64 +0,0 @@
-import { Component } from 'react';
-import { View, Animated, findNodeHandle, ImageProps, StyleProp, ViewStyle, NativeSyntheticEvent, ImageLoadEventData, ImageErrorEventData } from 'react-native';
-declare type VerticalProps = {
-    vertical: true;
-    sliderHeight: number;
-    itemHeight: number;
-};
-declare type HorizontalProps = {
-    vertical: false;
-    sliderWidth: number;
-    itemWidth: number;
-};
-declare type ParallaxImageProps = {
-    carouselRef: Parameters<typeof findNodeHandle>[0];
-    scrollPosition: Animated.Value | undefined;
-    containerStyle: StyleProp<ViewStyle>;
-    dimensions?: {
-        width: number;
-        height: number;
-    };
-    fadeDuration: number;
-    parallaxFactor: number;
-    showSpinner: boolean;
-    spinnerColor: string;
-    AnimatedImageComponent: typeof Animated.Image;
-} & ImageProps & (VerticalProps | HorizontalProps);
-export declare enum ParallaxImageStatus {
-    'LOADING' = 1,
-    'LOADED' = 2,
-    'TRANSITION_FINISHED' = 3,
-    'ERROR' = 4
-}
-declare type ParallaxImageState = {
-    offset: number;
-    width: number;
-    height: number;
-    status: ParallaxImageStatus;
-    animOpacity: Animated.Value;
-};
-export default class ParallaxImage extends Component<ParallaxImageProps, ParallaxImageState> {
-    static defaultProps: {
-        containerStyle: {};
-        fadeDuration: number;
-        parallaxFactor: number;
-        showSpinner: boolean;
-        spinnerColor: string;
-        AnimatedImageComponent: Animated.AnimatedComponent<typeof import("react-native").Image>;
-    };
-    _container?: View | null;
-    _mounted?: boolean;
-    constructor(props: ParallaxImageProps);
-    setNativeProps(nativeProps: {
-        [key: string]: unknown;
-    }): void;
-    componentDidMount(): void;
-    componentWillUnmount(): void;
-    _measureLayout(): void;
-    _onLoad(event: NativeSyntheticEvent<ImageLoadEventData>): void;
-    _onError(event: NativeSyntheticEvent<ImageErrorEventData>): void;
-    get image(): JSX.Element;
-    get spinner(): false | JSX.Element;
-    render(): JSX.Element;
-}
-export {};
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.style.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.style.d.ts
deleted file mode 100644
index 52e370b..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/parallaximage/ParallaxImage.style.d.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-declare const _default: {
-    container: {
-        overflow: "hidden";
-        alignItems: "center";
-        justifyContent: "center";
-    };
-    image: {
-        position: "relative";
-        resizeMode: "cover";
-        width: undefined;
-        height: undefined;
-    };
-    loaderContainer: {
-        alignItems: "center";
-        justifyContent: "center";
-        position: "absolute";
-        left: 0;
-        right: 0;
-        top: 0;
-        bottom: 0;
-    };
-};
-export default _default;
diff --git a/node_modules/react-native-snap-carousel/lib/typescript/utils/animations.d.ts b/node_modules/react-native-snap-carousel/lib/typescript/utils/animations.d.ts
deleted file mode 100644
index 15cde25..0000000
--- a/node_modules/react-native-snap-carousel/lib/typescript/utils/animations.d.ts
+++ /dev/null
@@ -1,67 +0,0 @@
-import { Animated } from 'react-native';
-import type { CarouselProps } from 'src/carousel/types';
-export declare function getInputRangeFromIndexes<TData>(range: number[], index: number, carouselProps: CarouselProps<TData>): number[];
-export declare function defaultScrollInterpolator<TData>(index: number, carouselProps: CarouselProps<TData>): {
-    inputRange: number[];
-    outputRange: number[];
-};
-export declare function defaultAnimatedStyles<TData>(_index: number, animatedValue: Animated.AnimatedInterpolation, carouselProps: CarouselProps<TData>): {};
-export declare function shiftAnimatedStyles<TData>(_index: number, animatedValue: Animated.AnimatedInterpolation, carouselProps: CarouselProps<TData>): {
-    transform: {}[];
-};
-export declare function stackScrollInterpolator<TData>(index: number, carouselProps: CarouselProps<TData>): {
-    inputRange: number[];
-    outputRange: number[];
-};
-export declare function stackAnimatedStyles<TData>(index: number, animatedValue: Animated.AnimatedInterpolation, carouselProps: CarouselProps<TData>, cardOffset?: number): {
-    opacity: Animated.AnimatedInterpolation;
-    transform: ({
-        scale: Animated.AnimatedInterpolation;
-    } | {
-        [x: string]: Animated.AnimatedInterpolation;
-        scale?: undefined;
-    })[];
-    zIndex?: undefined;
-} | {
-    zIndex: number;
-    opacity: Animated.AnimatedInterpolation;
-    transform: ({
-        scale: Animated.AnimatedInterpolation;
-    } | {
-        [x: string]: Animated.AnimatedInterpolation;
-        scale?: undefined;
-    })[];
-};
-export declare function tinderScrollInterpolator<TData>(index: number, carouselProps: CarouselProps<TData>): {
-    inputRange: number[];
-    outputRange: number[];
-};
-export declare function tinderAnimatedStyles<TData>(index: number, animatedValue: Animated.AnimatedInterpolation, carouselProps: CarouselProps<TData>, cardOffset?: number): {
-    opacity: Animated.AnimatedInterpolation;
-    transform: ({
-        scale: Animated.AnimatedInterpolation;
-        rotate?: undefined;
-    } | {
-        rotate: Animated.AnimatedInterpolation;
-        scale?: undefined;
-    } | {
-        [x: string]: Animated.AnimatedInterpolation;
-        scale?: undefined;
-        rotate?: undefined;
-    })[];
-    zIndex?: undefined;
-} | {
-    zIndex: number;
-    opacity: Animated.AnimatedInterpolation;
-    transform: ({
-        scale: Animated.AnimatedInterpolation;
-        rotate?: undefined;
-    } | {
-        rotate: Animated.AnimatedInterpolation;
-        scale?: undefined;
-    } | {
-        [x: string]: Animated.AnimatedInterpolation;
-        scale?: undefined;
-        rotate?: undefined;
-    })[];
-};
diff --git a/node_modules/react-native-snap-carousel/src/carousel/Carousel.js b/node_modules/react-native-snap-carousel/src/carousel/Carousel.js
new file mode 100644
index 0000000..fe68516
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/src/carousel/Carousel.js
@@ -0,0 +1,1161 @@
+import React, { Component } from 'react';
+import { Animated, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';
+import PropTypes from 'prop-types';
+import shallowCompare from 'react-addons-shallow-compare';
+import {
+    defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles,
+    shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles
+} from '../utils/animations';
+
+// Metro doesn't support dynamic imports - i.e. require() done in the component itself
+// But at the same time the following import will fail on Snack...
+// TODO: find a way to get React Native's version without having to assume the file path
+// import RN_PACKAGE from '../../../react-native/package.json';
+
+const IS_ANDROID = Platform.OS === 'android';
+
+// Native driver for scroll events
+// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html
+const AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;
+const AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);
+
+// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView
+// See https://github.com/facebook/react-native/issues/11960
+// NOTE: the following variable is not declared in the constructor
+// otherwise it is undefined at init, which messes with custom indexes
+const IS_RTL = I18nManager.isRTL;
+
+export default class Carousel extends Component {
+
+    static propTypes = {
+        data: PropTypes.array.isRequired,
+        renderItem: PropTypes.func.isRequired,
+        itemWidth: PropTypes.number, // required for horizontal carousel
+        itemHeight: PropTypes.number, // required for vertical carousel
+        sliderWidth: PropTypes.number, // required for horizontal carousel
+        sliderHeight: PropTypes.number, // required for vertical carousel
+        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),
+        activeSlideOffset: PropTypes.number,
+        apparitionDelay: PropTypes.number,
+        autoplay: PropTypes.bool,
+        autoplayDelay: PropTypes.number,
+        autoplayInterval: PropTypes.number,
+        callbackOffsetMargin: PropTypes.number,
+        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        enableSnap: PropTypes.bool,
+        firstItem: PropTypes.number,
+        hasParallaxImages: PropTypes.bool,
+        inactiveSlideOpacity: PropTypes.number,
+        inactiveSlideScale: PropTypes.number,
+        inactiveSlideShift: PropTypes.number,
+        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),
+        layoutCardOffset: PropTypes.number,
+        loop: PropTypes.bool,
+        loopClonesPerSide: PropTypes.number,
+        scrollEnabled: PropTypes.bool,
+        scrollInterpolator: PropTypes.func,
+        slideInterpolatedStyle: PropTypes.func,
+        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        shouldOptimizeUpdates: PropTypes.bool,
+        useExperimentalSnap: PropTypes.bool,
+        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
+        vertical: PropTypes.bool,
+        onScrollIndexChanged: PropTypes.func,
+        onSnapToItem: PropTypes.func
+    };
+
+    static defaultProps = {
+        activeSlideAlignment: 'center',
+        activeSlideOffset: 20,
+        apparitionDelay: 0,
+        autoplay: false,
+        autoplayDelay: 1000,
+        autoplayInterval: 3000,
+        callbackOffsetMargin: 5,
+        containerCustomStyle: {},
+        contentContainerCustomStyle: {},
+        enableSnap: true,
+        firstItem: 0,
+        hasParallaxImages: false,
+        inactiveSlideOpacity: 0.7,
+        inactiveSlideScale: 0.9,
+        inactiveSlideShift: 0,
+        layout: 'default',
+        loop: false,
+        loopClonesPerSide: 3,
+        scrollEnabled: true,
+        slideStyle: {},
+        shouldOptimizeUpdates: true,
+        useExperimentalSnap: false,
+        useScrollView: !AnimatedFlatList,
+        vertical: false
+    }
+
+    constructor (props) {
+        super(props);
+
+        this.state = {
+            hideCarousel: !!props.apparitionDelay,
+            interpolators: []
+        };
+
+        // this._RNVersionCode = this._getRNVersionCode();
+
+        // The following values are not stored in the state because 'setState()' is asynchronous
+        // and this results in an absolutely crappy behavior on Android while swiping (see #156)
+        const initialActiveItem = this._getFirstItem(props.firstItem);
+        this._activeItem = initialActiveItem;
+        this._onScrollActiveItem = initialActiveItem;
+        this._previousFirstItem = initialActiveItem;
+        this._previousItemsLength = initialActiveItem;
+
+        this._mounted = false;
+        this._positions = [];
+        this._currentScrollOffset = 0; // Store ScrollView's scroll position
+        this._scrollEnabled = props.scrollEnabled !== false;
+
+        this._getCellRendererComponent = this._getCellRendererComponent.bind(this);
+        this._getItemLayout = this._getItemLayout.bind(this);
+        this._getKeyExtractor = this._getKeyExtractor.bind(this);
+        this._onLayout = this._onLayout.bind(this);
+        this._onScroll = this._onScroll.bind(this);
+        this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);
+        this._onTouchStart = this._onTouchStart.bind(this);
+        this._onTouchEnd = this._onTouchEnd.bind(this);
+        this._renderItem = this._renderItem.bind(this);
+
+        // WARNING: call this AFTER binding _onScroll
+        this._setScrollHandler(props);
+
+        // Display warnings
+        this._displayWarnings(props);
+    }
+
+    componentDidMount () {
+        const { apparitionDelay, autoplay, firstItem } = this.props;
+
+        this._mounted = true;
+        this._initPositionsAndInterpolators();
+
+        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...
+        this._initTimeout = setTimeout(() => {
+            if (!this._mounted) {
+                return;
+            }
+
+            const apparitionCallback = () => {
+                if (apparitionDelay) {
+                    this.setState({ hideCarousel: false });
+                }
+                if (autoplay) {
+                    this.startAutoplay();
+                }
+            };
+
+            // FlatList will use its own built-in prop `initialScrollIndex`
+            if (this._needsScrollView()) {
+                const _firstItem = this._getFirstItem(firstItem);
+                this._snapToItem(_firstItem, false, false, true);
+                // this._hackActiveSlideAnimation(_firstItem);
+            }
+
+            if (apparitionDelay) {
+                this._apparitionTimeout = setTimeout(() => {
+                    apparitionCallback();
+                }, apparitionDelay);
+            } else {
+                apparitionCallback();
+            }
+        }, 1);
+    }
+
+    shouldComponentUpdate (nextProps, nextState) {
+        if (this.props.shouldOptimizeUpdates === false) {
+            return true;
+        } else {
+            return shallowCompare(this, nextProps, nextState);
+        }
+    }
+
+    componentDidUpdate (prevProps) {
+        const { interpolators } = this.state;
+        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;
+        const itemsLength = this._getCustomDataLength(this.props);
+
+        if (!itemsLength) {
+            return;
+        }
+
+        const nextFirstItem = this._getFirstItem(firstItem, this.props);
+        let nextActiveItem = typeof this._activeItem !== 'undefined' ? this._activeItem : nextFirstItem;
+
+        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;
+        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;
+        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;
+        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;
+        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;
+
+        // Prevent issues with dynamically removed items
+        if (nextActiveItem > itemsLength - 1) {
+            nextActiveItem = itemsLength - 1;
+        }
+
+        // Handle changing scrollEnabled independent of user -> carousel interaction
+        if (hasNewScrollEnabled) {
+            this._setScrollEnabled(scrollEnabled);
+        }
+
+        if (interpolators.length !== itemsLength || hasNewSliderWidth ||
+            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {
+            this._activeItem = nextActiveItem;
+            this._previousItemsLength = itemsLength;
+
+            this._initPositionsAndInterpolators(this.props);
+
+            // Handle scroll issue when dynamically removing items (see #133)
+            // This also fixes first item's active state on Android
+            // Because 'initialScrollIndex' apparently doesn't trigger scroll
+            if (this._previousItemsLength > itemsLength) {
+                this._hackActiveSlideAnimation(nextActiveItem);
+            }
+
+            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {
+                this._snapToItem(nextActiveItem, false, false, true);
+            }
+        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {
+            this._activeItem = nextFirstItem;
+            this._previousFirstItem = nextFirstItem;
+            this._snapToItem(nextFirstItem, false, true, true);
+        }
+
+        if (this.props.onScroll !== prevProps.onScroll) {
+            this._setScrollHandler(this.props);
+        }
+    }
+
+    componentWillUnmount () {
+        this._mounted = false;
+        this.stopAutoplay();
+        clearTimeout(this._initTimeout);
+        clearTimeout(this._apparitionTimeout);
+        clearTimeout(this._hackSlideAnimationTimeout);
+        clearTimeout(this._enableAutoplayTimeout);
+        clearTimeout(this._autoplayTimeout);
+        clearTimeout(this._snapNoMomentumTimeout);
+        clearTimeout(this._androidRepositioningTimeout);
+    }
+
+    get realIndex () {
+        return this._activeItem;
+    }
+
+    get currentIndex () {
+        return this._getDataIndex(this._activeItem);
+    }
+
+    get currentScrollPosition () {
+        return this._currentScrollOffset;
+    }
+
+    _setScrollHandler (props) {
+        // Native driver for scroll events
+        const scrollEventConfig = {
+            listener: this._onScroll,
+            useNativeDriver: true
+        };
+        this._scrollPos = new Animated.Value(0);
+        const argMapping = props.vertical ?
+            [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :
+            [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];
+
+        if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {
+            // Because of a react-native issue https://github.com/facebook/react-native/issues/13294
+            argMapping.pop();
+            const [argMap] = props.onScroll._argMapping;
+            if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {
+                // Shares the same animated value passed in props
+                this._scrollPos =
+                argMap.nativeEvent.contentOffset.x ||
+                argMap.nativeEvent.contentOffset.y ||
+                this._scrollPos;
+            }
+            argMapping.push(...props.onScroll._argMapping);
+        }
+        this._onScrollHandler = Animated.event(
+            argMapping,
+            scrollEventConfig
+        );
+    }
+
+    // This will return a future-proof version code number compatible with semantic versioning
+    // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002
+    // _getRNVersionCode () {
+    //     const version = RN_PACKAGE && RN_PACKAGE.version;
+    //     if (!version) {
+    //         return null;
+    //     }
+    //     const versionSplit = version.split('.');
+    //     if (!versionSplit || !versionSplit.length) {
+    //         return null;
+    //     }
+    //     return versionSplit[0] * 10000 +
+    //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +
+    //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);
+    // }
+
+    _displayWarnings (props = this.props) {
+        const pluginName = 'react-native-snap-carousel';
+        const removedProps = [
+            'activeAnimationType',
+            'activeAnimationOptions',
+            'enableMomentum',
+            'lockScrollTimeoutDuration',
+            'lockScrollWhileSnapping',
+            'onBeforeSnapToItem',
+            'swipeThreshold'
+        ];
+
+        // if (this._RNVersionCode && this._RNVersionCode < 5800) {
+        //     console.error(
+        //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +
+        //         'Please downgrade to version 3.x or update your version of React Native.'
+        //     );
+        // }
+        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {
+            console.error(`${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`);
+        }
+        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {
+            console.error(`${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`);
+        }
+
+        removedProps.forEach((removedProp) => {
+            if (props[removedProp]) {
+                console.warn(`${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`);
+            }
+        });
+    }
+
+    _needsScrollView () {
+        const { useScrollView } = this.props;
+        // Android's cell renderer is buggy and has a stange overflow
+        // TODO: a workaround might be to pass the custom animated styles directly to it
+        return IS_ANDROID ?
+            useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout() :
+            useScrollView || !AnimatedFlatList;
+    }
+
+    _needsRTLAdaptations () {
+        const { vertical } = this.props;
+        return IS_RTL && IS_ANDROID && !vertical;
+    }
+
+    _enableLoop () {
+        const { data, enableSnap, loop } = this.props;
+        return enableSnap && loop && data && data.length && data.length > 1;
+    }
+
+    _shouldAnimateSlides (props = this.props) {
+        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;
+        return inactiveSlideOpacity < 1 ||
+            inactiveSlideScale < 1 ||
+            !!scrollInterpolator ||
+            !!slideInterpolatedStyle ||
+            this._shouldUseShiftLayout() ||
+            this._shouldUseStackLayout() ||
+            this._shouldUseTinderLayout();
+    }
+
+    _shouldUseShiftLayout () {
+        const { inactiveSlideShift, layout } = this.props;
+        return layout === 'default' && inactiveSlideShift !== 0;
+    }
+
+    _shouldUseStackLayout () {
+        return this.props.layout === 'stack';
+    }
+
+    _shouldUseTinderLayout () {
+        return this.props.layout === 'tinder';
+    }
+
+    _shouldRepositionScroll (index) {
+        const { data, enableSnap, loopClonesPerSide } = this.props;
+        const dataLength = data && data.length;
+        if (!enableSnap || !dataLength || !this._enableLoop() ||
+            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {
+            return false;
+        }
+        return true;
+    }
+
+    _roundNumber (num, decimals = 1) {
+        // https://stackoverflow.com/a/41716722/
+        const rounder = Math.pow(10, decimals);
+        return Math.round((num + Number.EPSILON) * rounder) / rounder;
+    }
+
+    _isMultiple (x, y) {
+        // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/
+        // Required because Android viewport size can return pretty complicated decimals numbers
+        return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);
+    }
+
+    _getCustomData (props = this.props) {
+        const { data, loopClonesPerSide } = props;
+        const dataLength = data && data.length;
+
+        if (!dataLength) {
+            return [];
+        }
+
+        if (!this._enableLoop()) {
+            return data;
+        }
+
+        let previousItems = [];
+        let nextItems = [];
+
+        if (loopClonesPerSide > dataLength) {
+            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
+            const remainder = loopClonesPerSide % dataLength;
+
+            for (let i = 0; i < dataMultiplier; i++) {
+                previousItems.push(...data);
+                nextItems.push(...data);
+            }
+
+            previousItems.unshift(...data.slice(-remainder));
+            nextItems.push(...data.slice(0, remainder));
+        } else {
+            previousItems = data.slice(-loopClonesPerSide);
+            nextItems = data.slice(0, loopClonesPerSide);
+        }
+
+        return previousItems.concat(data, nextItems);
+    }
+
+    _getCustomDataLength (props = this.props) {
+        const { data, loopClonesPerSide } = props;
+        const dataLength = data && data.length;
+
+        if (!dataLength) {
+            return 0;
+        }
+
+        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;
+    }
+
+    _getCustomIndex (index, props = this.props) {
+        const itemsLength = this._getCustomDataLength(props);
+
+        if (!itemsLength || typeof index === 'undefined') {
+            return 0;
+        }
+
+        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;
+    }
+
+    _getDataIndex (index) {
+        const { data, loopClonesPerSide } = this.props;
+        const dataLength = data && data.length;
+
+        if (!this._enableLoop() || !dataLength) {
+            return index;
+        }
+
+        if (index >= dataLength + loopClonesPerSide) {
+            return loopClonesPerSide > dataLength ?
+                (index - loopClonesPerSide) % dataLength :
+                index - dataLength - loopClonesPerSide;
+        } else if (index < loopClonesPerSide) {
+            // TODO: is there a simpler way of determining the interpolated index?
+            if (loopClonesPerSide > dataLength) {
+                const baseDataIndexes = [];
+                const dataIndexes = [];
+                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
+                const remainder = loopClonesPerSide % dataLength;
+
+                for (let i = 0; i < dataLength; i++) {
+                    baseDataIndexes.push(i);
+                }
+
+                for (let j = 0; j < dataMultiplier; j++) {
+                    dataIndexes.push(...baseDataIndexes);
+                }
+
+                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));
+                return dataIndexes[index];
+            } else {
+                return index + dataLength - loopClonesPerSide;
+            }
+        } else {
+            return index - loopClonesPerSide;
+        }
+    }
+
+    // Used with `snapToItem()` and 'PaginationDot'
+    _getPositionIndex (index) {
+        const { loop, loopClonesPerSide } = this.props;
+        return loop ? index + loopClonesPerSide : index;
+    }
+
+    _getSnapOffsets (props = this.props) {
+        const offset = this._getItemMainDimension();
+        return [...Array(this._getCustomDataLength(props))].map((_, i) => {
+            return i * offset;
+        });
+    }
+
+    _getFirstItem (index, props = this.props) {
+        const { loopClonesPerSide } = props;
+        const itemsLength = this._getCustomDataLength(props);
+
+        if (!itemsLength || index > itemsLength - 1 || index < 0) {
+            return 0;
+        }
+
+        return this._enableLoop() ? index + loopClonesPerSide : index;
+    }
+
+    _getWrappedRef () {
+        // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component
+        if (this._carouselRef && (
+            (this._needsScrollView() && this._carouselRef.scrollTo) ||
+            (!this._needsScrollView() && this._carouselRef.scrollToOffset)
+        )) {
+            return this._carouselRef;
+        }
+        // https://github.com/facebook/react-native/issues/10635
+        // https://stackoverflow.com/a/48786374/8412141
+        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();
+    }
+
+    _getScrollEnabled () {
+        return this._scrollEnabled;
+    }
+
+    _setScrollEnabled (scrollEnabled = true) {
+        const wrappedRef = this._getWrappedRef();
+
+        if (!wrappedRef || !wrappedRef.setNativeProps) {
+            return;
+        }
+
+        // 'setNativeProps()' is used instead of 'setState()' because the latter
+        // really takes a toll on Android behavior when momentum is disabled
+        wrappedRef.setNativeProps({ scrollEnabled });
+        this._scrollEnabled = scrollEnabled;
+    }
+
+    _getItemMainDimension () {
+        const { itemWidth, itemHeight, vertical } = this.props;
+        return vertical ? itemHeight : itemWidth;
+    }
+
+    _getItemScrollOffset (index) {
+        return this._positions && this._positions[index] && this._positions[index].start;
+    }
+
+    _getItemLayout (_, index) {
+        const itemMainDimension = this._getItemMainDimension();
+        return {
+            index,
+            length: itemMainDimension,
+            offset: itemMainDimension * index // + this._getContainerInnerMargin()
+        };
+    }
+
+    // This will allow us to have a proper zIndex even with a FlatList
+    // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165
+    _getCellRendererComponent ({ children, index, style, ...props }) {
+        const cellStyle = [
+            style,
+            !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}
+        ];
+
+        return (
+            <View style={cellStyle} index={index} {...props}>
+                {children}
+            </View>
+        );
+    }
+
+    _getKeyExtractor (_, index) {
+        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;
+    }
+
+    _getScrollOffset (event) {
+        const { vertical } = this.props;
+        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&
+            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;
+    }
+
+    _getContainerInnerMargin (opposite = false) {
+        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;
+
+        if ((activeSlideAlignment === 'start' && !opposite) ||
+            (activeSlideAlignment === 'end' && opposite)) {
+            return 0;
+        } else if ((activeSlideAlignment === 'end' && !opposite) ||
+            (activeSlideAlignment === 'start' && opposite)) {
+            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;
+        } else {
+            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;
+        }
+    }
+
+    _getActiveSlideOffset () {
+        const { activeSlideOffset } = this.props;
+        const itemMainDimension = this._getItemMainDimension();
+        const minOffset = 10;
+        // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide
+        return itemMainDimension / 2 - activeSlideOffset >= minOffset ? activeSlideOffset : minOffset;
+    }
+
+    _getActiveItem (offset) {
+        const itemMainDimension = this._getItemMainDimension();
+        const center = offset + itemMainDimension / 2;
+        const activeSlideOffset = this._getActiveSlideOffset();
+        const lastIndex = this._positions.length - 1;
+        let itemIndex;
+
+        if (offset <= 0) {
+            return 0;
+        }
+
+        if (this._positions[lastIndex] && offset >= this._positions[lastIndex].start) {
+            return lastIndex;
+        }
+
+        for (let i = 0; i < this._positions.length; i++) {
+            const { start, end } = this._positions[i];
+            if (center + activeSlideOffset >= start && center - activeSlideOffset <= end) {
+                itemIndex = i;
+                break;
+            }
+        }
+
+        return itemIndex || 0;
+    }
+
+    _getSlideInterpolatedStyle (index, animatedValue) {
+        const { layoutCardOffset, slideInterpolatedStyle } = this.props;
+
+        if (slideInterpolatedStyle) {
+            return slideInterpolatedStyle(index, animatedValue, this.props);
+        } else if (this._shouldUseTinderLayout()) {
+            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);
+        } else if (this._shouldUseStackLayout()) {
+            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);
+        } else if (this._shouldUseShiftLayout()) {
+            return shiftAnimatedStyles(index, animatedValue, this.props);
+        } else {
+            return defaultAnimatedStyles(index, animatedValue, this.props);
+        }
+    }
+
+    _initPositionsAndInterpolators (props = this.props) {
+        const { data, scrollInterpolator } = props;
+        const itemMainDimension = this._getItemMainDimension();
+
+        if (!data || !data.length) {
+            return;
+        }
+
+        const interpolators = [];
+        this._positions = [];
+
+        this._getCustomData(props).forEach((itemData, index) => {
+            const _index = this._getCustomIndex(index, props);
+            let animatedValue;
+
+            this._positions[index] = {
+                start: index * itemMainDimension,
+                end: index * itemMainDimension + itemMainDimension
+            };
+
+            if (!this._shouldAnimateSlides(props)) {
+                animatedValue = new Animated.Value(1);
+            } else {
+                let interpolator;
+
+                if (scrollInterpolator) {
+                    interpolator = scrollInterpolator(_index, props);
+                } else if (this._shouldUseStackLayout()) {
+                    interpolator = stackScrollInterpolator(_index, props);
+                } else if (this._shouldUseTinderLayout()) {
+                    interpolator = tinderScrollInterpolator(_index, props);
+                }
+
+                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {
+                    interpolator = defaultScrollInterpolator(_index, props);
+                }
+
+                animatedValue = this._scrollPos.interpolate({
+                    ...interpolator,
+                    extrapolate: 'clamp'
+                });
+            }
+
+            interpolators.push(animatedValue);
+        });
+
+        this.setState({ interpolators });
+    }
+
+    _hackActiveSlideAnimation (index, scrollValue = 1) {
+        const offset = this._getItemScrollOffset(index);
+
+        if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {
+            return;
+        }
+
+        const multiplier = this._currentScrollOffset === 0 ? 1 : -1;
+        const scrollDelta = scrollValue * multiplier;
+
+        this._scrollTo({ offset: offset + scrollDelta, animated: false });
+
+        clearTimeout(this._hackSlideAnimationTimeout);
+        this._hackSlideAnimationTimeout = setTimeout(() => {
+            this._scrollTo({ offset, animated: false });
+        }, 1); // works randomly when set to '0'
+    }
+
+    _repositionScroll (index, animated = false) {
+        const { data, loopClonesPerSide } = this.props;
+        const dataLength = data && data.length;
+
+        if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {
+            return;
+        }
+
+        let repositionTo = index;
+
+        if (index >= dataLength + loopClonesPerSide) {
+            repositionTo = index - dataLength;
+        } else if (index < loopClonesPerSide) {
+            repositionTo = index + dataLength;
+        }
+
+        this._snapToItem(repositionTo, animated, false);
+    }
+
+    _scrollTo ({ offset, index, animated = true }) {
+        const { vertical } = this.props;
+        const wrappedRef = this._getWrappedRef();
+        if (!this._mounted || !wrappedRef || (typeof offset === 'undefined' && typeof index === 'undefined')) {
+            return;
+        }
+
+        let scrollToOffset;
+        if (typeof index !== 'undefined') {
+            scrollToOffset = this._getItemScrollOffset(index);
+        } else {
+            scrollToOffset = offset;
+        }
+
+        if (typeof scrollToOffset === 'undefined') {
+            return;
+        }
+
+        const options = this._needsScrollView() ? {
+            x: vertical ? 0 : offset,
+            y: vertical ? offset : 0,
+            animated
+        } : {
+            offset,
+            animated
+        };
+
+        if (this._needsScrollView()) {
+            wrappedRef.scrollTo(options);
+        } else {
+            wrappedRef.scrollToOffset(options);
+        }
+    }
+
+    _onTouchStart () {
+        const { onTouchStart } = this.props;
+
+        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`
+        if (this._getScrollEnabled() !== false && this._autoplaying) {
+            this.pauseAutoPlay();
+        }
+
+        onTouchStart && onTouchStart();
+    }
+
+    _onTouchEnd () {
+        const { onTouchEnd } = this.props;
+
+        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {
+            // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()
+            this.startAutoplay();
+        }
+
+        onTouchEnd && onTouchEnd();
+    }
+
+    _onScroll (event) {
+        const { onScroll, onScrollIndexChanged } = this.props;
+        const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
+        const nextActiveItem = this._getActiveItem(scrollOffset);
+
+        this._currentScrollOffset = scrollOffset;
+
+        if (nextActiveItem !== this._onScrollActiveItem) {
+            this._onScrollActiveItem = nextActiveItem;
+            onScrollIndexChanged && onScrollIndexChanged(this._getDataIndex(nextActiveItem));
+        }
+
+        if (typeof onScroll === 'function' && event) {
+            onScroll(event);
+        }
+    }
+
+    _onMomentumScrollEnd (event) {
+        const { autoplayDelay, itemWidth, onMomentumScrollEnd, onSnapToItem } = this.props;
+        const scrollOffset = event ? this._getScrollOffset(event) : this._currentScrollOffset;
+        const nextActiveItem = this._getActiveItem(scrollOffset);
+        const hasSnapped = this._isMultiple(scrollOffset, itemWidth);
+
+        // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:
+        // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated
+        // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically
+        if (nextActiveItem !== this._activeItem) {
+            this._activeItem = nextActiveItem;
+            onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));
+
+            if (hasSnapped) {
+                this._repositionScroll(nextActiveItem);
+            }
+        }
+
+        onMomentumScrollEnd && onMomentumScrollEnd(event);
+
+        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed
+        // https://github.com/facebook/react-native/issues/9439
+        if (IS_ANDROID && this._autoplay && !this._autoplaying) {
+            clearTimeout(this._enableAutoplayTimeout);
+            this._enableAutoplayTimeout = setTimeout(() => {
+                this.startAutoplay();
+            }, autoplayDelay);
+        }
+
+    }
+
+    _onLayout (event) {
+        const { onLayout } = this.props;
+
+        // Prevent unneeded actions during the first 'onLayout' (triggered on init)
+        if (this._onLayoutInitDone) {
+            this._initPositionsAndInterpolators();
+            this._snapToItem(this._activeItem, false, false, true);
+        } else {
+            this._onLayoutInitDone = true;
+        }
+
+        onLayout && onLayout(event);
+    }
+
+    _snapToItem (index, animated = true, fireCallback = true, forceScrollTo = false) {
+        const { onSnapToItem, isForceIndex } = this.props;
+        const itemsLength = this._getCustomDataLength();
+        const wrappedRef = this._getWrappedRef();
+
+        if (!itemsLength || !wrappedRef) {
+            return;
+        }
+
+        if (!index || index < 0) {
+            index = 0;
+        } else if (itemsLength > 0 && index >= itemsLength) {
+            index = itemsLength - 1;
+        }
+
+        if (index === this._activeItem && !forceScrollTo && !isForceIndex) {
+            return;
+        }
+
+        const offset = this._getItemScrollOffset(index);
+
+        if (offset === undefined) {
+            return;
+        }
+
+        this._scrollTo({ offset, animated, index });
+
+        // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated
+        // so we need to trigger the callback manually
+        // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically
+        // Therefore everything critical needs to be manually called here as well, even though the timing might be off
+        const requiresManualTrigger = !animated || IS_ANDROID;
+        if (requiresManualTrigger) {
+            this._activeItem = index;
+
+            if (fireCallback) {
+                onSnapToItem && onSnapToItem(this._getDataIndex(index));
+            }
+
+            // Repositioning on Android
+            if (IS_ANDROID && this._shouldRepositionScroll(index)) {
+                if (animated) {
+                    this._androidRepositioningTimeout = setTimeout(() => {
+                        // Without scroll animation, the behavior is completely buggy...
+                        this._repositionScroll(index, true);
+                    }, 400); // Approximate scroll duration on Android
+                } else {
+                    this._repositionScroll(index);
+                }
+            }
+        }
+    }
+
+    startAutoplay () {
+        const { autoplayInterval, autoplayDelay } = this.props;
+        this._autoplay = true;
+
+        if (this._autoplaying) {
+            return;
+        }
+
+        clearTimeout(this._autoplayTimeout);
+        this._autoplayTimeout = setTimeout(() => {
+            this._autoplaying = true;
+            this._autoplayInterval = setInterval(() => {
+                if (this._autoplaying) {
+                    this.snapToNext();
+                }
+            }, autoplayInterval);
+        }, autoplayDelay);
+    }
+
+    pauseAutoPlay () {
+        this._autoplaying = false;
+        clearTimeout(this._autoplayTimeout);
+        clearTimeout(this._enableAutoplayTimeout);
+        clearInterval(this._autoplayInterval);
+    }
+
+    stopAutoplay () {
+        this._autoplay = false;
+        this.pauseAutoPlay();
+    }
+
+    snapToItem (index, animated = true, fireCallback = true) {
+        if (!index || index < 0) {
+            index = 0;
+        }
+
+        const positionIndex = this._getPositionIndex(index);
+        const { isForceIndex } = this.props;
+        if (positionIndex === this._activeItem && !isForceIndex) {
+            return;
+        }
+
+        this._snapToItem(positionIndex, animated, fireCallback);
+    }
+
+    snapToNext (animated = true, fireCallback = true) {
+        const itemsLength = this._getCustomDataLength();
+
+        let newIndex = this._activeItem + 1;
+        if (newIndex > itemsLength - 1) {
+            newIndex = 0;
+        }
+        this._snapToItem(newIndex, animated, fireCallback);
+    }
+
+    snapToPrev (animated = true, fireCallback = true) {
+        const itemsLength = this._getCustomDataLength();
+
+        let newIndex = this._activeItem - 1;
+        if (newIndex < 0) {
+            newIndex = itemsLength - 1;
+        }
+        this._snapToItem(newIndex, animated, fireCallback);
+    }
+
+    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668
+    triggerRenderingHack (offset = 1) {
+        this._hackActiveSlideAnimation(this._activeItem, offset);
+    }
+
+    _renderItem ({ item, index }) {
+        const { interpolators } = this.state;
+        const {
+            hasParallaxImages, itemWidth, itemHeight, keyExtractor, renderItem,
+            sliderHeight, sliderWidth, slideStyle, vertical
+        } = this.props;
+        const animatedValue = interpolators && interpolators[index];
+
+        if (typeof animatedValue === 'undefined') {
+            return null;
+        }
+
+        const animate = this._shouldAnimateSlides();
+        const Component = animate ? Animated.View : View;
+        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};
+        const dataIndex = this._getDataIndex(index);
+
+        const parallaxProps = hasParallaxImages ? {
+            scrollPosition: this._scrollPos,
+            carouselRef: this._carouselRef,
+            vertical,
+            sliderWidth,
+            sliderHeight,
+            itemWidth,
+            itemHeight
+        } : undefined;
+
+        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };
+        const specificProps = this._needsScrollView() ? {
+            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)
+        } : {};
+
+        return (
+            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>
+                { renderItem({ item, index, dataIndex }, parallaxProps) }
+            </Component>
+        );
+    }
+
+    _getComponentOverridableProps () {
+        const { hideCarousel } = this.state;
+        const {
+            itemWidth, itemHeight, loopClonesPerSide,
+            sliderWidth, sliderHeight, vertical
+        } = this.props;
+        const visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;
+        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;
+        const initialNumToRender = visibleItems + (initialNumPerSide * 2);
+        const maxToRenderPerBatch = initialNumToRender + (initialNumPerSide * 2);
+        const windowSize = maxToRenderPerBatch;
+
+        const specificProps = !this._needsScrollView() ? {
+            initialNumToRender,
+            maxToRenderPerBatch,
+            windowSize
+            // updateCellsBatchingPeriod
+        } : {};
+
+        return {
+            ...specificProps,
+            automaticallyAdjustContentInsets: false,
+            decelerationRate: 'fast',
+            directionalLockEnabled: true,
+            disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily
+            inverted: this._needsRTLAdaptations(),
+            overScrollMode: 'never',
+            pinchGestureEnabled: false,
+            pointerEvents: hideCarousel ? 'none' : 'auto',
+            // removeClippedSubviews: !this._needsScrollView(),
+            // renderToHardwareTextureAndroid: true,
+            scrollsToTop: false,
+            showsHorizontalScrollIndicator: false,
+            showsVerticalScrollIndicator: false
+        };
+    }
+
+    _getComponentStaticProps () {
+        const { hideCarousel } = this.state;
+        const {
+            activeSlideAlignment, CellRendererComponent, containerCustomStyle,
+            contentContainerCustomStyle, firstItem, getItemLayout, keyExtractor,
+            sliderWidth, sliderHeight, style, useExperimentalSnap, vertical
+        } = this.props;
+
+        const containerStyle = [
+            // { overflow: 'hidden' },
+            containerCustomStyle || style || {},
+            hideCarousel ? { opacity: 0 } : {},
+            vertical ?
+                { height: sliderHeight, flexDirection: 'column' } :
+                // LTR hack; see https://github.com/facebook/react-native/issues/11960
+                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423
+                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }
+        ];
+
+        const innerMarginStyle = vertical ? {
+            paddingTop: this._getContainerInnerMargin(),
+            paddingBottom: this._getContainerInnerMargin(true)
+        } : {
+            paddingLeft: this._getContainerInnerMargin(),
+            paddingRight: this._getContainerInnerMargin(true)
+        };
+
+        const contentContainerStyle = [
+            !useExperimentalSnap ? innerMarginStyle : {},
+            contentContainerCustomStyle || {}
+        ];
+
+        // WARNING: `snapToAlignment` won't work as intended because of the following:
+        // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755
+        // - Snap points will be off
+        // - Slide animations will be off
+        // - Last items won't be set as active (no `onSnapToItem` callback)
+        // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being
+        const snapProps = useExperimentalSnap ? {
+            // disableIntervalMomentum: true, // Slide ± one item at a time
+            snapToAlignment: activeSlideAlignment,
+            snapToInterval: this._getItemMainDimension()
+        } : {
+            snapToOffsets: this._getSnapOffsets()
+        };
+
+        // Flatlist specifics
+        const specificProps = !this._needsScrollView() ? {
+            CellRendererComponent: CellRendererComponent || this._getCellRendererComponent,
+            getItemLayout: getItemLayout || this._getItemLayout,
+            initialScrollIndex: this._getFirstItem(firstItem),
+            keyExtractor: keyExtractor || this._getKeyExtractor,
+            numColumns: 1,
+            renderItem: this._renderItem
+        } : {};
+
+        return {
+            ...specificProps,
+            ...snapProps,
+            ref: (c) => { this._carouselRef = c; },
+            contentContainerStyle: contentContainerStyle,
+            data: this._getCustomData(),
+            horizontal: !vertical,
+            scrollEventThrottle: 1,
+            style: containerStyle,
+            onLayout: this._onLayout,
+            onMomentumScrollEnd: this._onMomentumScrollEnd,
+            onScroll: this._onScrollHandler,
+            onTouchStart: this._onTouchStart,
+            onTouchEnd: this._onTouchEnd
+        };
+    }
+
+    render () {
+        const { data, renderItem, useScrollView } = this.props;
+
+        if (!data || !renderItem) {
+            return null;
+        }
+
+        const props = {
+            ...this._getComponentOverridableProps(),
+            ...this.props,
+            ...this._getComponentStaticProps()
+        };
+
+        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;
+
+        return this._needsScrollView() ? (
+            <ScrollViewComponent {...props}>
+                {
+                    this._getCustomData().map((item, index) => {
+                        return this._renderItem({ item, index });
+                    })
+                }
+            </ScrollViewComponent>
+        ) : (
+            <AnimatedFlatList {...props} />
+        );
+    }
+}
diff --git a/node_modules/react-native-snap-carousel/src/carousel/Carousel.tsx b/node_modules/react-native-snap-carousel/src/carousel/Carousel.tsx
deleted file mode 100644
index e9daf5b..0000000
--- a/node_modules/react-native-snap-carousel/src/carousel/Carousel.tsx
+++ /dev/null
@@ -1,1342 +0,0 @@
-import React, { PropsWithChildren } from 'react';
-import {
-    Animated,
-    FlatList,
-    I18nManager,
-    Platform,
-    ScrollView,
-    View,
-    StyleProp,
-    NativeSyntheticEvent,
-    NativeScrollEvent,
-    LayoutChangeEvent,
-    GestureResponderEvent,
-    ViewStyle
-} from 'react-native';
-import shallowCompare from 'react-addons-shallow-compare';
-import {
-    defaultScrollInterpolator,
-    stackScrollInterpolator,
-    tinderScrollInterpolator,
-    defaultAnimatedStyles,
-    shiftAnimatedStyles,
-    stackAnimatedStyles,
-    tinderAnimatedStyles
-} from '../utils/animations';
-import type { CarouselProps, CarouselState } from './types';
-
-// Metro doesn't support dynamic imports - i.e. require() done in the component itself
-// But at the same time the following import will fail on Snack...
-// TODO: find a way to get React Native's version without having to assume the file path
-// import RN_PACKAGE from '../../../react-native/package.json';
-
-const IS_ANDROID = Platform.OS === 'android';
-
-// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView
-// See https://github.com/facebook/react-native/issues/11960
-// NOTE: the following variable is not declared in the constructor
-// otherwise it is undefined at init, which messes with custom indexes
-const IS_RTL = I18nManager.isRTL;
-
-export class Carousel<TData> extends React.Component<
-  CarouselProps<TData>,
-  CarouselState
-> {
-  static defaultProps = {
-      activeSlideAlignment: 'center',
-      activeSlideOffset: 20,
-      apparitionDelay: 0,
-      autoplay: false,
-      autoplayDelay: 1000,
-      autoplayInterval: 3000,
-      callbackOffsetMargin: 5,
-      containerCustomStyle: {},
-      contentContainerCustomStyle: {},
-      enableSnap: true,
-      firstItem: 0,
-      hasParallaxImages: false,
-      inactiveSlideOpacity: 0.7,
-      inactiveSlideScale: 0.9,
-      inactiveSlideShift: 0,
-      layout: 'default',
-      loop: false,
-      loopClonesPerSide: 3,
-      scrollEnabled: true,
-      slideStyle: {},
-      shouldOptimizeUpdates: true,
-      useExperimentalSnap: false,
-      useScrollView: !Animated.FlatList
-  };
-
-  _activeItem: number;
-  _onScrollActiveItem: number;
-  _previousFirstItem: number;
-  _previousItemsLength: number;
-  _mounted: boolean;
-  _positions: { start: number; end: number }[];
-  _currentScrollOffset: number;
-  _scrollEnabled: boolean;
-
-  _initTimeout?: ReturnType<typeof setTimeout>;
-  _apparitionTimeout?: ReturnType<typeof setTimeout>;
-  _hackSlideAnimationTimeout?: ReturnType<typeof setTimeout>;
-  _enableAutoplayTimeout?: ReturnType<typeof setTimeout>;
-  _autoplayTimeout?: ReturnType<typeof setTimeout>;
-  _snapNoMomentumTimeout?: ReturnType<typeof setTimeout>;
-  _androidRepositioningTimeout?: ReturnType<typeof setTimeout>;
-  _autoplayInterval?: ReturnType<typeof setInterval>;
-
-  _scrollPos?: Animated.Value;
-
-  _onScrollHandler?: ReturnType<typeof Animated.event>;
-
-  _carouselRef: ScrollView | FlatList<TData> | null = null;
-
-  _autoplaying?: boolean;
-  _autoplay?: boolean;
-
-  _onLayoutInitDone?: boolean;
-
-  constructor (props: CarouselProps<TData>) {
-      super(props);
-
-      this.state = {
-          hideCarousel: !!props.apparitionDelay,
-          interpolators: []
-      };
-
-      // this._RNVersionCode = this._getRNVersionCode();
-
-      // The following values are not stored in the state because 'setState()' is asynchronous
-      // and this results in an absolutely crappy behavior on Android while swiping (see #156)
-      const initialActiveItem = this._getFirstItem(props.firstItem);
-      this._activeItem = initialActiveItem;
-      this._onScrollActiveItem = initialActiveItem;
-      this._previousFirstItem = initialActiveItem;
-      this._previousItemsLength = initialActiveItem;
-
-      this._mounted = false;
-      this._positions = [];
-      this._currentScrollOffset = 0; // Store ScrollView's scroll position
-      this._scrollEnabled = props.scrollEnabled !== false;
-
-      this._getCellRendererComponent = this._getCellRendererComponent.bind(this);
-      this._getItemLayout = this._getItemLayout.bind(this);
-      this._getKeyExtractor = this._getKeyExtractor.bind(this);
-      this._onLayout = this._onLayout.bind(this);
-      this._onScroll = this._onScroll.bind(this);
-      this._onMomentumScrollEnd = this._onMomentumScrollEnd.bind(this);
-      this._onTouchStart = this._onTouchStart.bind(this);
-      this._onTouchEnd = this._onTouchEnd.bind(this);
-      this._renderItem = this._renderItem.bind(this);
-
-      // WARNING: call this AFTER binding _onScroll
-      this._setScrollHandler(props);
-
-      // Display warnings
-      this._displayWarnings(props);
-  }
-
-  componentDidMount () {
-      const { apparitionDelay, autoplay, firstItem } = this.props;
-
-      this._mounted = true;
-      this._initPositionsAndInterpolators();
-
-      // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...
-      this._initTimeout = setTimeout(() => {
-          if (!this._mounted) {
-              return;
-          }
-
-          const apparitionCallback = () => {
-              if (apparitionDelay) {
-                  this.setState({ hideCarousel: false });
-              }
-              if (autoplay) {
-                  this.startAutoplay();
-              }
-          };
-
-          // FlatList will use its own built-in prop `initialScrollIndex`
-          if (this._needsScrollView()) {
-              const _firstItem = this._getFirstItem(firstItem);
-              this._snapToItem(_firstItem, false, false, true);
-              // this._hackActiveSlideAnimation(_firstItem);
-          }
-
-          if (apparitionDelay) {
-              this._apparitionTimeout = setTimeout(() => {
-                  apparitionCallback();
-              }, apparitionDelay);
-          } else {
-              apparitionCallback();
-          }
-      }, 1);
-  }
-
-  shouldComponentUpdate (
-      nextProps: CarouselProps<TData>,
-      nextState: CarouselState
-  ): boolean {
-      if (this.props.shouldOptimizeUpdates === false) {
-          return true;
-      } else {
-          return shallowCompare(this, nextProps, nextState);
-      }
-  }
-
-  componentDidUpdate (prevProps: CarouselProps<TData>) {
-      const { interpolators } = this.state;
-      const {
-          firstItem,
-          scrollEnabled
-      } = this.props;
-      const itemsLength = this._getCustomDataLength(this.props);
-
-      if (!itemsLength) {
-          return;
-      }
-
-      const nextFirstItem = this._getFirstItem(firstItem, this.props);
-      let nextActiveItem =
-      typeof this._activeItem !== 'undefined' ?
-          this._activeItem :
-          nextFirstItem;
-
-      const hasNewSize = this.props.vertical !== prevProps.vertical ||
-       (
-           this.props.vertical && prevProps.vertical && (
-               prevProps.itemHeight !== this.props.itemHeight || prevProps.sliderHeight !== this.props.sliderHeight
-           )
-       ) || (
-          !this.props.vertical && !prevProps.vertical && (
-              prevProps.itemWidth !== this.props.itemWidth || prevProps.sliderWidth !== this.props.sliderWidth
-          )
-      );
-
-      // Prevent issues with dynamically removed items
-      if (nextActiveItem > itemsLength - 1) {
-          nextActiveItem = itemsLength - 1;
-      }
-
-      // Handle changing scrollEnabled independent of user -> carousel interaction
-      if (scrollEnabled !== prevProps.scrollEnabled) {
-          this._setScrollEnabled(scrollEnabled);
-      }
-
-      if (
-          interpolators.length !== itemsLength ||
-          hasNewSize
-      ) {
-          this._activeItem = nextActiveItem;
-          this._previousItemsLength = itemsLength;
-
-          this._initPositionsAndInterpolators(this.props);
-
-          // Handle scroll issue when dynamically removing items (see #133)
-          // This also fixes first item's active state on Android
-          // Because 'initialScrollIndex' apparently doesn't trigger scroll
-          if (this._previousItemsLength > itemsLength) {
-              this._hackActiveSlideAnimation(nextActiveItem);
-          }
-
-          if (hasNewSize) {
-              this._snapToItem(nextActiveItem, false, false, true);
-          }
-      } else if (
-          nextFirstItem !== this._previousFirstItem &&
-      nextFirstItem !== this._activeItem
-      ) {
-          this._activeItem = nextFirstItem;
-          this._previousFirstItem = nextFirstItem;
-          this._snapToItem(nextFirstItem, false, true, true);
-      }
-
-      if (this.props.onScroll !== prevProps.onScroll) {
-          this._setScrollHandler(this.props);
-      }
-  }
-
-  componentWillUnmount () {
-      this._mounted = false;
-      this.stopAutoplay();
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._initTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._apparitionTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._hackSlideAnimationTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._enableAutoplayTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._autoplayTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._snapNoMomentumTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._androidRepositioningTimeout);
-  }
-
-  get realIndex () {
-      return this._activeItem;
-  }
-
-  get currentIndex () {
-      return this._getDataIndex(this._activeItem);
-  }
-
-  get currentScrollPosition () {
-      return this._currentScrollOffset;
-  }
-
-  _setScrollHandler (props: CarouselProps<TData>) {
-      // Native driver for scroll events
-      const scrollEventConfig = {
-          listener: this._onScroll,
-          useNativeDriver: true
-      };
-      this._scrollPos = new Animated.Value(0);
-      const argMapping = props.vertical ?
-          [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }] :
-          [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];
-
-      // @ts-expect-error Let's ignore for now that trick
-      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {
-      // Because of a react-native issue https://github.com/facebook/react-native/issues/13294
-          argMapping.pop();
-          // @ts-expect-error Let's ignore for now that trick
-          const [argMap] = props.onScroll._argMapping;
-          if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {
-              // Shares the same animated value passed in props
-              this._scrollPos =
-          argMap.nativeEvent.contentOffset.x ||
-          argMap.nativeEvent.contentOffset.y ||
-          this._scrollPos;
-          }
-          // @ts-expect-error Let's ignore for now that trick
-          argMapping.push(...props.onScroll._argMapping);
-      }
-      this._onScrollHandler = Animated.event<NativeScrollEvent>(
-          argMapping,
-          scrollEventConfig
-      );
-  }
-
-  // This will return a future-proof version code number compatible with semantic versioning
-  // Examples: 0.59.3 -> 5903 / 0.61.4 -> 6104 / 0.62.12 -> 6212 / 1.0.2 -> 10002
-  // _getRNVersionCode () {
-  //     const version = RN_PACKAGE && RN_PACKAGE.version;
-  //     if (!version) {
-  //         return null;
-  //     }
-  //     const versionSplit = version.split('.');
-  //     if (!versionSplit || !versionSplit.length) {
-  //         return null;
-  //     }
-  //     return versionSplit[0] * 10000 +
-  //         (typeof versionSplit[1] !== 'undefined' ? versionSplit[1] * 100 : 0) +
-  //         (typeof versionSplit[2] !== 'undefined' ? versionSplit[2] * 1 : 0);
-  // }
-
-  _displayWarnings (props: CarouselProps<TData> = this.props) {
-      const pluginName = 'react-native-snap-carousel';
-      const removedProps = [
-          'activeAnimationType',
-          'activeAnimationOptions',
-          'enableMomentum',
-          'lockScrollTimeoutDuration',
-          'lockScrollWhileSnapping',
-          'onBeforeSnapToItem',
-          'swipeThreshold'
-      ] as const;
-
-      // if (this._RNVersionCode && this._RNVersionCode < 5800) {
-      //     console.error(
-      //         `${pluginName}: Version 4+ of the plugin is based on React Native props that were introduced in version 0.58. ` +
-      //         'Please downgrade to version 3.x or update your version of React Native.'
-      //     );
-      // }
-      if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {
-          console.error(
-              `${pluginName}: You need to specify both 'sliderWidth' and 'itemWidth' for horizontal carousels`
-          );
-      }
-      if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {
-          console.error(
-              `${pluginName}: You need to specify both 'sliderHeight' and 'itemHeight' for vertical carousels`
-          );
-      }
-
-      removedProps.forEach((removedProp) => {
-          if (removedProp in props) {
-              console.warn(
-                  `${pluginName}: Prop ${removedProp} has been removed in version 4 of the plugin`
-              );
-          }
-      });
-  }
-
-  _needsScrollView () {
-      const { useScrollView } = this.props;
-      // Android's cell renderer is buggy and has a stange overflow
-      // TODO: a workaround might be to pass the custom animated styles directly to it
-      return IS_ANDROID ?
-          useScrollView ||
-          !Animated.FlatList ||
-          this._shouldUseStackLayout() ||
-          this._shouldUseTinderLayout() :
-          useScrollView || !Animated.FlatList;
-  }
-
-  _needsRTLAdaptations () {
-      const { vertical } = this.props;
-      return IS_RTL && IS_ANDROID && !vertical;
-  }
-
-  _enableLoop () {
-      const { data, enableSnap, loop } = this.props;
-      return enableSnap && loop && data && data.length && data.length > 1;
-  }
-
-  _shouldAnimateSlides (props: CarouselProps<TData> = this.props) {
-      const {
-          inactiveSlideOpacity,
-          inactiveSlideScale,
-          scrollInterpolator,
-          slideInterpolatedStyle
-      } = props;
-      return (
-          inactiveSlideOpacity < 1 ||
-      inactiveSlideScale < 1 ||
-      !!scrollInterpolator ||
-      !!slideInterpolatedStyle ||
-      this._shouldUseShiftLayout() ||
-      this._shouldUseStackLayout() ||
-      this._shouldUseTinderLayout()
-      );
-  }
-
-  _shouldUseShiftLayout () {
-      const { inactiveSlideShift, layout } = this.props;
-      return layout === 'default' && inactiveSlideShift !== 0;
-  }
-
-  _shouldUseStackLayout () {
-      return this.props.layout === 'stack';
-  }
-
-  _shouldUseTinderLayout () {
-      return this.props.layout === 'tinder';
-  }
-
-  _shouldRepositionScroll (index: number) {
-      const { data, enableSnap, loopClonesPerSide } = this.props;
-      const dataLength = data && data.length;
-      if (
-          !enableSnap ||
-      !dataLength ||
-      !this._enableLoop() ||
-      (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)
-      ) {
-          return false;
-      }
-      return true;
-  }
-
-  _roundNumber (num: number, decimals = 1) {
-      // https://stackoverflow.com/a/41716722/
-      const rounder = Math.pow(10, decimals);
-      return Math.round((num + Number.EPSILON) * rounder) / rounder;
-  }
-
-  _isMultiple (x: number, y: number) {
-      // This prevents Javascript precision issues: https://stackoverflow.com/a/58440614/
-      // Required because Android viewport size can return pretty complicated decimals numbers
-      return Math.round(Math.round(x / y) / (1 / y)) === Math.round(x);
-  }
-
-  _getCustomData (props: CarouselProps<TData> = this.props) {
-      const { data, loopClonesPerSide } = props;
-      const dataLength = data && data.length;
-
-      if (!dataLength) {
-          return [];
-      }
-
-      if (!this._enableLoop()) {
-          return data;
-      }
-
-      let previousItems = [];
-      let nextItems = [];
-
-      if (loopClonesPerSide > dataLength) {
-          const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-          const remainder = loopClonesPerSide % dataLength;
-
-          for (let i = 0; i < dataMultiplier; i++) {
-              previousItems.push(...data);
-              nextItems.push(...data);
-          }
-
-          previousItems.unshift(...data.slice(-remainder));
-          nextItems.push(...data.slice(0, remainder));
-      } else {
-          previousItems = data.slice(-loopClonesPerSide);
-          nextItems = data.slice(0, loopClonesPerSide);
-      }
-
-      return previousItems.concat(data, nextItems);
-  }
-
-  _getCustomDataLength (props: CarouselProps<TData> = this.props) {
-      const { data, loopClonesPerSide } = props;
-      const dataLength = data && data.length;
-
-      if (!dataLength) {
-          return 0;
-      }
-
-      return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;
-  }
-
-  _getCustomIndex (index: number, props: CarouselProps<TData> = this.props) {
-      const itemsLength = this._getCustomDataLength(props);
-
-      if (!itemsLength || typeof index === 'undefined') {
-          return 0;
-      }
-
-      return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;
-  }
-
-  _getDataIndex (index: number) {
-      const { data, loopClonesPerSide } = this.props;
-      const dataLength = data && data.length;
-
-      if (!this._enableLoop() || !dataLength) {
-          return index;
-      }
-
-      if (index >= dataLength + loopClonesPerSide) {
-          return loopClonesPerSide > dataLength ?
-              (index - loopClonesPerSide) % dataLength :
-              index - dataLength - loopClonesPerSide;
-      } else if (index < loopClonesPerSide) {
-      // TODO: is there a simpler way of determining the interpolated index?
-          if (loopClonesPerSide > dataLength) {
-              const baseDataIndexes = [];
-              const dataIndexes = [];
-              const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);
-              const remainder = loopClonesPerSide % dataLength;
-
-              for (let i = 0; i < dataLength; i++) {
-                  baseDataIndexes.push(i);
-              }
-
-              for (let j = 0; j < dataMultiplier; j++) {
-                  dataIndexes.push(...baseDataIndexes);
-              }
-
-              dataIndexes.unshift(...baseDataIndexes.slice(-remainder));
-              return dataIndexes[index];
-          } else {
-              return index + dataLength - loopClonesPerSide;
-          }
-      } else {
-          return index - loopClonesPerSide;
-      }
-  }
-
-  // Used with `snapToItem()` and 'PaginationDot'
-  _getPositionIndex (index: number) {
-      const { loop, loopClonesPerSide } = this.props;
-      return loop ? index + loopClonesPerSide : index;
-  }
-
-  _getSnapOffsets (props: CarouselProps<TData> = this.props) {
-      const offset = this._getItemMainDimension();
-      return [...Array(this._getCustomDataLength(props))].map((_, i) => {
-          return i * offset;
-      });
-  }
-
-  _getFirstItem (index: number, props: CarouselProps<TData> = this.props) {
-      const { loopClonesPerSide } = props;
-      const itemsLength = this._getCustomDataLength(props);
-
-      if (!itemsLength || index > itemsLength - 1 || index < 0) {
-          return 0;
-      }
-
-      return this._enableLoop() ? index + loopClonesPerSide : index;
-  }
-
-  _getWrappedRef () {
-      // Starting with RN 0.62, we should no longer call `getNode()` on the ref of an Animated component
-      if (
-          this._carouselRef &&
-      ((this._needsScrollView() &&
-        (this._carouselRef as ScrollView).scrollTo) ||
-        (!this._needsScrollView() &&
-          (this._carouselRef as FlatList).scrollToOffset))
-      ) {
-          return this._carouselRef;
-      }
-      // https://github.com/facebook/react-native/issues/10635
-      // https://stackoverflow.com/a/48786374/8412141
-      return (
-          this._carouselRef &&
-      // @ts-expect-error This is for before 0.62
-      this._carouselRef.getNode &&
-      // @ts-expect-error This is for before 0.62
-      this._carouselRef.getNode()
-      );
-  }
-
-  _getScrollEnabled () {
-      return this._scrollEnabled;
-  }
-
-  _setScrollEnabled (scrollEnabled = true) {
-      const wrappedRef = this._getWrappedRef();
-
-      if (!wrappedRef || !wrappedRef.setNativeProps) {
-          return;
-      }
-
-      // 'setNativeProps()' is used instead of 'setState()' because the latter
-      // really takes a toll on Android behavior when momentum is disabled
-      wrappedRef.setNativeProps({ scrollEnabled });
-      this._scrollEnabled = scrollEnabled;
-  }
-
-  _getItemMainDimension () {
-      return this.props.vertical ? this.props.itemHeight : this.props.itemWidth;
-  }
-
-  _getItemScrollOffset (index: number) {
-      return (
-          this._positions && this._positions[index] && this._positions[index].start
-      );
-  }
-
-  _getItemLayout (_: TData[], index: number) {
-      const itemMainDimension = this._getItemMainDimension();
-      return {
-          index,
-          length: itemMainDimension,
-          offset: itemMainDimension * index // + this._getContainerInnerMargin()
-      };
-  }
-
-  // This will allow us to have a proper zIndex even with a FlatList
-  // https://github.com/facebook/react-native/issues/18616#issuecomment-389444165
-  _getCellRendererComponent ({
-      children,
-      index,
-      style,
-      ...props
-  }: PropsWithChildren<{ index: number; style: StyleProp<ViewStyle> }>) {
-      const cellStyle = [
-          style,
-          !IS_ANDROID ? { zIndex: this._getCustomDataLength() - index } : {}
-      ];
-
-      return (
-          <View style={cellStyle} key={index} {...props}>
-              {children}
-          </View>
-      );
-  }
-
-  _getKeyExtractor (_: TData, index: number) {
-      return this._needsScrollView() ?
-          `scrollview-item-${index}` :
-          `flatlist-item-${index}`;
-  }
-
-  _getScrollOffset (event: NativeSyntheticEvent<NativeScrollEvent>) {
-      const { vertical } = this.props;
-      return (
-          (event &&
-        event.nativeEvent &&
-        event.nativeEvent.contentOffset &&
-        event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) ||
-      0
-      );
-  }
-
-  _getContainerInnerMargin (opposite = false) {
-      const { activeSlideAlignment } = this.props;
-
-      if (
-          (activeSlideAlignment === 'start' && !opposite) ||
-      (activeSlideAlignment === 'end' && opposite)
-      ) {
-          return 0;
-      } else if (
-          (activeSlideAlignment === 'end' && !opposite) ||
-      (activeSlideAlignment === 'start' && opposite)
-      ) {
-          return this.props.vertical ?
-              this.props.sliderHeight - this.props.itemHeight :
-              this.props.sliderWidth - this.props.itemWidth;
-      } else {
-          return this.props.vertical ?
-              (this.props.sliderHeight - this.props.itemHeight) / 2 :
-              (this.props.sliderWidth - this.props.itemWidth) / 2;
-      }
-  }
-
-  _getActiveSlideOffset () {
-      const { activeSlideOffset } = this.props;
-      const itemMainDimension = this._getItemMainDimension();
-      const minOffset = 10;
-      // Make sure activeSlideOffset never prevents the active area from being at least 10 px wide
-      return itemMainDimension / 2 - activeSlideOffset >= minOffset ?
-          activeSlideOffset :
-          minOffset;
-  }
-
-  _getActiveItem (offset: number) {
-      const itemMainDimension = this._getItemMainDimension();
-      const center = offset + itemMainDimension / 2;
-      const activeSlideOffset = this._getActiveSlideOffset();
-      const lastIndex = this._positions.length - 1;
-      let itemIndex;
-
-      if (offset <= 0) {
-          return 0;
-      }
-
-      if (
-          this._positions[lastIndex] &&
-      offset >= this._positions[lastIndex].start
-      ) {
-          return lastIndex;
-      }
-
-      for (let i = 0; i < this._positions.length; i++) {
-          const { start, end } = this._positions[i];
-          if (
-              center + activeSlideOffset >= start &&
-        center - activeSlideOffset <= end
-          ) {
-              itemIndex = i;
-              break;
-          }
-      }
-
-      return itemIndex || 0;
-  }
-
-  _getSlideInterpolatedStyle (index: number, animatedValue: Animated.AnimatedInterpolation) {
-      const { layoutCardOffset, slideInterpolatedStyle } = this.props;
-
-      if (slideInterpolatedStyle) {
-          return slideInterpolatedStyle(index, animatedValue, this.props);
-      } else if (this._shouldUseTinderLayout()) {
-          return tinderAnimatedStyles(
-              index,
-              animatedValue,
-              this.props,
-              layoutCardOffset
-          );
-      } else if (this._shouldUseStackLayout()) {
-          return stackAnimatedStyles(
-              index,
-              animatedValue,
-              this.props,
-              layoutCardOffset
-          );
-      } else if (this._shouldUseShiftLayout()) {
-          return shiftAnimatedStyles(index, animatedValue, this.props);
-      } else {
-          return defaultAnimatedStyles(index, animatedValue, this.props);
-      }
-  }
-
-  _initPositionsAndInterpolators (props: CarouselProps<TData> = this.props) {
-      const { data, scrollInterpolator } = props;
-      const itemMainDimension = this._getItemMainDimension();
-
-      if (!data || !data.length) {
-          return;
-      }
-
-      const interpolators: Animated.AnimatedInterpolation[] = [];
-      this._positions = [];
-
-      this._getCustomData(props).forEach((_itemData, index) => {
-          const _index = this._getCustomIndex(index, props);
-          let animatedValue: Animated.AnimatedInterpolation;
-
-          this._positions[index] = {
-              start: index * itemMainDimension,
-              end: index * itemMainDimension + itemMainDimension
-          };
-
-          if (!this._shouldAnimateSlides(props) || !this._scrollPos) {
-              animatedValue = new Animated.Value(1);
-          } else {
-              let interpolator;
-
-              if (scrollInterpolator) {
-                  interpolator = scrollInterpolator(_index, props);
-              } else if (this._shouldUseStackLayout()) {
-                  interpolator = stackScrollInterpolator(_index, props);
-              } else if (this._shouldUseTinderLayout()) {
-                  interpolator = tinderScrollInterpolator(_index, props);
-              }
-
-              if (
-                  !interpolator ||
-          !interpolator.inputRange ||
-          !interpolator.outputRange
-              ) {
-                  interpolator = defaultScrollInterpolator(_index, props);
-              }
-
-              animatedValue = this._scrollPos.interpolate({
-                  ...interpolator,
-                  extrapolate: 'clamp'
-              });
-          }
-
-          interpolators.push(animatedValue);
-      });
-
-      this.setState({ interpolators });
-  }
-
-  _hackActiveSlideAnimation (index: number, scrollValue = 1) {
-      const offset = this._getItemScrollOffset(index);
-
-      if (!this._mounted || !this._carouselRef || typeof offset === 'undefined') {
-          return;
-      }
-
-      const multiplier = this._currentScrollOffset === 0 ? 1 : -1;
-      const scrollDelta = scrollValue * multiplier;
-
-      this._scrollTo({ offset: offset + scrollDelta, animated: false });
-
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._hackSlideAnimationTimeout);
-      this._hackSlideAnimationTimeout = setTimeout(() => {
-          this._scrollTo({ offset, animated: false });
-      }, 1); // works randomly when set to '0'
-  }
-
-  _repositionScroll (index: number, animated = false) {
-      const { data, loopClonesPerSide } = this.props;
-      const dataLength = data && data.length;
-
-      if (typeof index === 'undefined' || !this._shouldRepositionScroll(index)) {
-          return;
-      }
-
-      let repositionTo = index;
-
-      if (index >= dataLength + loopClonesPerSide) {
-          repositionTo = index - dataLength;
-      } else if (index < loopClonesPerSide) {
-          repositionTo = index + dataLength;
-      }
-
-      this._snapToItem(repositionTo, animated, false);
-  }
-
-  _scrollTo ({
-      offset,
-      index,
-      animated = true
-  }: {
-    offset: number;
-    index?: number;
-    animated: boolean;
-  }) {
-      const { vertical } = this.props;
-      const wrappedRef = this._getWrappedRef();
-      if (
-          !this._mounted ||
-      !wrappedRef ||
-      (typeof offset === 'undefined' && typeof index === 'undefined')
-      ) {
-          return;
-      }
-
-      let scrollToOffset;
-      if (typeof index !== 'undefined') {
-          scrollToOffset = this._getItemScrollOffset(index);
-      } else {
-          scrollToOffset = offset;
-      }
-
-      if (typeof scrollToOffset === 'undefined') {
-          return;
-      }
-
-      const options = this._needsScrollView() ?
-          {
-              x: vertical ? 0 : offset,
-              y: vertical ? offset : 0,
-              animated
-          } :
-          {
-              offset,
-              animated
-          };
-
-      if (this._needsScrollView()) {
-          wrappedRef.scrollTo(options);
-      } else {
-          wrappedRef.scrollToOffset(options);
-      }
-  }
-
-  _onTouchStart (event: GestureResponderEvent) {
-      const { onTouchStart } = this.props;
-
-      // `onTouchStart` is fired even when `scrollEnabled` is set to `false`
-      if (this._getScrollEnabled() !== false && this._autoplaying) {
-          this.pauseAutoPlay();
-      }
-
-      onTouchStart && onTouchStart(event);
-  }
-
-  _onTouchEnd (event: GestureResponderEvent) {
-      const { onTouchEnd } = this.props;
-
-      if (
-          this._getScrollEnabled() !== false &&
-      this._autoplay &&
-      !this._autoplaying
-      ) {
-      // This event is buggy on Android, so a fallback is provided in _onMomentumScrollEnd()
-          this.startAutoplay();
-      }
-
-      onTouchEnd && onTouchEnd(event);
-  }
-
-  _onScroll (event: NativeSyntheticEvent<NativeScrollEvent>) {
-      const { onScroll, onScrollIndexChanged } = this.props;
-      const scrollOffset = event ?
-          this._getScrollOffset(event) :
-          this._currentScrollOffset;
-      const nextActiveItem = this._getActiveItem(scrollOffset);
-
-      this._currentScrollOffset = scrollOffset;
-
-      if (nextActiveItem !== this._onScrollActiveItem) {
-          this._onScrollActiveItem = nextActiveItem;
-          onScrollIndexChanged &&
-        onScrollIndexChanged(this._getDataIndex(nextActiveItem));
-      }
-
-      if (typeof onScroll === 'function' && event) {
-          onScroll(event);
-      }
-  }
-
-  _onMomentumScrollEnd (event: NativeSyntheticEvent<NativeScrollEvent>) {
-      const { autoplayDelay, onMomentumScrollEnd, onSnapToItem } = this.props;
-      const scrollOffset = event ?
-          this._getScrollOffset(event) :
-          this._currentScrollOffset;
-      const nextActiveItem = this._getActiveItem(scrollOffset);
-      const hasSnapped = this._isMultiple(
-          scrollOffset,
-          this.props.vertical ? this.props.itemHeight : this.props.itemWidth
-      );
-
-      // WARNING: everything in this condition will probably need to be called on _snapToItem as well because:
-      // 1. `onMomentumScrollEnd` won't be called if the scroll isn't animated
-      // 2. `onMomentumScrollEnd` won't be called at all on Android when scrolling programmatically
-      if (nextActiveItem !== this._activeItem) {
-          this._activeItem = nextActiveItem;
-          onSnapToItem && onSnapToItem(this._getDataIndex(nextActiveItem));
-
-          if (hasSnapped) {
-              this._repositionScroll(nextActiveItem);
-          }
-      }
-
-      onMomentumScrollEnd && onMomentumScrollEnd(event);
-
-      // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed
-      // https://github.com/facebook/react-native/issues/9439
-      if (IS_ANDROID && this._autoplay && !this._autoplaying) {
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-          clearTimeout(this._enableAutoplayTimeout);
-          this._enableAutoplayTimeout = setTimeout(() => {
-              this.startAutoplay();
-          }, autoplayDelay);
-      }
-  }
-
-  _onLayout (event: LayoutChangeEvent) {
-      const { onLayout } = this.props;
-
-      // Prevent unneeded actions during the first 'onLayout' (triggered on init)
-      if (this._onLayoutInitDone) {
-          this._initPositionsAndInterpolators();
-          this._snapToItem(this._activeItem, false, false, true);
-      } else {
-          this._onLayoutInitDone = true;
-      }
-
-      onLayout && onLayout(event);
-  }
-
-  _snapToItem (
-      index: number,
-      animated = true,
-      fireCallback = true,
-      forceScrollTo = false
-  ) {
-      const { onSnapToItem } = this.props;
-      const itemsLength = this._getCustomDataLength();
-      const wrappedRef = this._getWrappedRef();
-
-      if (!itemsLength || !wrappedRef) {
-          return;
-      }
-
-      if (!index || index < 0) {
-          index = 0;
-      } else if (itemsLength > 0 && index >= itemsLength) {
-          index = itemsLength - 1;
-      }
-
-      if (index === this._activeItem && !forceScrollTo) {
-          return;
-      }
-
-      const offset = this._getItemScrollOffset(index);
-
-      if (offset === undefined) {
-          return;
-      }
-
-      this._scrollTo({ offset, animated });
-
-      // On both platforms, `onMomentumScrollEnd` won't be triggered if the scroll isn't animated
-      // so we need to trigger the callback manually
-      // On Android `onMomentumScrollEnd` won't be triggered when scrolling programmatically
-      // Therefore everything critical needs to be manually called here as well, even though the timing might be off
-      const requiresManualTrigger = !animated || IS_ANDROID;
-      if (requiresManualTrigger) {
-          this._activeItem = index;
-
-          if (fireCallback) {
-              onSnapToItem && onSnapToItem(this._getDataIndex(index));
-          }
-
-          // Repositioning on Android
-          if (IS_ANDROID && this._shouldRepositionScroll(index)) {
-              if (animated) {
-                  this._androidRepositioningTimeout = setTimeout(() => {
-                      // Without scroll animation, the behavior is completely buggy...
-                      this._repositionScroll(index, true);
-                  }, 400); // Approximate scroll duration on Android
-              } else {
-                  this._repositionScroll(index);
-              }
-          }
-      }
-  }
-
-  startAutoplay () {
-      const { autoplayInterval, autoplayDelay } = this.props;
-      this._autoplay = true;
-
-      if (this._autoplaying) {
-          return;
-      }
-
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._autoplayTimeout);
-      this._autoplayTimeout = setTimeout(() => {
-          this._autoplaying = true;
-          this._autoplayInterval = setInterval(() => {
-              if (this._autoplaying) {
-                  this.snapToNext();
-              }
-          }, autoplayInterval);
-      }, autoplayDelay);
-  }
-
-  pauseAutoPlay () {
-      this._autoplaying = false;
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._autoplayTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearTimeout(this._enableAutoplayTimeout);
-      // @ts-expect-error setTimeout / clearTiemout is buggy :/
-      clearInterval(this._autoplayInterval);
-  }
-
-  stopAutoplay () {
-      this._autoplay = false;
-      this.pauseAutoPlay();
-  }
-
-  snapToItem (index: number, animated = true, fireCallback = true) {
-      if (!index || index < 0) {
-          index = 0;
-      }
-
-      const positionIndex = this._getPositionIndex(index);
-
-      if (positionIndex === this._activeItem) {
-          return;
-      }
-
-      this._snapToItem(positionIndex, animated, fireCallback);
-  }
-
-  snapToNext (animated = true, fireCallback = true) {
-      const itemsLength = this._getCustomDataLength();
-
-      let newIndex = this._activeItem + 1;
-      if (newIndex > itemsLength - 1) {
-          newIndex = 0;
-      }
-      this._snapToItem(newIndex, animated, fireCallback);
-  }
-
-  snapToPrev (animated = true, fireCallback = true) {
-      const itemsLength = this._getCustomDataLength();
-
-      let newIndex = this._activeItem - 1;
-      if (newIndex < 0) {
-          newIndex = itemsLength - 1;
-      }
-      this._snapToItem(newIndex, animated, fireCallback);
-  }
-
-  // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668
-  triggerRenderingHack (offset = 1) {
-      this._hackActiveSlideAnimation(this._activeItem, offset);
-  }
-
-  _renderItem ({ item, index }: { item: TData; index: number }) {
-      const { interpolators } = this.state;
-      const {
-          keyExtractor,
-          slideStyle
-      } = this.props;
-      const animatedValue = interpolators && interpolators[index];
-
-      if (typeof animatedValue === 'undefined') {
-          return null;
-      }
-
-      const animate = this._shouldAnimateSlides();
-      const Component = animate ? Animated.View : View;
-      const animatedStyle = animate ?
-          this._getSlideInterpolatedStyle(index, animatedValue) :
-          {};
-      const dataIndex = this._getDataIndex(index);
-
-      const mainDimension = this.props.vertical ?
-          { height: this.props.itemHeight } :
-          { width: this.props.itemWidth };
-      const specificProps = this._needsScrollView() ?
-          {
-              key: keyExtractor ?
-                  keyExtractor(item, index) :
-                  this._getKeyExtractor(item, index)
-          } :
-          {};
-
-      return (
-          <Component
-            style={[mainDimension, slideStyle, animatedStyle]}
-            pointerEvents='box-none'
-            {...specificProps}
-          >
-              {this.props.vertical ? this.props.renderItem({ item, index, dataIndex }, {
-                  scrollPosition: this._scrollPos,
-                  carouselRef: this._carouselRef,
-                  vertical: this.props.vertical,
-                  sliderHeight: this.props.sliderHeight,
-                  itemHeight: this.props.itemHeight
-              }) : this.props.renderItem({ item, index, dataIndex }, {
-                  scrollPosition: this._scrollPos,
-                  carouselRef: this._carouselRef,
-                  vertical: !!this.props.vertical,
-                  sliderWidth: this.props.sliderWidth,
-                  itemWidth: this.props.itemWidth
-              })}
-          </Component>
-      );
-  }
-
-  _getComponentOverridableProps () {
-      const { hideCarousel } = this.state;
-      const { loopClonesPerSide } = this.props;
-      const visibleItems =
-      Math.ceil(
-          this.props.vertical ?
-              this.props.sliderHeight / this.props.itemHeight :
-              this.props.sliderWidth / this.props.itemWidth
-      ) + 1;
-      const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;
-      const initialNumToRender = visibleItems + initialNumPerSide * 2;
-      const maxToRenderPerBatch = initialNumToRender + initialNumPerSide * 2;
-      const windowSize = maxToRenderPerBatch;
-
-      const specificProps = !this._needsScrollView() ?
-          {
-              initialNumToRender,
-              maxToRenderPerBatch,
-              windowSize
-          // updateCellsBatchingPeriod
-          } :
-          {};
-
-      return {
-          ...specificProps,
-          automaticallyAdjustContentInsets: false,
-          decelerationRate: 'fast' as const,
-          directionalLockEnabled: true,
-          disableScrollViewPanResponder: false, // If set to `true`, touch events will be triggered too easily
-          inverted: this._needsRTLAdaptations(),
-          overScrollMode: 'never' as const,
-          pinchGestureEnabled: false,
-          pointerEvents: hideCarousel ? 'none' as const : 'auto' as const,
-          // removeClippedSubviews: !this._needsScrollView(),
-          // renderToHardwareTextureAndroid: true,
-          scrollsToTop: false,
-          showsHorizontalScrollIndicator: false,
-          showsVerticalScrollIndicator: false
-      };
-  }
-
-  _getComponentStaticProps () {
-      const { hideCarousel } = this.state;
-      const {
-          activeSlideAlignment,
-          CellRendererComponent,
-          containerCustomStyle,
-          contentContainerCustomStyle,
-          firstItem,
-          getItemLayout,
-          keyExtractor,
-          style,
-          useExperimentalSnap
-      } = this.props;
-
-      const containerStyle = [
-      // { overflow: 'hidden' },
-          containerCustomStyle || style || {},
-          hideCarousel ? { opacity: 0 } : {},
-          this.props.vertical ?
-              { height: this.props.sliderHeight, flexDirection: 'column' as const } : // LTR hack; see https://github.com/facebook/react-native/issues/11960
-          // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423
-              {
-                  width: this.props.sliderWidth,
-                  flexDirection: this._needsRTLAdaptations() ? 'row-reverse' as const : 'row' as const
-              }
-      ];
-
-      const innerMarginStyle = this.props.vertical ?
-          {
-              paddingTop: this._getContainerInnerMargin(),
-              paddingBottom: this._getContainerInnerMargin(true)
-          } :
-          {
-              paddingLeft: this._getContainerInnerMargin(),
-              paddingRight: this._getContainerInnerMargin(true)
-          };
-
-      const contentContainerStyle = [
-          !useExperimentalSnap ? innerMarginStyle : {},
-          contentContainerCustomStyle || {}
-      ];
-
-      // WARNING: `snapToAlignment` won't work as intended because of the following:
-      // https://github.com/facebook/react-native/blob/d0871d0a9a373e1d3ac35da46c85c0d0e793116d/React/Views/ScrollView/RCTScrollView.m#L751-L755
-      // - Snap points will be off
-      // - Slide animations will be off
-      // - Last items won't be set as active (no `onSnapToItem` callback)
-      // Recommended only with large slides and `activeSlideAlignment` set to `start` for the time being
-      const snapProps = useExperimentalSnap ?
-          {
-          // disableIntervalMomentum: true, // Slide ± one item at a time
-              snapToAlignment: activeSlideAlignment,
-              snapToInterval: this._getItemMainDimension()
-          } :
-          {
-              snapToOffsets: this._getSnapOffsets()
-          };
-
-      // Flatlist specifics
-      const specificProps = !this._needsScrollView() ?
-          {
-              CellRendererComponent:
-            CellRendererComponent || this._getCellRendererComponent,
-              getItemLayout: getItemLayout || this._getItemLayout,
-              initialScrollIndex: this._getFirstItem(firstItem),
-              keyExtractor: keyExtractor || this._getKeyExtractor,
-              numColumns: 1,
-              renderItem: this._renderItem
-          } :
-          {};
-
-      return {
-          ...specificProps,
-          ...snapProps,
-          // eslint-disable-next-line @typescript-eslint/no-explicit-any
-          ref: (c: any) => {
-              this._carouselRef = c as FlatList<TData> | ScrollView;
-          },
-          contentContainerStyle: contentContainerStyle,
-          data: this._getCustomData(),
-          horizontal: !this.props.vertical,
-          scrollEventThrottle: 1,
-          style: containerStyle,
-          onLayout: this._onLayout,
-          onMomentumScrollEnd: this._onMomentumScrollEnd,
-          onScroll: this._onScrollHandler,
-          onTouchStart: this._onTouchStart,
-          onTouchEnd: this._onTouchEnd
-      };
-  }
-
-  render () {
-      const { data, renderItem, useScrollView } = this.props;
-
-      if (!data || !renderItem) {
-          return null;
-      }
-
-      const props = {
-          ...this._getComponentOverridableProps(),
-          ...this.props,
-          ...this._getComponentStaticProps()
-      };
-
-      const ScrollViewComponent =
-      typeof useScrollView === 'function' ? useScrollView : Animated.ScrollView;
-
-      return this._needsScrollView() || !Animated.FlatList ? (
-          <ScrollViewComponent {...props}>
-              {this._getCustomData().map((item, index) => {
-                  return this._renderItem({ item, index });
-              })}
-          </ScrollViewComponent>
-      ) : (
-          // @ts-expect-error Seems complicated to make TS 100% happy, while sharing that many things between
-          // flatlist && scrollview implementation. I'll prob try to rewrite parts of the logic to overcome that.
-          <Animated.FlatList {...props} />
-      );
-  }
-}
-
-export default Carousel;
diff --git a/node_modules/react-native-snap-carousel/src/carousel/types.ts b/node_modules/react-native-snap-carousel/src/carousel/types.ts
deleted file mode 100644
index 46c1e5e..0000000
--- a/node_modules/react-native-snap-carousel/src/carousel/types.ts
+++ /dev/null
@@ -1,103 +0,0 @@
-import type {
-    StyleProp,
-    ViewStyle,
-    Animated,
-    NativeScrollEvent,
-    NativeSyntheticEvent,
-    FlatListProps,
-    ScrollView,
-    FlatList
-} from 'react-native';
-import type { ReactNode } from 'react';
-
-type CarouselBaseProps<TData> = {
-  data: TData[];
-  activeSlideAlignment: 'center' | 'end' | 'start';
-  activeSlideOffset: number;
-  apparitionDelay: number;
-  autoplay: boolean;
-  autoplayDelay: number;
-  autoplayInterval: number;
-  callbackOffsetMargin: number;
-  containerCustomStyle: StyleProp<ViewStyle>;
-  contentContainerCustomStyle: StyleProp<ViewStyle>;
-  enableSnap: boolean;
-  firstItem: number;
-  inactiveSlideOpacity: number;
-  inactiveSlideScale: number;
-  inactiveSlideShift: number;
-  layout: 'default' | 'stack' | 'tinder';
-  layoutCardOffset?: number;
-  loop: boolean;
-  loopClonesPerSide: number;
-  scrollEnabled: boolean;
-  scrollInterpolator?: (index: number, props: CarouselBaseProps<TData>) => {
-    inputRange: number[];
-    outputRange: number[];
-  };
-  slideInterpolatedStyle?: (
-    index: number,
-    animatedValue: Animated.AnimatedInterpolation,
-    props: CarouselBaseProps<TData>
-  ) => StyleProp<ViewStyle>;
-  slideStyle?: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;
-  shouldOptimizeUpdates: boolean;
-  useExperimentalSnap: boolean;
-  useScrollView: boolean | React.ComponentType<unknown>;
-  onScroll?: (event: NativeSyntheticEvent<NativeScrollEvent>) => void;
-  onScrollIndexChanged?: (index: number) => void;
-  onSnapToItem?: (index: number) => void;
-};
-
-type InheritedPropsFromFlatlist<TData> = Pick<
-  FlatListProps<TData>,
-  | 'onTouchStart'
-  | 'onTouchEnd'
-  | 'onMomentumScrollEnd'
-  | 'onLayout'
-  | 'keyExtractor'
-  | 'CellRendererComponent'
-  | 'getItemLayout'
-  | 'style'
->;
-
-type VerticalCarouselProps<TData> = {
-  vertical: true;
-  itemHeight: number;
-  sliderHeight: number;
-  renderItem: (
-    baseData: { index: number; dataIndex: number; item: TData },
-    parallaxData: {
-      scrollPosition: Animated.Value | undefined,
-      carouselRef: ScrollView | FlatList<TData> | null,
-      vertical: true,
-      itemHeight: number,
-      sliderHeight: number,
-    }
-  ) => ReactNode;
-};
-
-type HorizontalCarouselProps<TData> = {
-  vertical: false | undefined;
-  itemWidth: number;
-  sliderWidth: number;
-  renderItem: (
-    baseData: { index: number; dataIndex: number; item: TData },
-    parallaxData: {
-      scrollPosition: Animated.Value | undefined,
-      carouselRef: ScrollView | FlatList<TData> | null,
-      vertical: false,
-      itemWidth: number,
-      sliderWidth: number,
-    }
-  ) => ReactNode;
-};
-
-export type CarouselProps<TData> = CarouselBaseProps<TData> &
-  (HorizontalCarouselProps<TData> | VerticalCarouselProps<TData>) &
-  InheritedPropsFromFlatlist<TData>;
-
-export type CarouselState = {
-  hideCarousel: boolean;
-  interpolators: (Animated.Value | Animated.AnimatedInterpolation)[];
-};
diff --git a/node_modules/react-native-snap-carousel/src/index.js b/node_modules/react-native-snap-carousel/src/index.js
new file mode 100644
index 0000000..d937253
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/src/index.js
@@ -0,0 +1,6 @@
+import Carousel from './carousel/Carousel';
+import Pagination from './pagination/Pagination';
+import ParallaxImage from './parallaximage/ParallaxImage';
+import { getInputRangeFromIndexes } from './utils/animations';
+
+export { Carousel as default, Pagination, ParallaxImage, getInputRangeFromIndexes };
diff --git a/node_modules/react-native-snap-carousel/src/index.ts b/node_modules/react-native-snap-carousel/src/index.ts
deleted file mode 100644
index 3e1a854..0000000
--- a/node_modules/react-native-snap-carousel/src/index.ts
+++ /dev/null
@@ -1,13 +0,0 @@
-import Carousel from './carousel/Carousel';
-import Pagination from './pagination/Pagination';
-import ParallaxImage, { ParallaxImageStatus } from './parallaximage/ParallaxImage';
-import { getInputRangeFromIndexes } from './utils/animations';
-
-export {
-    Carousel as default,
-    Carousel,
-    Pagination,
-    ParallaxImage,
-    ParallaxImageStatus,
-    getInputRangeFromIndexes
-};
diff --git a/node_modules/react-native-snap-carousel/src/pagination/Pagination.js b/node_modules/react-native-snap-carousel/src/pagination/Pagination.js
new file mode 100644
index 0000000..30f8171
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/src/pagination/Pagination.js
@@ -0,0 +1,167 @@
+import React, { PureComponent } from 'react';
+import { I18nManager, Platform, View, ViewPropTypes } from 'react-native';
+import PropTypes from 'prop-types';
+import PaginationDot from './PaginationDot';
+import styles from './Pagination.style';
+
+const IS_IOS = Platform.OS === 'ios';
+const IS_RTL = I18nManager.isRTL;
+
+export default class Pagination extends PureComponent {
+
+    static propTypes = {
+        activeDotIndex: PropTypes.number.isRequired,
+        dotsLength: PropTypes.number.isRequired,
+        activeOpacity: PropTypes.number,
+        carouselRef: PropTypes.object,
+        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        dotColor: PropTypes.string,
+        dotContainerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        dotElement: PropTypes.element,
+        dotStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        inactiveDotColor: PropTypes.string,
+        inactiveDotElement: PropTypes.element,
+        inactiveDotOpacity: PropTypes.number,
+        inactiveDotScale: PropTypes.number,
+        inactiveDotStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        renderDots: PropTypes.func,
+        tappableDots: PropTypes.bool,
+        vertical: PropTypes.bool,
+        accessibilityLabel: PropTypes.string,
+        animatedDuration: PropTypes.number,
+        animatedFriction: PropTypes.number,
+        animatedTension: PropTypes.number,
+        delayPressInDot: PropTypes.number
+    };
+
+    static defaultProps = {
+        inactiveDotOpacity: 0.5,
+        inactiveDotScale: 0.5,
+        tappableDots: false,
+        vertical: false,
+        animatedDuration: 250,
+        animatedFriction: 4,
+        animatedTension: 50,
+        delayPressInDot: 0
+    }
+
+    constructor (props) {
+        super(props);
+
+        // Warnings
+        if ((props.dotColor && !props.inactiveDotColor) || (!props.dotColor && props.inactiveDotColor)) {
+            console.warn(
+                'react-native-snap-carousel | Pagination: ' +
+                'You need to specify both `dotColor` and `inactiveDotColor`'
+            );
+        }
+        if ((props.dotElement && !props.inactiveDotElement) || (!props.dotElement && props.inactiveDotElement)) {
+            console.warn(
+                'react-native-snap-carousel | Pagination: ' +
+                'You need to specify both `dotElement` and `inactiveDotElement`'
+            );
+        }
+        if (props.tappableDots && props.carouselRef === undefined) {
+            console.warn(
+                'react-native-snap-carousel | Pagination: ' +
+                'You must specify prop `carouselRef` when setting `tappableDots` to `true`'
+            );
+        }
+    }
+
+    _needsRTLAdaptations () {
+        const { vertical } = this.props;
+        return IS_RTL && !IS_IOS && !vertical;
+    }
+
+    get _activeDotIndex () {
+        const { activeDotIndex, dotsLength } = this.props;
+        return this._needsRTLAdaptations() ? dotsLength - activeDotIndex - 1 : activeDotIndex;
+    }
+
+    get dots () {
+        const {
+            activeOpacity,
+            carouselRef,
+            dotsLength,
+            dotColor,
+            dotContainerStyle,
+            dotElement,
+            dotStyle,
+            inactiveDotColor,
+            inactiveDotElement,
+            inactiveDotOpacity,
+            inactiveDotScale,
+            inactiveDotStyle,
+            renderDots,
+            tappableDots,
+            animatedDuration,
+            animatedFriction,
+            animatedTension,
+            delayPressInDot
+        } = this.props;
+
+        if (renderDots) {
+            return renderDots(this._activeDotIndex, dotsLength, this);
+        }
+
+        const DefaultDot = <PaginationDot
+          carouselRef={carouselRef}
+          tappable={tappableDots && typeof carouselRef !== 'undefined'}
+          activeOpacity={activeOpacity}
+          color={dotColor}
+          containerStyle={dotContainerStyle}
+          style={dotStyle}
+          inactiveColor={inactiveDotColor}
+          inactiveOpacity={inactiveDotOpacity}
+          inactiveScale={inactiveDotScale}
+          inactiveStyle={inactiveDotStyle}
+          animatedDuration={animatedDuration}
+          animatedFriction={animatedFriction}
+          animatedTension={animatedTension}
+          delayPressInDot={delayPressInDot}
+        />;
+
+        const dots = [...Array(dotsLength).keys()].map(i => {
+            const isActive = i === this._activeDotIndex;
+            return React.cloneElement(
+                (isActive ? dotElement : inactiveDotElement) || DefaultDot,
+                {
+                    key: `pagination-dot-${i}`,
+                    active: isActive,
+                    index: i
+                }
+            );
+        });
+
+        return dots;
+    }
+
+    render () {
+        const { dotsLength, containerStyle, vertical, accessibilityLabel } = this.props;
+
+        if (!dotsLength || dotsLength < 2) {
+            return false;
+        }
+
+        const style = [
+            styles.sliderPagination,
+            { flexDirection: vertical ?
+                'column' :
+                (this._needsRTLAdaptations() ? 'row-reverse' : 'row')
+            },
+            containerStyle || {}
+        ];
+
+        return (
+            <View
+              pointerEvents={'box-none'}
+              style={style}
+              accessible={!!accessibilityLabel}
+              accessibilityLabel={accessibilityLabel}
+            >
+                { this.dots }
+            </View>
+        );
+    }
+}
diff --git a/node_modules/react-native-snap-carousel/src/pagination/Pagination.style.ts b/node_modules/react-native-snap-carousel/src/pagination/Pagination.style.js
similarity index 100%
rename from node_modules/react-native-snap-carousel/src/pagination/Pagination.style.ts
rename to node_modules/react-native-snap-carousel/src/pagination/Pagination.style.js
diff --git a/node_modules/react-native-snap-carousel/src/pagination/Pagination.tsx b/node_modules/react-native-snap-carousel/src/pagination/Pagination.tsx
deleted file mode 100644
index 2447c48..0000000
--- a/node_modules/react-native-snap-carousel/src/pagination/Pagination.tsx
+++ /dev/null
@@ -1,194 +0,0 @@
-import React, { PureComponent, ReactElement } from 'react';
-import {
-    I18nManager,
-    Platform,
-    View,
-    StyleProp,
-    ViewStyle
-} from 'react-native';
-import PaginationDot from './PaginationDot';
-import styles from './Pagination.style';
-import type Carousel from 'src/carousel/Carousel';
-
-const IS_IOS = Platform.OS === 'ios';
-const IS_RTL = I18nManager.isRTL;
-
-type PaginationProps<TData> = {
-  activeDotIndex: number;
-  dotsLength: number;
-  activeOpacity?: number;
-  carouselRef?: Carousel<TData> | null;
-  containerStyle?: StyleProp<ViewStyle>;
-  dotColor?: string;
-  dotContainerStyle?: StyleProp<ViewStyle>;
-  dotElement?: ReactElement;
-  dotStyle?: StyleProp<ViewStyle>;
-  inactiveDotColor?: string;
-  inactiveDotElement?: ReactElement;
-  inactiveDotOpacity: number;
-  inactiveDotScale: number;
-  inactiveDotStyle?: StyleProp<ViewStyle>;
-  renderDots?: (
-    activeIndex: number,
-    length: number,
-    context: Pagination<TData>
-  ) => ReactElement;
-  tappableDots: boolean;
-  vertical: boolean;
-  accessibilityLabel?: string;
-  animatedDuration: number;
-  animatedFriction: number;
-  animatedTension: number;
-  delayPressInDot: number;
-};
-
-export default class Pagination<TData> extends PureComponent<PaginationProps<TData>> {
-  static defaultProps = {
-      inactiveDotOpacity: 0.5,
-      inactiveDotScale: 0.5,
-      tappableDots: false,
-      vertical: false,
-      animatedDuration: 250,
-      animatedFriction: 4,
-      animatedTension: 50,
-      delayPressInDot: 0
-  };
-
-  constructor (props: PaginationProps<TData>) {
-      super(props);
-
-      // Warnings
-      if (
-          (props.dotColor && !props.inactiveDotColor) ||
-      (!props.dotColor && props.inactiveDotColor)
-      ) {
-          console.warn(
-              'react-native-snap-carousel | Pagination: ' +
-          'You need to specify both `dotColor` and `inactiveDotColor`'
-          );
-      }
-      if (
-          (props.dotElement && !props.inactiveDotElement) ||
-      (!props.dotElement && props.inactiveDotElement)
-      ) {
-          console.warn(
-              'react-native-snap-carousel | Pagination: ' +
-          'You need to specify both `dotElement` and `inactiveDotElement`'
-          );
-      }
-      if (props.tappableDots && props.carouselRef === undefined) {
-          console.warn(
-              'react-native-snap-carousel | Pagination: ' +
-          'You must specify prop `carouselRef` when setting `tappableDots` to `true`'
-          );
-      }
-  }
-
-  _needsRTLAdaptations () {
-      const { vertical } = this.props;
-      return IS_RTL && !IS_IOS && !vertical;
-  }
-
-  get _activeDotIndex () {
-      const { activeDotIndex, dotsLength } = this.props;
-      return this._needsRTLAdaptations() ?
-          dotsLength - activeDotIndex - 1 :
-          activeDotIndex;
-  }
-
-  get dots () {
-      const {
-          activeOpacity,
-          carouselRef,
-          dotsLength,
-          dotColor,
-          dotContainerStyle,
-          dotElement,
-          dotStyle,
-          inactiveDotColor,
-          inactiveDotElement,
-          inactiveDotOpacity,
-          inactiveDotScale,
-          inactiveDotStyle,
-          renderDots,
-          tappableDots,
-          animatedDuration,
-          animatedFriction,
-          animatedTension,
-          delayPressInDot
-      } = this.props;
-
-      if (renderDots) {
-          return renderDots(this._activeDotIndex, dotsLength, this);
-      }
-
-      const DefaultDot = (
-          <PaginationDot
-            carouselRef={carouselRef}
-            tappable={tappableDots && typeof carouselRef !== 'undefined'}
-            activeOpacity={activeOpacity}
-            color={dotColor}
-            containerStyle={dotContainerStyle}
-            style={dotStyle}
-            inactiveColor={inactiveDotColor}
-            inactiveOpacity={inactiveDotOpacity}
-            inactiveScale={inactiveDotScale}
-            inactiveStyle={inactiveDotStyle}
-            animatedDuration={animatedDuration}
-            animatedFriction={animatedFriction}
-            animatedTension={animatedTension}
-            delayPressInDot={delayPressInDot}
-          />
-      );
-
-      const dots = [...Array(dotsLength).keys()].map((i) => {
-          const isActive = i === this._activeDotIndex;
-          return React.cloneElement(
-              (isActive ? dotElement : inactiveDotElement) || DefaultDot,
-              {
-                  key: `pagination-dot-${i}`,
-                  active: isActive,
-                  index: i
-              }
-          );
-      });
-
-      return dots;
-  }
-
-  render () {
-      const {
-          dotsLength,
-          containerStyle,
-          vertical,
-          accessibilityLabel
-      } = this.props;
-
-      if (!dotsLength || dotsLength < 2) {
-          return false;
-      }
-
-      const style = [
-          styles.sliderPagination,
-          {
-              flexDirection: vertical ?
-                  ('column' as const) :
-                  this._needsRTLAdaptations() ?
-                      ('row-reverse' as const) :
-                      ('row' as const)
-          },
-          containerStyle || {}
-      ];
-
-      return (
-          <View
-            pointerEvents='box-none'
-            style={style}
-            accessible={!!accessibilityLabel}
-            accessibilityLabel={accessibilityLabel}
-          >
-              {this.dots}
-          </View>
-      );
-  }
-}
diff --git a/node_modules/react-native-snap-carousel/src/pagination/PaginationDot.tsx b/node_modules/react-native-snap-carousel/src/pagination/PaginationDot.js
similarity index 52%
rename from node_modules/react-native-snap-carousel/src/pagination/PaginationDot.tsx
rename to node_modules/react-native-snap-carousel/src/pagination/PaginationDot.js
index 8ea5c47..3b708b0 100644
--- a/node_modules/react-native-snap-carousel/src/pagination/PaginationDot.tsx
+++ b/node_modules/react-native-snap-carousel/src/pagination/PaginationDot.js
@@ -1,44 +1,30 @@
-import React, { PureComponent, RefObject } from 'react';
-import {
-    Animated,
-    Easing,
-    TouchableOpacity,
-    StyleProp,
-    ViewStyle
-} from 'react-native';
+import React, { PureComponent } from 'react';
+import { View, Animated, Easing, TouchableOpacity, ViewPropTypes } from 'react-native';
+import PropTypes from 'prop-types';
 import styles from './Pagination.style';
-import type Carousel from 'src/carousel/Carousel';
-
-type PaginationDotProps<TData> = {
-  inactiveOpacity: number;
-  inactiveScale: number;
-  active?: boolean;
-  activeOpacity?: number;
-  animatedDuration?: number;
-  animatedFriction?: number;
-  animatedTension?: number;
-  carouselRef?: Carousel<TData> | RefObject<Carousel<TData>> | null;
-  color?: string;
-  containerStyle?: StyleProp<ViewStyle>;
-  delayPressInDot?: number;
-  inactiveColor?: string;
-  inactiveStyle?: StyleProp<ViewStyle>;
-  index?: number;
-  style?: StyleProp<ViewStyle>;
-  tappable?: boolean;
-};
-
-type PaginationDotState = {
-  animColor: Animated.Value;
-  animOpacity: Animated.Value;
-  animTransform: Animated.Value;
-};
-
-export default class PaginationDot<TData> extends PureComponent<
-  PaginationDotProps<TData>,
-  PaginationDotState
-> {
-    constructor (props: PaginationDotProps<TData>) {
+
+export default class PaginationDot extends PureComponent {
+
+    static propTypes = {
+        inactiveOpacity: PropTypes.number.isRequired,
+        inactiveScale: PropTypes.number.isRequired,
+        active: PropTypes.bool,
+        activeOpacity: PropTypes.number,
+        animatedDuration: PropTypes.number,
+        animatedFriction: PropTypes.number,
+        animatedTension: PropTypes.number,
+        carouselRef: PropTypes.object,
+        color: PropTypes.string,
+        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        delayPressInDot: PropTypes.number,
+        inactiveColor: PropTypes.string,
+        inactiveStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        index: PropTypes.number,
+        style: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        tappable: PropTypes.bool
+    };
+
+    constructor (props) {
         super(props);
         this.state = {
             animColor: new Animated.Value(0),
@@ -53,7 +39,7 @@ export default class PaginationDot<TData> extends PureComponent<
         }
     }
 
-    componentDidUpdate (prevProps: PaginationDotProps<TData>) {
+    componentDidUpdate (prevProps) {
         if (prevProps.active !== this.props.active) {
             this._animate(this.props.active ? 1 : 0);
         }
@@ -69,7 +55,7 @@ export default class PaginationDot<TData> extends PureComponent<
             useNativeDriver: !this._shouldAnimateColor
         };
 
-        const animations = [
+        let animations = [
             Animated.timing(animOpacity, {
                 easing: Easing.linear,
                 duration: animatedDuration,
@@ -83,12 +69,10 @@ export default class PaginationDot<TData> extends PureComponent<
         ];
 
         if (this._shouldAnimateColor) {
-            animations.push(
-                Animated.timing(animColor, {
-                    easing: Easing.linear,
-                    ...commonProperties
-                })
-            );
+            animations.push(Animated.timing(animColor, {
+                easing: Easing.linear,
+                ...commonProperties
+            }));
         }
 
         Animated.parallel(animations).start();
@@ -122,24 +106,19 @@ export default class PaginationDot<TData> extends PureComponent<
                 inputRange: [0, 1],
                 outputRange: [inactiveOpacity, 1]
             }),
-            transform: [
-                {
-                    scale: animTransform.interpolate({
-                        inputRange: [0, 1],
-                        outputRange: [inactiveScale, 1]
-                    })
-                }
-            ]
+            transform: [{
+                scale: animTransform.interpolate({
+                    inputRange: [0, 1],
+                    outputRange: [inactiveScale, 1]
+                })
+            }]
         };
-        const animatedColor =
-      this._shouldAnimateColor && inactiveColor && color ?
-          {
-              backgroundColor: animColor.interpolate({
-                  inputRange: [0, 1],
-                  outputRange: [inactiveColor, color]
-              })
-          } :
-          {};
+        const animatedColor = this._shouldAnimateColor ? {
+            backgroundColor: animColor.interpolate({
+                inputRange: [0, 1],
+                outputRange: [inactiveColor, color]
+            })
+        } : {};
 
         const dotContainerStyle = [
             styles.sliderPaginationDotContainer,
@@ -154,25 +133,17 @@ export default class PaginationDot<TData> extends PureComponent<
             animatedColor
         ];
 
-        const onPress =
-      tappable && (!!index || index === 0) ?
-          () => {
-              try {
-                  const currentRef =
-                carouselRef && 'current' in carouselRef ?
-                    carouselRef.current :
-                    carouselRef;
-              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-              currentRef!._snapToItem(currentRef!._getPositionIndex(index));
-              } catch (error) {
-                  console.warn(
-                      'react-native-snap-carousel | Pagination: ' +
-                  '`carouselRef` has to be a Carousel ref.\n' +
-                  error
-                  );
-              }
-          } :
-          undefined;
+        const onPress = tappable ? () => {
+            try {
+                const currentRef = carouselRef.current || carouselRef;
+                currentRef._snapToItem(currentRef._getPositionIndex(index));
+            } catch (error) {
+                console.warn(
+                    'react-native-snap-carousel | Pagination: ' +
+                    '`carouselRef` has to be a Carousel ref.\n' + error
+                );
+            }
+        } : undefined;
 
         return (
             <TouchableOpacity
diff --git a/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.js b/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.js
new file mode 100644
index 0000000..8bc774a
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.js
@@ -0,0 +1,222 @@
+// Parallax effect inspired by https://github.com/oblador/react-native-parallax/
+
+import React, { Component } from 'react';
+import { View, ViewPropTypes, Image, Animated, Easing, ActivityIndicator, findNodeHandle } from 'react-native';
+import PropTypes from 'prop-types';
+import styles from './ParallaxImage.style';
+
+export default class ParallaxImage extends Component {
+
+    static propTypes = {
+        ...Image.propTypes,
+        carouselRef: PropTypes.object, // passed from <Carousel />
+        itemHeight: PropTypes.number, // passed from <Carousel />
+        itemWidth: PropTypes.number, // passed from <Carousel />
+        scrollPosition: PropTypes.object, // passed from <Carousel />
+        sliderHeight: PropTypes.number, // passed from <Carousel />
+        sliderWidth: PropTypes.number, // passed from <Carousel />
+        vertical: PropTypes.bool, // passed from <Carousel />
+        containerStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,
+        dimensions: PropTypes.shape({
+            width: PropTypes.number,
+            height: PropTypes.number
+        }),
+        fadeDuration: PropTypes.number,
+        parallaxFactor: PropTypes.number,
+        showSpinner: PropTypes.bool,
+        spinnerColor: PropTypes.string,
+        AnimatedImageComponent: PropTypes.oneOfType([
+            PropTypes.func,
+            PropTypes.object
+        ])
+    };
+
+    static defaultProps = {
+        containerStyle: {},
+        fadeDuration: 500,
+        parallaxFactor: 0.3,
+        showSpinner: true,
+        spinnerColor: 'rgba(0, 0, 0, 0.4)',
+        AnimatedImageComponent: Animated.Image
+    }
+
+    constructor (props) {
+        super(props);
+        this.state = {
+            offset: 0,
+            width: 0,
+            height: 0,
+            status: 1, // 1 -> loading; 2 -> loaded // 3 -> transition finished; 4 -> error
+            animOpacity: new Animated.Value(0)
+        };
+        this._onLoad = this._onLoad.bind(this);
+        this._onError = this._onError.bind(this);
+        this._measureLayout = this._measureLayout.bind(this);
+    }
+
+    setNativeProps (nativeProps) {
+        this._container.setNativeProps(nativeProps);
+    }
+
+    componentDidMount () {
+        this._mounted = true;
+
+        setTimeout(() => {
+            this._measureLayout();
+        }, 0);
+    }
+
+    componentWillUnmount () {
+        this._mounted = false;
+    }
+
+    _measureLayout () {
+        if (this._container) {
+            const {
+                dimensions,
+                vertical,
+                carouselRef,
+                sliderWidth,
+                sliderHeight,
+                itemWidth,
+                itemHeight
+            } = this.props;
+
+            if (carouselRef) {
+                this._container.measureLayout(
+                    findNodeHandle(carouselRef),
+                    (x, y, width, height, pageX, pageY) => {
+                        const offset = vertical ?
+                            y - ((sliderHeight - itemHeight) / 2) :
+                            x - ((sliderWidth - itemWidth) / 2);
+
+                        this.setState({
+                            offset: offset,
+                            width: dimensions && dimensions.width ?
+                                dimensions.width :
+                                Math.ceil(width),
+                            height: dimensions && dimensions.height ?
+                                dimensions.height :
+                                Math.ceil(height)
+                        });
+                    }
+                );
+            }
+        }
+    }
+
+    _onLoad (event) {
+        const { animOpacity } = this.state;
+        const { fadeDuration, onLoad } = this.props;
+
+        if (!this._mounted) {
+            return;
+        }
+
+        this.setState({ status: 2 });
+
+        if (onLoad) {
+            onLoad(event);
+        }
+
+        Animated.timing(animOpacity, {
+            toValue: 1,
+            duration: fadeDuration,
+            easing: Easing.out(Easing.quad),
+            isInteraction: false,
+            useNativeDriver: true
+        }).start(() => {
+            this.setState({ status: 3 });
+        });
+    }
+
+    // If arg is missing from method signature, it just won't be called
+    _onError (event) {
+        const { onError } = this.props;
+
+        this.setState({ status: 4 });
+
+        if (onError) {
+            onError(event);
+        }
+    }
+
+    get image () {
+        const { status, animOpacity, offset, width, height } = this.state;
+        const {
+            scrollPosition,
+            dimensions,
+            vertical,
+            sliderWidth,
+            sliderHeight,
+            parallaxFactor,
+            style,
+            AnimatedImageComponent,
+            ...other
+        } = this.props;
+
+        const parallaxPadding = (vertical ? height : width) * parallaxFactor;
+        const requiredStyles = { position: 'relative' };
+        const dynamicStyles = {
+            width: vertical ? width : width + parallaxPadding * 2,
+            height: vertical ? height + parallaxPadding * 2 : height,
+            opacity: animOpacity,
+            transform: scrollPosition ? [
+                {
+                    translateX: !vertical ? scrollPosition.interpolate({
+                        inputRange: [offset - sliderWidth, offset + sliderWidth],
+                        outputRange: [-parallaxPadding, parallaxPadding],
+                        extrapolate: 'clamp'
+                    }) : 0
+                },
+                {
+                    translateY: vertical ? scrollPosition.interpolate({
+                        inputRange: [offset - sliderHeight, offset + sliderHeight],
+                        outputRange: [-parallaxPadding, parallaxPadding],
+                        extrapolate: 'clamp'
+                    }) : 0
+                }
+            ] : []
+        };
+
+        return (
+            <AnimatedImageComponent
+              {...other}
+              style={[styles.image, style, requiredStyles, dynamicStyles]}
+              onLoad={this._onLoad}
+              onError={status !== 3 ? this._onError : undefined} // prevent infinite-loop bug
+            />
+        );
+    }
+
+    get spinner () {
+        const { status } = this.state;
+        const { showSpinner, spinnerColor } = this.props;
+
+        return status === 1 && showSpinner ? (
+            <View style={styles.loaderContainer}>
+                <ActivityIndicator
+                  size={'small'}
+                  color={spinnerColor}
+                  animating={true}
+                />
+            </View>
+        ) : false;
+    }
+
+    render () {
+        const { containerStyle } = this.props;
+
+        return (
+            <View
+              ref={(c) => { this._container = c; }}
+              pointerEvents={'none'}
+              style={[containerStyle, styles.container]}
+              onLayout={this._measureLayout}
+            >
+                { this.image }
+                { this.spinner }
+            </View>
+        );
+    }
+}
diff --git a/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.ts b/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.js
similarity index 88%
rename from node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.ts
rename to node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.js
index 6c03836..a71ea47 100644
--- a/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.ts
+++ b/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.style.js
@@ -9,8 +9,8 @@ export default StyleSheet.create({
     image: {
         position: 'relative',
         resizeMode: 'cover',
-        width: undefined,
-        height: undefined
+        width: null,
+        height: null
     },
     loaderContainer: {
         ...StyleSheet.absoluteFillObject,
diff --git a/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.tsx b/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.tsx
deleted file mode 100644
index bac86b2..0000000
--- a/node_modules/react-native-snap-carousel/src/parallaximage/ParallaxImage.tsx
+++ /dev/null
@@ -1,264 +0,0 @@
-// Parallax effect inspired by https://github.com/oblador/react-native-parallax/
-
-import React, { Component } from 'react';
-import {
-    View,
-    Animated,
-    Easing,
-    ActivityIndicator,
-    findNodeHandle,
-    ImageProps,
-    StyleProp,
-    ViewStyle,
-    NativeSyntheticEvent,
-    ImageLoadEventData,
-    ImageErrorEventData
-} from 'react-native';
-import styles from './ParallaxImage.style';
-
-type VerticalProps = {
-    vertical: true;
-    sliderHeight: number; // passed from <Carousel />
-    itemHeight: number; // passed from <Carousel />
-}
-type HorizontalProps = {
-    vertical: false;
-    sliderWidth: number; // passed from <Carousel />
-    itemWidth: number; // passed from <Carousel />
-}
-
-type ParallaxImageProps = {
-  carouselRef: Parameters<typeof findNodeHandle>[0]; // passed from <Carousel />
-  scrollPosition: Animated.Value | undefined; // passed from <Carousel />
-  containerStyle: StyleProp<ViewStyle>;
-  dimensions?: {
-    width: number;
-    height: number;
-  };
-  fadeDuration: number;
-  parallaxFactor: number;
-  showSpinner: boolean;
-  spinnerColor: string;
-  AnimatedImageComponent: typeof Animated.Image;
-} & ImageProps & (VerticalProps | HorizontalProps);
-
-export enum ParallaxImageStatus {
-    'LOADING' = 1,
-    'LOADED' = 2,
-    'TRANSITION_FINISHED' = 3,
-    'ERROR' = 4
-}
-
-type ParallaxImageState = {
-  offset: number;
-  width: number;
-  height: number;
-  status: ParallaxImageStatus;
-  animOpacity: Animated.Value;
-};
-
-export default class ParallaxImage extends Component<
-  ParallaxImageProps,
-  ParallaxImageState
-> {
-  static defaultProps = {
-      containerStyle: {},
-      fadeDuration: 500,
-      parallaxFactor: 0.3,
-      showSpinner: true,
-      spinnerColor: 'rgba(0, 0, 0, 0.4)',
-      AnimatedImageComponent: Animated.Image
-  };
-
-  _container?: View | null;
-  _mounted?: boolean;
-
-  constructor (props: ParallaxImageProps) {
-      super(props);
-      this.state = {
-          offset: 0,
-          width: 0,
-          height: 0,
-          status: ParallaxImageStatus.LOADING,
-          animOpacity: new Animated.Value(0)
-      };
-      this._onLoad = this._onLoad.bind(this);
-      this._onError = this._onError.bind(this);
-      this._measureLayout = this._measureLayout.bind(this);
-  }
-
-  setNativeProps (nativeProps: { [key: string]: unknown }) {
-    this._container?.setNativeProps(nativeProps);
-  }
-
-  componentDidMount () {
-      this._mounted = true;
-
-      setTimeout(() => {
-          this._measureLayout();
-      }, 0);
-  }
-
-  componentWillUnmount () {
-      this._mounted = false;
-  }
-
-  _measureLayout () {
-      if (this._container) {
-          const {
-              dimensions,
-              carouselRef
-          } = this.props;
-
-          const nodeHandle = findNodeHandle(carouselRef);
-
-          if (carouselRef && nodeHandle) {
-              this._container.measureLayout(
-                  nodeHandle,
-                  (x, y, width, height) => {
-                      const offset = this.props.vertical ?
-                          y - (this.props.sliderHeight - this.props.itemHeight) / 2 :
-                          x - (this.props.sliderWidth - this.props.itemWidth) / 2;
-
-                      this.setState({
-                          offset: offset,
-                          width:
-                dimensions && dimensions.width ?
-                    dimensions.width :
-                    Math.ceil(width),
-                          height:
-                dimensions && dimensions.height ?
-                    dimensions.height :
-                    Math.ceil(height)
-                      });
-                  },
-                  // eslint-disable-next-line @typescript-eslint/no-empty-function
-                  () => {}
-              );
-          }
-      }
-  }
-
-  _onLoad (event: NativeSyntheticEvent<ImageLoadEventData>) {
-      const { animOpacity } = this.state;
-      const { fadeDuration, onLoad } = this.props;
-
-      if (!this._mounted) {
-          return;
-      }
-
-      this.setState({ status: ParallaxImageStatus.LOADED });
-
-      if (onLoad) {
-          onLoad(event);
-      }
-
-      Animated.timing(animOpacity, {
-          toValue: 1,
-          duration: fadeDuration,
-          easing: Easing.out(Easing.quad),
-          isInteraction: false,
-          useNativeDriver: true
-      }).start(() => {
-          this.setState({ status: ParallaxImageStatus.TRANSITION_FINISHED });
-      });
-  }
-
-  // If arg is missing from method signature, it just won't be called
-  _onError (event: NativeSyntheticEvent<ImageErrorEventData>) {
-      const { onError } = this.props;
-
-      this.setState({ status: ParallaxImageStatus.ERROR });
-
-      if (onError) {
-          onError(event);
-      }
-  }
-
-  get image () {
-      const { status, animOpacity, offset, width, height } = this.state;
-      const {
-          scrollPosition,
-          // False positive :( other doesn't have the dimension key
-          // eslint-disable-next-line @typescript-eslint/no-unused-vars
-          dimensions,
-          parallaxFactor,
-          style,
-          AnimatedImageComponent,
-          ...other
-      } = this.props;
-      const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;
-      const requiredStyles = { position: 'relative' as const };
-      const dynamicStyles = {
-          width: this.props.vertical ? width : width + parallaxPadding * 2,
-          height: this.props.vertical ? height + parallaxPadding * 2 : height,
-          opacity: animOpacity,
-          transform: scrollPosition ?
-              [
-                  {
-                      translateX: !this.props.vertical ?
-                          scrollPosition.interpolate({
-                              inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],
-                              outputRange: [-parallaxPadding, parallaxPadding],
-                              extrapolate: 'clamp'
-                          }) :
-                          0
-                  },
-                  {
-                      translateY: this.props.vertical ?
-                          scrollPosition.interpolate({
-                              inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],
-                              outputRange: [-parallaxPadding, parallaxPadding],
-                              extrapolate: 'clamp'
-                          }) :
-                          0
-                  }
-              ] :
-              []
-      };
-
-      return (
-          <AnimatedImageComponent
-            {...other}
-            style={[styles.image, style, requiredStyles, dynamicStyles]}
-            onLoad={this._onLoad}
-            onError={status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined} // prevent infinite-loop bug
-          />
-      );
-  }
-
-  get spinner () {
-      const { status } = this.state;
-      const { showSpinner, spinnerColor } = this.props;
-
-      return status === ParallaxImageStatus.LOADING && showSpinner ? (
-          <View style={styles.loaderContainer}>
-              <ActivityIndicator
-                size='small'
-                color={spinnerColor}
-                animating={true}
-              />
-          </View>
-      ) : (
-          false
-      );
-  }
-
-  render () {
-      const { containerStyle } = this.props;
-
-      return (
-          <View
-            ref={(c) => {
-                this._container = c;
-            }}
-            pointerEvents='none'
-            style={[containerStyle, styles.container]}
-            onLayout={this._measureLayout}
-          >
-              {this.image}
-              {this.spinner}
-          </View>
-      );
-  }
-}
diff --git a/node_modules/react-native-snap-carousel/src/utils/animations.js b/node_modules/react-native-snap-carousel/src/utils/animations.js
new file mode 100644
index 0000000..bdb58b6
--- /dev/null
+++ b/node_modules/react-native-snap-carousel/src/utils/animations.js
@@ -0,0 +1,325 @@
+import { Platform } from 'react-native';
+
+const IS_ANDROID = Platform.OS === 'android';
+
+// Get scroll interpolator's input range from an array of slide indexes
+// Indexes are relative to the current active slide (index 0)
+// For example, using [3, 2, 1, 0, -1] will return:
+// [
+//     (index - 3) * sizeRef, // active + 3
+//     (index - 2) * sizeRef, // active + 2
+//     (index - 1) * sizeRef, // active + 1
+//     index * sizeRef, // active
+//     (index + 1) * sizeRef // active - 1
+// ]
+export function getInputRangeFromIndexes (range, index, carouselProps) {
+    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
+    let inputRange = [];
+
+    for (let i = 0; i < range.length; i++) {
+        inputRange.push((index - range[i]) * sizeRef);
+    }
+
+    return inputRange;
+}
+
+// Default behavior
+// Scale and/or opacity effect
+// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'
+export function defaultScrollInterpolator (index, carouselProps) {
+    const range = [1, 0, -1];
+    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
+    const outputRange = [0, 1, 0];
+
+    return { inputRange, outputRange };
+}
+export function defaultAnimatedStyles (index, animatedValue, carouselProps) {
+    let animatedOpacity = {};
+    let animatedScale = {};
+
+    if (carouselProps.inactiveSlideOpacity < 1) {
+        animatedOpacity = {
+            opacity: animatedValue.interpolate({
+                inputRange: [0, 1],
+                outputRange: [carouselProps.inactiveSlideOpacity, 1]
+            })
+        };
+    }
+
+    if (carouselProps.inactiveSlideScale < 1) {
+        animatedScale = {
+            transform: [{
+                scale: animatedValue.interpolate({
+                    inputRange: [0, 1],
+                    outputRange: [carouselProps.inactiveSlideScale, 1]
+                })
+            }]
+        };
+    }
+
+    return {
+        ...animatedOpacity,
+        ...animatedScale
+    };
+}
+
+// Shift animation
+// Same as the default one, but the active slide is also shifted up or down
+// Based on prop 'inactiveSlideShift'
+export function shiftAnimatedStyles (index, animatedValue, carouselProps) {
+    let animatedOpacity = {};
+    let animatedScale = {};
+    let animatedTranslate = {};
+
+    if (carouselProps.inactiveSlideOpacity < 1) {
+        animatedOpacity = {
+            opacity: animatedValue.interpolate({
+                inputRange: [0, 1],
+                outputRange: [carouselProps.inactiveSlideOpacity, 1]
+            })
+        };
+    }
+
+    if (carouselProps.inactiveSlideScale < 1) {
+        animatedScale = {
+            scale: animatedValue.interpolate({
+                inputRange: [0, 1],
+                outputRange: [carouselProps.inactiveSlideScale, 1]
+            })
+        };
+    }
+
+    if (carouselProps.inactiveSlideShift !== 0) {
+        const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';
+        animatedTranslate = {
+            [translateProp]: animatedValue.interpolate({
+                inputRange: [0, 1],
+                outputRange: [carouselProps.inactiveSlideShift, 0]
+            })
+        };
+    }
+
+    return {
+        ...animatedOpacity,
+        transform: [
+            { ...animatedScale },
+            { ...animatedTranslate }
+        ]
+    };
+}
+
+// Stack animation
+// Imitate a deck/stack of cards (see #195)
+// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
+// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
+// The `elevation` property compensates for that only visually, which is not good enough
+export function stackScrollInterpolator (index, carouselProps) {
+    const range = IS_ANDROID ?
+        [1, 0, -1, -2, -3] :
+        [3, 2, 1, 0, -1];
+    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
+    const outputRange = range;
+
+    return { inputRange, outputRange };
+}
+export function stackAnimatedStyles (index, animatedValue, carouselProps, cardOffset) {
+    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
+    const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
+
+    const card1Scale = 0.9;
+    const card2Scale = 0.8;
+
+    cardOffset = !cardOffset && cardOffset !== 0 ? 18 : cardOffset;
+
+    const getTranslateFromScale = (cardIndex, scale) => {
+        const centerFactor = 1 / scale * cardIndex;
+        const centeredPosition = -Math.round(sizeRef * centerFactor);
+        const edgeAlignment = Math.round((sizeRef - (sizeRef * scale)) / 2);
+        const offset = Math.round(cardOffset * Math.abs(cardIndex) / scale);
+
+        return IS_ANDROID ?
+            centeredPosition - edgeAlignment - offset :
+            centeredPosition + edgeAlignment + offset;
+    };
+
+    const opacityOutputRange = carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];
+
+    return IS_ANDROID ? {
+        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
+        opacity: animatedValue.interpolate({
+            inputRange: [-3, -2, -1, 0],
+            outputRange: opacityOutputRange.reverse(),
+            extrapolate: 'clamp'
+        }),
+        transform: [{
+            scale: animatedValue.interpolate({
+                inputRange: [-2, -1, 0, 1],
+                outputRange: [card2Scale, card1Scale, 1, card1Scale],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [translateProp]: animatedValue.interpolate({
+                inputRange: [-3, -2, -1, 0, 1],
+                outputRange: [
+                    getTranslateFromScale(-3, card2Scale),
+                    getTranslateFromScale(-2, card2Scale),
+                    getTranslateFromScale(-1, card1Scale),
+                    0,
+                    sizeRef * 0.5
+                ],
+                extrapolate: 'clamp'
+            })
+        }]
+    } : {
+        zIndex: carouselProps.data.length - index,
+        opacity: animatedValue.interpolate({
+            inputRange: [0, 1, 2, 3],
+            outputRange: opacityOutputRange,
+            extrapolate: 'clamp'
+        }),
+        transform: [{
+            scale: animatedValue.interpolate({
+                inputRange: [-1, 0, 1, 2],
+                outputRange: [card1Scale, 1, card1Scale, card2Scale],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [translateProp]: animatedValue.interpolate({
+                inputRange: [-1, 0, 1, 2, 3],
+                outputRange: [
+                    -sizeRef * 0.5,
+                    0,
+                    getTranslateFromScale(1, card1Scale),
+                    getTranslateFromScale(2, card2Scale),
+                    getTranslateFromScale(3, card2Scale)
+                ],
+                extrapolate: 'clamp'
+            })
+        }]
+    };
+}
+
+// Tinder animation
+// Imitate the popular Tinder layout
+// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
+// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
+// The `elevation` property compensates for that only visually, which is not good enough
+export function tinderScrollInterpolator (index, carouselProps) {
+    const range = IS_ANDROID ?
+        [1, 0, -1, -2, -3] :
+        [3, 2, 1, 0, -1];
+    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
+    const outputRange = range;
+
+    return { inputRange, outputRange };
+}
+export function tinderAnimatedStyles (index, animatedValue, carouselProps, cardOffset) {
+    const sizeRef = carouselProps.vertical ? carouselProps.itemHeight : carouselProps.itemWidth;
+    const mainTranslateProp = carouselProps.vertical ? 'translateY' : 'translateX';
+    const secondaryTranslateProp = carouselProps.vertical ? 'translateX' : 'translateY';
+
+    const card1Scale = 0.96;
+    const card2Scale = 0.92;
+    const card3Scale = 0.88;
+
+    const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;
+
+    cardOffset = !cardOffset && cardOffset !== 0 ? 9 : cardOffset;
+
+    const getMainTranslateFromScale = (cardIndex, scale) => {
+        const centerFactor = 1 / scale * cardIndex;
+        return -Math.round(sizeRef * centerFactor);
+    };
+
+    const getSecondaryTranslateFromScale = (cardIndex, scale) => {
+        return Math.round(cardOffset * Math.abs(cardIndex) / scale);
+    };
+
+    return IS_ANDROID ? {
+        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
+        opacity: animatedValue.interpolate({
+            inputRange: [-3, -2, -1, 0, 1],
+            outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],
+            extrapolate: 'clamp'
+        }),
+        transform: [{
+            scale: animatedValue.interpolate({
+                inputRange: [-3, -2, -1, 0],
+                outputRange: [card3Scale, card2Scale, card1Scale, 1],
+                extrapolate: 'clamp'
+            })
+        }, {
+            rotate: animatedValue.interpolate({
+                inputRange: [0, 1],
+                outputRange: ['0deg', '22deg'],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [mainTranslateProp]: animatedValue.interpolate({
+                inputRange: [-3, -2, -1, 0, 1],
+                outputRange: [
+                    getMainTranslateFromScale(-3, card3Scale),
+                    getMainTranslateFromScale(-2, card2Scale),
+                    getMainTranslateFromScale(-1, card1Scale),
+                    0,
+                    sizeRef * 1.1
+                ],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [secondaryTranslateProp]: animatedValue.interpolate({
+                inputRange: [-3, -2, -1, 0],
+                outputRange: [
+                    getSecondaryTranslateFromScale(-3, card3Scale),
+                    getSecondaryTranslateFromScale(-2, card2Scale),
+                    getSecondaryTranslateFromScale(-1, card1Scale),
+                    0
+                ],
+                extrapolate: 'clamp'
+            })
+        }]
+    } : {
+        zIndex: carouselProps.data.length - index,
+        opacity: animatedValue.interpolate({
+            inputRange: [-1, 0, 1, 2, 3],
+            outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],
+            extrapolate: 'clamp'
+        }),
+        transform: [{
+            scale: animatedValue.interpolate({
+                inputRange: [0, 1, 2, 3],
+                outputRange: [1, card1Scale, card2Scale, card3Scale],
+                extrapolate: 'clamp'
+            })
+        }, {
+            rotate: animatedValue.interpolate({
+                inputRange: [-1, 0],
+                outputRange: ['-22deg', '0deg'],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [mainTranslateProp]: animatedValue.interpolate({
+                inputRange: [-1, 0, 1, 2, 3],
+                outputRange: [
+                    -sizeRef * 1.1,
+                    0,
+                    getMainTranslateFromScale(1, card1Scale),
+                    getMainTranslateFromScale(2, card2Scale),
+                    getMainTranslateFromScale(3, card3Scale)
+                ],
+                extrapolate: 'clamp'
+            })
+        }, {
+            [secondaryTranslateProp]: animatedValue.interpolate({
+                inputRange: [0, 1, 2, 3],
+                outputRange: [
+                    0,
+                    getSecondaryTranslateFromScale(1, card1Scale),
+                    getSecondaryTranslateFromScale(2, card2Scale),
+                    getSecondaryTranslateFromScale(3, card3Scale)
+                ],
+                extrapolate: 'clamp'
+            })
+        }]
+    };
+}
diff --git a/node_modules/react-native-snap-carousel/src/utils/animations.ts b/node_modules/react-native-snap-carousel/src/utils/animations.ts
deleted file mode 100644
index bf1c50f..0000000
--- a/node_modules/react-native-snap-carousel/src/utils/animations.ts
+++ /dev/null
@@ -1,383 +0,0 @@
-import { Platform, Animated } from 'react-native';
-import type { CarouselProps } from 'src/carousel/types';
-
-const IS_ANDROID = Platform.OS === 'android';
-
-// Get scroll interpolator's input range from an array of slide indexes
-// Indexes are relative to the current active slide (index 0)
-// For example, using [3, 2, 1, 0, -1] will return:
-// [
-//     (index - 3) * sizeRef, // active + 3
-//     (index - 2) * sizeRef, // active + 2
-//     (index - 1) * sizeRef, // active + 1
-//     index * sizeRef, // active
-//     (index + 1) * sizeRef // active - 1
-// ]
-export function getInputRangeFromIndexes<TData> (
-    range: number[],
-    index: number,
-    carouselProps: CarouselProps<TData>
-) {
-    const sizeRef = carouselProps.vertical ?
-        carouselProps.itemHeight :
-        carouselProps.itemWidth;
-    const inputRange = [];
-
-    for (let i = 0; i < range.length; i++) {
-        inputRange.push((index - range[i]) * sizeRef);
-    }
-
-    return inputRange;
-}
-
-// Default behavior
-// Scale and/or opacity effect
-// Based on props 'inactiveSlideOpacity' and 'inactiveSlideScale'
-export function defaultScrollInterpolator<TData> (
-    index: number,
-    carouselProps: CarouselProps<TData>
-) {
-    const range = [1, 0, -1];
-    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-    const outputRange = [0, 1, 0];
-
-    return { inputRange, outputRange };
-}
-export function defaultAnimatedStyles<TData> (
-    _index: number,
-    animatedValue: Animated.AnimatedInterpolation,
-    carouselProps: CarouselProps<TData>
-) {
-    let animatedOpacity = {};
-    let animatedScale = {};
-
-    if (carouselProps.inactiveSlideOpacity < 1) {
-        animatedOpacity = {
-            opacity: animatedValue.interpolate({
-                inputRange: [0, 1],
-                outputRange: [carouselProps.inactiveSlideOpacity, 1]
-            })
-        };
-    }
-
-    if (carouselProps.inactiveSlideScale < 1) {
-        animatedScale = {
-            transform: [
-                {
-                    scale: animatedValue.interpolate({
-                        inputRange: [0, 1],
-                        outputRange: [carouselProps.inactiveSlideScale, 1]
-                    })
-                }
-            ]
-        };
-    }
-
-    return {
-        ...animatedOpacity,
-        ...animatedScale
-    };
-}
-
-// Shift animation
-// Same as the default one, but the active slide is also shifted up or down
-// Based on prop 'inactiveSlideShift'
-export function shiftAnimatedStyles<TData> (
-    _index: number,
-    animatedValue: Animated.AnimatedInterpolation,
-    carouselProps: CarouselProps<TData>
-) {
-    let animatedOpacity = {};
-    let animatedScale = {};
-    let animatedTranslate = {};
-
-    if (carouselProps.inactiveSlideOpacity < 1) {
-        animatedOpacity = {
-            opacity: animatedValue.interpolate({
-                inputRange: [0, 1],
-                outputRange: [carouselProps.inactiveSlideOpacity, 1]
-            })
-        };
-    }
-
-    if (carouselProps.inactiveSlideScale < 1) {
-        animatedScale = {
-            scale: animatedValue.interpolate({
-                inputRange: [0, 1],
-                outputRange: [carouselProps.inactiveSlideScale, 1]
-            })
-        };
-    }
-
-    if (carouselProps.inactiveSlideShift !== 0) {
-        const translateProp = carouselProps.vertical ? 'translateX' : 'translateY';
-        animatedTranslate = {
-            [translateProp]: animatedValue.interpolate({
-                inputRange: [0, 1],
-                outputRange: [carouselProps.inactiveSlideShift, 0]
-            })
-        };
-    }
-
-    return {
-        ...animatedOpacity,
-        transform: [{ ...animatedScale }, { ...animatedTranslate }]
-    };
-}
-
-// Stack animation
-// Imitate a deck/stack of cards (see #195)
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-export function stackScrollInterpolator<TData> (
-    index: number,
-    carouselProps: CarouselProps<TData>
-) {
-    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-    const outputRange = range;
-
-    return { inputRange, outputRange };
-}
-export function stackAnimatedStyles<TData> (
-    index: number,
-    animatedValue: Animated.AnimatedInterpolation,
-    carouselProps: CarouselProps<TData>,
-    cardOffset?: number
-) {
-    const sizeRef = carouselProps.vertical ?
-        carouselProps.itemHeight :
-        carouselProps.itemWidth;
-    const translateProp = carouselProps.vertical ? 'translateY' : 'translateX';
-
-    const card1Scale = 0.9;
-    const card2Scale = 0.8;
-
-    const newCardOffset = cardOffset ?? 18;
-
-    const getTranslateFromScale = (cardIndex: number, scale: number) => {
-        const centerFactor = (1 / scale) * cardIndex;
-        const centeredPosition = -Math.round(sizeRef * centerFactor);
-        const edgeAlignment = Math.round((sizeRef - sizeRef * scale) / 2);
-        const offset = Math.round((newCardOffset * Math.abs(cardIndex)) / scale);
-
-        return IS_ANDROID ?
-            centeredPosition - edgeAlignment - offset :
-            centeredPosition + edgeAlignment + offset;
-    };
-
-    const opacityOutputRange =
-    carouselProps.inactiveSlideOpacity === 1 ? [1, 1, 1, 0] : [1, 0.75, 0.5, 0];
-
-    return IS_ANDROID ?
-        {
-        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-            opacity: animatedValue.interpolate({
-                inputRange: [-3, -2, -1, 0],
-                outputRange: opacityOutputRange.reverse(),
-                extrapolate: 'clamp'
-            }),
-            transform: [
-                {
-                    scale: animatedValue.interpolate({
-                        inputRange: [-2, -1, 0, 1],
-                        outputRange: [card2Scale, card1Scale, 1, card1Scale],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [translateProp]: animatedValue.interpolate({
-                        inputRange: [-3, -2, -1, 0, 1],
-                        outputRange: [
-                            getTranslateFromScale(-3, card2Scale),
-                            getTranslateFromScale(-2, card2Scale),
-                            getTranslateFromScale(-1, card1Scale),
-                            0,
-                            sizeRef * 0.5
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                }
-            ]
-        } :
-        {
-            zIndex: carouselProps.data.length - index,
-            opacity: animatedValue.interpolate({
-                inputRange: [0, 1, 2, 3],
-                outputRange: opacityOutputRange,
-                extrapolate: 'clamp'
-            }),
-            transform: [
-                {
-                    scale: animatedValue.interpolate({
-                        inputRange: [-1, 0, 1, 2],
-                        outputRange: [card1Scale, 1, card1Scale, card2Scale],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [translateProp]: animatedValue.interpolate({
-                        inputRange: [-1, 0, 1, 2, 3],
-                        outputRange: [
-                            -sizeRef * 0.5,
-                            0,
-                            getTranslateFromScale(1, card1Scale),
-                            getTranslateFromScale(2, card2Scale),
-                            getTranslateFromScale(3, card2Scale)
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                }
-            ]
-        };
-}
-
-// Tinder animation
-// Imitate the popular Tinder layout
-// WARNING: The effect had to be visually inverted on Android because this OS doesn't honor the `zIndex`property
-// This means that the item with the higher zIndex (and therefore the tap receiver) remains the one AFTER the currently active item
-// The `elevation` property compensates for that only visually, which is not good enough
-export function tinderScrollInterpolator<TData> (
-    index: number,
-    carouselProps: CarouselProps<TData>
-) {
-    const range = IS_ANDROID ? [1, 0, -1, -2, -3] : [3, 2, 1, 0, -1];
-    const inputRange = getInputRangeFromIndexes(range, index, carouselProps);
-    const outputRange = range;
-
-    return { inputRange, outputRange };
-}
-export function tinderAnimatedStyles<TData> (
-    index: number,
-    animatedValue: Animated.AnimatedInterpolation,
-    carouselProps: CarouselProps<TData>,
-    cardOffset?: number
-) {
-    const sizeRef = carouselProps.vertical ?
-        carouselProps.itemHeight :
-        carouselProps.itemWidth;
-    const mainTranslateProp = carouselProps.vertical ?
-        'translateY' :
-        'translateX';
-    const secondaryTranslateProp = carouselProps.vertical ?
-        'translateX' :
-        'translateY';
-
-    const card1Scale = 0.96;
-    const card2Scale = 0.92;
-    const card3Scale = 0.88;
-
-    const peekingCardsOpacity = IS_ANDROID ? 0.92 : 1;
-
-    const newCardOffset = cardOffset ?? 9;
-
-    const getMainTranslateFromScale = (cardIndex: number, scale: number) => {
-        const centerFactor = (1 / scale) * cardIndex;
-        return -Math.round(sizeRef * centerFactor);
-    };
-
-    const getSecondaryTranslateFromScale = (cardIndex: number, scale: number) => {
-        return Math.round((newCardOffset * Math.abs(cardIndex)) / scale);
-    };
-
-    return IS_ANDROID ?
-        {
-        // elevation: carouselProps.data.length - index, // fix zIndex bug visually, but not from a logic point of view
-            opacity: animatedValue.interpolate({
-                inputRange: [-3, -2, -1, 0, 1],
-                outputRange: [0, peekingCardsOpacity, peekingCardsOpacity, 1, 0],
-                extrapolate: 'clamp'
-            }),
-            transform: [
-                {
-                    scale: animatedValue.interpolate({
-                        inputRange: [-3, -2, -1, 0],
-                        outputRange: [card3Scale, card2Scale, card1Scale, 1],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    rotate: animatedValue.interpolate({
-                        inputRange: [0, 1],
-                        outputRange: ['0deg', '22deg'],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [mainTranslateProp]: animatedValue.interpolate({
-                        inputRange: [-3, -2, -1, 0, 1],
-                        outputRange: [
-                            getMainTranslateFromScale(-3, card3Scale),
-                            getMainTranslateFromScale(-2, card2Scale),
-                            getMainTranslateFromScale(-1, card1Scale),
-                            0,
-                            sizeRef * 1.1
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [secondaryTranslateProp]: animatedValue.interpolate({
-                        inputRange: [-3, -2, -1, 0],
-                        outputRange: [
-                            getSecondaryTranslateFromScale(-3, card3Scale),
-                            getSecondaryTranslateFromScale(-2, card2Scale),
-                            getSecondaryTranslateFromScale(-1, card1Scale),
-                            0
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                }
-            ]
-        } :
-        {
-            zIndex: carouselProps.data.length - index,
-            opacity: animatedValue.interpolate({
-                inputRange: [-1, 0, 1, 2, 3],
-                outputRange: [0, 1, peekingCardsOpacity, peekingCardsOpacity, 0],
-                extrapolate: 'clamp'
-            }),
-            transform: [
-                {
-                    scale: animatedValue.interpolate({
-                        inputRange: [0, 1, 2, 3],
-                        outputRange: [1, card1Scale, card2Scale, card3Scale],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    rotate: animatedValue.interpolate({
-                        inputRange: [-1, 0],
-                        outputRange: ['-22deg', '0deg'],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [mainTranslateProp]: animatedValue.interpolate({
-                        inputRange: [-1, 0, 1, 2, 3],
-                        outputRange: [
-                            -sizeRef * 1.1,
-                            0,
-                            getMainTranslateFromScale(1, card1Scale),
-                            getMainTranslateFromScale(2, card2Scale),
-                            getMainTranslateFromScale(3, card3Scale)
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                },
-                {
-                    [secondaryTranslateProp]: animatedValue.interpolate({
-                        inputRange: [0, 1, 2, 3],
-                        outputRange: [
-                            0,
-                            getSecondaryTranslateFromScale(1, card1Scale),
-                            getSecondaryTranslateFromScale(2, card2Scale),
-                            getSecondaryTranslateFromScale(3, card3Scale)
-                        ],
-                        extrapolate: 'clamp'
-                    })
-                }
-            ]
-        };
-}
diff --git a/node_modules/react-native-snap-carousel/tsconfig.json b/node_modules/react-native-snap-carousel/tsconfig.json
deleted file mode 100644
index 02d1606..0000000
--- a/node_modules/react-native-snap-carousel/tsconfig.json
+++ /dev/null
@@ -1,28 +0,0 @@
-{
-  "compilerOptions": {
-    "baseUrl": ".",
-    "paths": {
-      "react-native-snap-carousel": ["./src/index"]
-    },
-    "allowUnreachableCode": false,
-    "allowUnusedLabels": false,
-    "esModuleInterop": true,
-    "importsNotUsedAsValues": "error",
-    "forceConsistentCasingInFileNames": true,
-    "jsx": "react",
-    "lib": ["esnext"],
-    "module": "esnext",
-    "moduleResolution": "node",
-    "noFallthroughCasesInSwitch": true,
-    "noImplicitReturns": true,
-    "noImplicitUseStrict": false,
-    "noStrictGenericChecks": false,
-    "noUnusedLocals": true,
-    "noUnusedParameters": true,
-    "resolveJsonModule": true,
-    "skipLibCheck": true,
-    "strict": true,
-    "target": "esnext",
-  },
-  "include": ["src/**/*"]
-}
